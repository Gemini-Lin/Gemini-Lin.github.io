---
title: 操作系统第四章--存储器管理（内存）
date: 2020-08-12 21:59:38
tags:
- OS
- 内存管理
- 分页
- 分段
categories: 
- 课程总结
- 操作系统
---
![操作系统第四章--存储器管理（内存）](https://s1.ax1x.com/2020/08/12/axaINn.png)
<!DOCTYPE html>
<html>
<head>
<title>操作系统第四章--存储器管理（内存）</title>
<meta charset="utf-8"/>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="renderer" content="webkit"/>
<meta name="author" content="mubu.com"/>
</head>
<body style="margin: 50px 20px;color: #333;font-family: SourceSansPro,-apple-system,BlinkMacSystemFont,'PingFang SC',Helvetica,Arial,'Microsoft YaHei',微软雅黑,黑体,Heiti,sans-serif,SimSun,宋体,serif">
<div class="export-wrapper"><div style="font-size: 22px; padding: 0 15px 0;"><div style="padding-bottom: 24px">操作系统第四章--存储器管理（内存）</div><div style="background: #e5e6e8; height: 1px; margin-bottom: 20px;"></div></div><ul style="list-style: disc outside;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储器的层次结构</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储器的层次结构（缓存、内存、外存）</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">主存储器与寄存器</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">主存储器：</span>用于保存进程运行时的程序和数据。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">寄存器：</span>寄存器<span class="bold" style="font-weight: bold;">访问速度最快</span>，与CPU协调工作。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">高速缓存与磁盘缓存</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">高速缓存：</span>CPU对高速缓存的访问，其速度<span class="bold" style="font-weight: bold;">比访问主存快</span>，<span class="bold" style="font-weight: bold;">比访问寄存器慢</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">磁盘缓存：</span>内存中一块存储区，对应于某固定磁盘，<span class="bold" style="font-weight: bold;">临时存储磁盘数据</span>（如，数据预取）。<!--more--></span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储器管理的目的和功能</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">主存储器的分配和管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">记住每个存储区域的状态</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">实施分配</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">接受系统或用户释放的存储区域</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">提高主存储器的利用率</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">扩充主存容量</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储保护</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储分配的三种方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储分配：</span>解决多道作业之间<span class="bold" style="font-weight: bold;">共享主存</span>的问题</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">直接指定方式：</span>程序员在编程序时，或编译程序(汇编程序)对源程序进行编译(汇编)时，<span class="bold" style="font-weight: bold;">使用实际存储地址</span>。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">这种分配方式的实质是：</span>由编程人员在编写程序时，或由编译程序编译源程序时，<span class="bold" style="font-weight: bold;">对一个作业的所有信息确定在主存存储空间中的位置。</span>因此，这种直接指定方式的存储分配方案，不仅用户感到不便，而且存储空间的利用也不那么有效。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">静态分配方式：</span>用户在编程时，或由编译程序产生的目的程序，均可从其地址空间的零地址开始；当<span class="bold" style="font-weight: bold;">装配程序</span>对其进行连接装入时才确定它们在主存中的相应位置，从而生成可执行程序。也就是说，<span class="bold" style="font-weight: bold;">存储分配是在装入时实现的。</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(1)在一个作业装入时必须分配其要求的<span class="bold" style="font-weight: bold;">全部存储量</span>；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(2)如果<span class="bold" style="font-weight: bold;">没有足够的存储空间</span>，就不能装入该作业；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(3)一旦一个作业进入内存后，在其退出系统之前，它一直<span class="bold" style="font-weight: bold;">占用着分配给它的全部存储空间</span>；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(4) 作业在整个运行过程中不能在内存中“搬家”、也<span class="bold" style="font-weight: bold;">不能再申请存储量</span>。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">动态分配方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(1)作业在存储空间中的位置，也是在其<span class="bold" style="font-weight: bold;">装入时确定</span>的；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(2)在其执行过程中可根据需要<span class="bold" style="font-weight: bold;">申请附加的存储空间</span>；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(3)一个作业已占用的部分存储区域不再需要时，可以要求<span class="bold" style="font-weight: bold;">归还给系统</span>。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">即：这种存储分配机制能<span class="bold" style="font-weight: bold;">接受不可预测的分配和释放存储区域的请求</span>，实现个别存储区域的分配和回收；</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(4)存储区域的大小是<span class="bold" style="font-weight: bold;">可变的</span>；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(5)允许作业在内存中<span class="bold" style="font-weight: bold;">“搬家”</span>。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基本概念</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">逻辑地址：</span>&nbsp; 用户的程序经过<span class="bold" style="font-weight: bold;">汇编或编译</span>后形成目标代码，目标代码通常采用<span class="bold" style="font-weight: bold;">相对地址的形式</span>，其首地址为0，其余指令中的地址都相对于首地址而编址。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">物理地址：内存中存储单元的地址</span>，可直接寻址</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">名空间：</span>一个用<span class="bold" style="font-weight: bold;">高级语言编制</span>的<span class="bold" style="font-weight: bold;">源程序</span>，我们说它存在于由程序员建立的<span class="bold" style="font-weight: bold;">符号名字空间</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">地址空间：</span>程序用来访问信息所用地址单元的集合，是<span class="bold" style="font-weight: bold;">逻辑（相对）地址的集合</span>，由编译程序生成。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储空间：</span>主存中<span class="bold" style="font-weight: bold;">物理单元的集合</span>。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">程序的装入和链接</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">程序的装入</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">绝对装入方式：</span>在编译时，如果知道程序将驻留在内存的具体位置，那么<span class="bold" style="font-weight: bold;">编译程序</span>将产生<span class="bold" style="font-weight: bold;">实际存储地址（绝对地址）</span>的目标代码。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">可重定位装入方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">重定位（地址映射/地址变换）</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">重定位就是把程序的<span class="bold" style="font-weight: bold;">逻辑地址空间</span>变换成内存中的<span class="bold" style="font-weight: bold;">实际物理地址空间</span>的过程，也就是说在装入时对<span class="bold" style="font-weight: bold;">目标程序</span>中指令和数据的修改过程。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">静态重定位</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">地址变换是在<span class="bold" style="font-weight: bold;">装入内存时一次完成</span>的，且以后不能移动。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">一般情况下,<span class="bold" style="font-weight: bold;">物理地址=相对地址+内存中的起始地址</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">动态重定位</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">装入程序将装入模块装入内存后，<span class="bold" style="font-weight: bold;">并不立即</span>把装入模块中的<span class="bold" style="font-weight: bold;">相对地址转换为绝对地址</span>，而是<span class="bold" style="font-weight: bold;">把这种地址转换推迟到程序执行时进行</span>。</span></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">程序的链接</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">静态链接：</span>在<span class="bold" style="font-weight: bold;">程序运行之前</span>，先将各目标模块及它们所需的库函数，<span class="bold" style="font-weight: bold;">链接成一个完整的装入模块（又称执行模块）</span>，以后不再拆开。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">装入时动态链接：</span>用户源程序经编译后所得到的目标模块，<span class="bold" style="font-weight: bold;">是在装入内存时，边装入边链接的。</span>即在装入一个目标模块时，若发生一个外部模块调用，将引起装入程序去找出相应的外部目标模块，并将其装入内存。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">运行时动态链接：</span>将某些目标模块的<span class="bold" style="font-weight: bold;">链接推迟到执行时才进行</span>，即在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并链接到调用模块上。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">连续分配存储管理方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">连续分配方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">连续分配：</span>指为用户程序分配一个连续的内存空间</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">存储保护（存储分配的前提）</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">自动地址修改</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">0页，1页寻址</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">界限寄存器</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">单一连续分配：</span>内存中仅驻留<span class="bold" style="font-weight: bold;">一道用户程序</span>，整个用户区为<span class="bold" style="font-weight: bold;">一个用户独占</span>。内存分为两个区域：<span class="bold" style="font-weight: bold;">系统区，用户区</span>。应用程序装入到用户区，可使用用户区全部空间。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">固定分区分配：</span>将内存用户空间划分为若干个固定大小的区域，每个区域称为一个分区（region），<span class="bold" style="font-weight: bold;">在每个分区中只装入一道作业 </span>，从而支持多道程序并发设计。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分区的划分方式</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分区大小相等</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分区大小不等</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分区说明表：</span>指出可用于分配的分区数以及每个区的大小、起始地址及状态。&nbsp; &nbsp; </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">内存分配过程：</span>&nbsp;当有作业要装入内存时，<span class="bold" style="font-weight: bold;">内存分配程序检索分区说明表</span>，从中找出一个<span class="bold" style="font-weight: bold;">尚未使用的满足大小要求</span>的分区分配给该作业，然后修改分区的状态；如果找不到合适的分区就拒绝为该作业分配内存。 &nbsp;</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">内碎片：</span>内存中<span class="bold" style="font-weight: bold;">已分配给用户但未被利用的区域</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">动态分区分配：</span>根据进程的实际需要，<span class="bold" style="font-weight: bold;">动态</span>地为之<span class="bold" style="font-weight: bold;">分配连续</span>的内存空间。即分区的边界可以移动，分区的大小是可变的。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分区数目大小固定</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分区数目大小可变</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分区分配</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">数据结构</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">空闲分区表</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">空闲分区链</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分区分配算法</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基于顺序搜索：</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">(1)最佳适应算法(Best Fit)</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为一作业选择分区时总是<span class="bold" style="font-weight: bold;">寻找其大小最接近作业所要求的存储区域</span>。即：把作业放入这样的分区后剩下的零头最小。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">将存储空间中所有的空白区按其<span class="bold" style="font-weight: bold;">大小递增</span>的顺序链接起来，组成一<span class="bold" style="font-weight: bold;">空白区链(Free&nbsp; List)</span>。&nbsp; &nbsp;&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">(2)最坏适应算法(Worst Fit)</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为作业选择存储区域时，总是<span class="bold" style="font-weight: bold;">寻找最大的空白区</span>。在划分后<span class="bold" style="font-weight: bold;">剩下的空白区也是最大的</span>，因而对以后的分配很可能仍然是有用的</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">空白块应以<span class="bold" style="font-weight: bold;">大小递减</span>的顺序链接起来</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">(3)首次适应算法(First Fit)</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">每个空白区按其在存储空间中<span class="bold" style="font-weight: bold;">地址递增</span>的顺序链在一起，即每个后继空白区的起始地址总是比前者的大。在为作业分配存储区域时，从这个空白区链的始端开始查找，<span class="bold" style="font-weight: bold;">选择第一个足以满足请求的空白块</span>，而不管它究竟有多大。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">外零头：</span>没有分配但<span class="bold" style="font-weight: bold;">无法分配</span>的空间，在低地址部分会积累大量外零头</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">内零头：</span>分配给用户但用户<span class="bold" style="font-weight: bold;">没有使用</span>的空间，单一连续分配有较大的内零头</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">(<span class="bold" style="font-weight: bold;">4)循环首次（下次）适应算法(Next Fit)</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">我们把存储空间中空白区构成一个<span class="bold" style="font-weight: bold;">循环链</span>。每次为存储请求查找合适的分区时，总是<span class="bold" style="font-weight: bold;">从上次查找结束的地方开始</span>，只要找到一个足够大的空白区，就将它划分后分配出去。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基于索引搜索：</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">(5)快速适应算法(Quick Fit)</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">将空闲分区根据其<span class="bold" style="font-weight: bold;">容量大小</span>进行<span class="bold" style="font-weight: bold;">分类</span>，对于每一类具有相同容量的所有空闲分区，单独设立一个<span class="bold" style="font-weight: bold;">空闲分区链表</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">同时，在内存中设立一张<span class="bold" style="font-weight: bold;">管理分区类型</span>，并记录了该类型<span class="bold" style="font-weight: bold;">空闲分区链表表头的索引表</span>，该表的每一个表项记录了对应类型空闲分区链表表头的指针。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分配过程：</span>根据进程的长度，寻找到<span class="bold" style="font-weight: bold;">能容纳它的最小空闲分区链表</span>，并取下第一块进行分配即可</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">(6)伙伴系统</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分区分配操作</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分配内存：</span>向操作系统提出一特定存储量的请求。通常，它并不要求这个分配的存储区域限于特定的位置，但是，这个区域<span class="bold" style="font-weight: bold;">必须是连续的</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">回收内存：</span>进程用于<span class="bold" style="font-weight: bold;">归还</span>一个不再需用的存储区域。当进程运行完毕释放内存时，系统根据<span class="bold" style="font-weight: bold;">回收区的首址</span>，<span class="bold" style="font-weight: bold;">从空闲区链(表)中找到相应的插入点</span>。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">伙伴系统</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在伙伴系统中，<span class="bold" style="font-weight: bold;">可用内存块的大小为 2^k&nbsp;</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">对空闲区按照<span class="bold" style="font-weight: bold;">大小</span>分类，相同大小的分区链接为一个<span class="bold" style="font-weight: bold;">双向空闲链表</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">进程请求大小为n的存储空间</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">首先计算一个 i 值，使2^i－1&lt; n ≤ 2^i；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在空闲分区大小为2^i的空闲分区链表中查找。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">if&nbsp;找到，即把该空闲分区分配给进程。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">哈希算法</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">利用哈希快速查找的优点</span>，以及空闲分区在可利用空间表中的分布规律，建立哈希函数，构造一张<span class="bold" style="font-weight: bold;">哈希表</span>，以<span class="bold" style="font-weight: bold;">空闲分区大小为关键字</span>，每一个表项记录了一个对应的空闲分区链表表头指针。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当进行空闲分区分配时，根据<span class="bold" style="font-weight: bold;">所需空闲分区大小</span>，通过<span class="bold" style="font-weight: bold;">哈希函数计算</span>，即得到在哈希表中的位置，从中<span class="bold" style="font-weight: bold;">得到相应的空闲分区链表</span>，实现最佳分配策略。&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">可重定位分区分配</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">紧凑：</span>将内存中的所有作业进行移动，使它们全都相邻接，这样，可把<span class="bold" style="font-weight: bold;">原来分散的多个小分区合成一个大分区</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">动态重定位</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在<span class="bold" style="font-weight: bold;">动态运行时装入</span>的方式中，作业装入内存后的所有地址都仍然是相对地址，将<span class="bold" style="font-weight: bold;">相对地址转换为物理地址</span>的工作，被推迟到<span class="bold" style="font-weight: bold;">程序指令要真正执行</span>时进行。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">程序在执行时，真正访问的<span class="bold" style="font-weight: bold;">内存地址</span>是<span class="bold" style="font-weight: bold;">相对地址与重定位寄存器中的地址</span>相加而形成的。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">动态重定位分区分配算法</span></span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">对换</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">对换概念</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">指把<span class="bold" style="font-weight: bold;">内存中</span>暂时不能运行的进程或者暂时不用的<span class="bold" style="font-weight: bold;">程序和数据</span>， <span class="bold" style="font-weight: bold;">调出到外存上</span>，以便腾出足够的内存空间， 再把已具备运行条件的进程或进程所需要的程序和数据，调入内存</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">对换空间的管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在具有对换功能的OS中，通常把磁盘空间分为<span class="bold" style="font-weight: bold;">文件区和对换区</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">文件区：</span>为提高存储空间利用率，采用<span class="bold" style="font-weight: bold;">离散分配</span>方式； </span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">对换区：</span>为提高进程换入换出的速度，采用<span class="bold" style="font-weight: bold;">连续分配</span>方式&nbsp;</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">进程的换出</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">进程选择：</span>先选择阻塞状态的，后选择就绪状态的 ；尽量选择优先级低的 ；考虑内存驻留时间长短&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">进程的换入</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">系统定时地查看所有进程的状态，从中找出<span class="bold" style="font-weight: bold;">“就绪”状态但已换出的进程</span></span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基本分页存储管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">离散分配</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">连续分配引起：<span class="bold" style="font-weight: bold;">碎片</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">碎片问题的解决：<span class="bold" style="font-weight: bold;">紧凑</span>方式消耗系统开销</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分页：程序地址空间</span>划分为许多<span class="bold" style="font-weight: bold;">固定大小的页或页面</span>，<span class="bold" style="font-weight: bold;">内存空间</span>也按该大小划分为若干<span class="bold" style="font-weight: bold;">物理块或页框</span>；将程序页放入任一页框。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分段：程序地址空间</span>划分为若干个<span class="bold" style="font-weight: bold;">不同大小的段</span>，每个段可以定义一组相对完整的信息。<span class="bold" style="font-weight: bold;">以段为单位分配内存</span>，段间无需相邻。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">段页：</span>综合分页和分段</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分页存储管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">页面和物理块</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">页面：</span>将一个进程的<span class="bold" style="font-weight: bold;">逻辑地址空间</span>分成若干个<span class="bold" style="font-weight: bold;">大小相等的片</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">物理块（页框）：</span>把内<span class="bold" style="font-weight: bold;">存空间</span>分成与页面<span class="bold" style="font-weight: bold;">相同大小</span>的若干个<span class="bold" style="font-weight: bold;">存储块</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">在为进程分配内存时，以<span class="bold" style="font-weight: bold;">块为单位</span>将进程中的<span class="bold" style="font-weight: bold;">若干个页</span>分别装入到多个可以<span class="bold" style="font-weight: bold;">不相邻接的物理块</span>中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“<span class="bold" style="font-weight: bold;">页内碎片</span>”或称为“<span class="bold" style="font-weight: bold;">内零头</span>”。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">页表：</span>页号、块号&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">地址变换</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">页表寄存器PTR：</span>存放当前运行的进程的页表在内存中的<span class="bold" style="font-weight: bold;">起始地址</span>，此进程的<span class="bold" style="font-weight: bold;">页表长度</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">变换过程</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">分页地址变换机构会自动地将<span class="bold" style="font-weight: bold;">有效地址</span>(相对地址)分为<span class="bold" style="font-weight: bold;">页号</span>和<span class="bold" style="font-weight: bold;">页内地址</span>两部分，再以<span class="bold" style="font-weight: bold;">页号</span>为<span class="bold" style="font-weight: bold;">索引</span>去检索<span class="bold" style="font-weight: bold;">页表</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">查找操作由<span class="bold" style="font-weight: bold;">硬件</span>执行。在执行检索之前，先将<span class="bold" style="font-weight: bold;">页号与页表长度</span>进行比较，如果页号大于或等于页表长度，则产生一地址越界中断。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">若未出现越界错误，则将<span class="bold" style="font-weight: bold;">页表始址</span>与页号和页表项长度的<span class="bold" style="font-weight: bold;">乘积</span>相加，便得到该表项在页表中的位置，于是可从中得到该页的<span class="bold" style="font-weight: bold;">物理块号</span>，将之装入<span class="bold" style="font-weight: bold;">物理地址寄存器</span>中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">与此同时，再将有效地址寄存器中的<span class="bold" style="font-weight: bold;">页内地址</span>送入物理地址寄存器的<span class="bold" style="font-weight: bold;">块内地址</span>字段中。这样便完成了从逻辑地址到物理地址的变换。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">快表</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分页系统：</span>处理机每次存取指令或数据至少需要访问<span class="bold" style="font-weight: bold;">两次物理内存：</span>第一次访问<span class="bold" style="font-weight: bold;">页表，</span>第二次<span class="bold" style="font-weight: bold;">存取指令或数据</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">快表：</span>为了提高地址变换速度，为进程页表设置的一个专用的<span class="bold" style="font-weight: bold;">高速缓冲存储器，专门保存当前进程最近访问过的一组页表项</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分页系统地址转换</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">通过根据逻辑地址中的<span class="bold" style="font-weight: bold;">页号</span>，查找<span class="bold" style="font-weight: bold;">快表中</span>是否存在<span class="bold" style="font-weight: bold;">对应的页表项</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">若快表中<span class="bold" style="font-weight: bold;">存在该表项</span>，称为<span class="bold" style="font-weight: bold;">命中（hit）</span>，取出其中的<span class="bold" style="font-weight: bold;">页框号</span>，加上<span class="bold" style="font-weight: bold;">页内偏移量</span>，计算出物理地址。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">若快表中不存在该页表项，称为<span class="bold" style="font-weight: bold;">命中失败</span>，则再查找页表，找到逻辑地址中指定页号对应的页框号。同时，<span class="bold" style="font-weight: bold;">更新快表</span>，将该表项插入快表中。并计算物理地址.</span></li></ul></li></ul></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">内存的有效访问时间</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">从进程<span class="bold" style="font-weight: bold;">发出</span>指定逻辑地址的<span class="bold" style="font-weight: bold;">访问请求</span>，经过地址变换，到在内存中找到对应的实际物理地址单元并<span class="bold" style="font-weight: bold;">取出数据</span>，所需要花费的总时间，称为<span class="bold" style="font-weight: bold;">内存的有效访问时间（EAT）</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">无块表时：</span>EAT = t + t = 2t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t为单次内存访问需要的时间。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">有快表时：</span>EAT = a λ + ( t + λ )(1-a) + t = 2t + λ – t a    λ为查找快表所需的时间，a为命中率</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">两级和多级页表</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">为了处理<span class="bold" style="font-weight: bold;">大页表的存储与检索</span>，引入了<span class="bold" style="font-weight: bold;">两级页表</span></span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">两级页表：外层页号+外层页内地址+页内地址</span></span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">反置页表</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">反置页表为每一个<span class="bold" style="font-weight: bold;">物理块</span>设置一个<span class="bold" style="font-weight: bold;">页表项</span>，并将它们按物理块的<span class="bold" style="font-weight: bold;">编号排序</span>，其中的内容则是<span class="bold" style="font-weight: bold;">页号</span>和其所属<span class="bold" style="font-weight: bold;">进程的标志符</span>。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基本分段存储管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">引入分段的原因：</span>方便编程、信息共享、信息保护、动态增长、动态链接</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分段存储基本原理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">程序由若干逻辑段组成，每个段有自己的名字和长度。程序的<span class="bold" style="font-weight: bold;">逻辑地址</span>是由<span class="bold" style="font-weight: bold;">段名（段号）</span>和<span class="bold" style="font-weight: bold;">段内偏移量</span>决定。每个段的逻辑地址从0开始编址.</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">系统采用<span class="bold" style="font-weight: bold;">动态划分</span>技术，将<span class="bold" style="font-weight: bold;">物理内存</span>动态地划分成许多<span class="bold" style="font-weight: bold;">尺寸不相等的分区</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当一个进程被<span class="bold" style="font-weight: bold;">装入物理内存</span>时，系统将为该进程的<span class="bold" style="font-weight: bold;">每一段</span>独立地<span class="bold" style="font-weight: bold;">分配一个分区</span>。同一进程的多个段<span class="bold" style="font-weight: bold;">不必存放在连续</span>的多个分区中。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分段系统的基本数据结构</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">段表：</span>每个<span class="bold" style="font-weight: bold;">进程建立一个段表</span>，用于描述进程的分段情况，记载进程的各个段到物理内存中分区的映射情况。其中包含<span class="bold" style="font-weight: bold;">段号、段长、段基址</span>以及对本段的<span class="bold" style="font-weight: bold;">存取控制权限</span>等信息。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">空闲分区表 : </span>用于记载物理内存中的空闲分区情况。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">段表寄存器：</span>实现快速地址变换，用来存放当前执行进程的<span class="bold" style="font-weight: bold;">段表</span>在物理内存中的<span class="bold" style="font-weight: bold;">起始地址（即基址）</span>。</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当创建进程，将进程的程序和数据<span class="bold" style="font-weight: bold;">装入内存</span>时，系统为之<span class="bold" style="font-weight: bold;">建立段表</span>，并将段表的<span class="bold" style="font-weight: bold;">起始地址</span>填入<span class="bold" style="font-weight: bold;">进程的PCB</span>中。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">当进程被<span class="bold" style="font-weight: bold;">调度执行</span>时，取出其PCB中的段表首址，<span class="bold" style="font-weight: bold;">填入段表寄存器</span>中。</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">地址变换和存储保护</span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（1）根据逻辑地址中的段号检索进程段表，获得指定段对应的段表项；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（2）判断是否地址越界。比较逻辑地址中的段内偏移量与段表项中的段长，若超过段的长度，则产生存储保护中断（该中断将由操作系统进行处理）；否则，转（3）；</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（3）把逻辑地址中的段内偏移量与段表表项中的段基址相加，从而得到物理地址。</span></li></ul></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">分页和分段的比较（划重点）</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（1）<span class="bold" style="font-weight: bold;">页</span>是信息的<span class="bold" style="font-weight: bold;">物理单位</span>，分页是为实现<span class="bold" style="font-weight: bold;">离散分配</span>方式，以消减内存的<span class="bold" style="font-weight: bold;">外零头</span>，提高内存的利用率；<span class="bold" style="font-weight: bold;">段</span>则是信息的<span class="bold" style="font-weight: bold;">逻辑</span>单位，它<span class="bold" style="font-weight: bold;">含有一组意义相对完整的信息</span>。分段的目的是为了能更好地满足用户的需要。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（2）<span class="bold" style="font-weight: bold;">页的大小固定且由系统决定</span>，因而在系统中只能有一种大小的页面，而<span class="bold" style="font-weight: bold;">段的长度却不固定，决定于用户所编写的程序</span>，通常由编译程序在对源程序进行<span class="bold" style="font-weight: bold;">编译</span>时，根据信息的性质来划分。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">（3）<span class="bold" style="font-weight: bold;">分页的作业地址空间是一维的，即单一的线性地址空间</span>，程序员只需利用一个记忆符，即可表示一个地址；而<span class="bold" style="font-weight: bold;">分段的作业地址空间则是二维的</span>，程序员在标识一个地址时，既需给出<span class="bold" style="font-weight: bold;">段名</span>，又需给出<span class="bold" style="font-weight: bold;">段内地址</span>。&nbsp;&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">段页式存储管理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">基本原理</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">采用<span class="bold" style="font-weight: bold;">分段方法组织用户程序</span>，采用<span class="bold" style="font-weight: bold;">分页方法分配和管理内存</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">先将<span class="bold" style="font-weight: bold;">用户程序分成若干个段</span>，再把<span class="bold" style="font-weight: bold;">每个段分成若干个页</span>，并为每一个段赋予一个段名。&nbsp;&nbsp;</span></li></ul></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;"><span class="bold" style="font-weight: bold;">地址变换</span></span><ul class="children" style="list-style: disc outside; padding-bottom: 4px;"><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">①首先，从<span class="bold" style="font-weight: bold;">段表寄存器</span>从获得进程<span class="bold" style="font-weight: bold;">段表的起始地址</span>，根据该地址，查找进程的段表。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">②然后，根据逻辑地址指定的段号检索段表，找到对应段的<span class="bold" style="font-weight: bold;">页表起始地址</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">③再根据逻辑地址中指定的页号检索该页表，找到对应<span class="bold" style="font-weight: bold;">页所在的页框号</span>。</span></li><li style="line-height: 24px;"><span class="content mubu-node" style="line-height: 24px; min-height: 24px; font-size: 16px; padding: 2px 0px; display: inline-block; vertical-align: top;">④最后，用页框号加上逻辑地址中指定的<span class="bold" style="font-weight: bold;">页内偏移量</span>，形成物理地址。</span></li></ul></li></ul></li></ul></li></ul></div>
</body>
</html>