<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>十七又三</title>
    <url>/twenty/</url>
    <content><![CDATA[<h1 id="十七又三">
          <a href="#十七又三" class="heading-link"><i class="fas fa-link"></i></a>十七又三</h1>
      <p>今年的生日本来不打算写着什么的<br>想让日子就这么静静地流逝着<br>十一点多却又在床上翻来覆去<br>习惯性的失眠，胡思乱想<br>还是开灯从床上爬起<br>让回忆从指尖沙沙流过</p>
<a id="more"></a>
<p>在古时，二十岁即是加冠之年，寓意成年。<br>成年之时，我想谈谈关于过去，关于未来，关于穿越时空的旅行。</p>

        <h1 id="友情">
          <a href="#友情" class="heading-link"><i class="fas fa-link"></i></a>友情</h1>
      <p>首先谈的是友情<br>从初中到高中再到大学<br>收获了一批批的沉甸甸的友情</p>
<p>在前天和初中同学们在群里彻夜长谈，讲十四岁的故事，我想起自己在当时唱的“十七岁的雨季”，那时的我总觉得十七岁好遥远啊，是十四岁的我怎么也想不到的，而如今一转眼就二十了。有个初中同学说，他很羡慕我，说我那时候敢说敢做，什么都不怕，每天都在一直笑。其实我也羡慕那个时候的自己，天真傻憨，想说就说，想做就做，没有顾及。我总感觉上了大学，我不快乐，我不会把自己的想法轻易地暴露出来，学会了伪装自己，在大学里的友情，更多的是君子之交淡如水。</p>
<p>上个月去泉州玩的时候，我骑着电动车在江滨大道驰行，吹着海风上了高架桥，那一刻我的思绪回到了17岁那年在厦门的夏天。当时和几个高中同学，高二暑假一放假就跑到厦门，一到厦门就被骗了票钱，骑着自行车满厦门的追，到晚上又一群人走丢了，骑着自行车上了高架桥，回到宾馆大家挤在一个小房间吃着夜宵。那是关于高中的友情，就在刚刚远在澳洲的班长又在零点给了发了祝福。</p>
<p>我很庆幸在大学的时候阴差阳错地进入了至微支教队，在这里我遇到了一群交心的朋友，他们陪着我度过了一整年，现在都在偷偷地给我准备着生日祝福。</p>

        <h1 id="爱情">
          <a href="#爱情" class="heading-link"><i class="fas fa-link"></i></a>爱情</h1>
      <p>之后我想谈谈爱情</p>
<p>在去年，我谈了人生第一场恋爱，即使现在结束了，回想起来还是很美好，很多画面仍然还在脑海里闪现。<br>在这过去的一年里，我一直在想怎么样才算是真正地爱一个人，才能做到不亏待别人也不委屈自己，我只能不停地去找寻，去试探。<br>心动也许不是恋爱，等心定下来了，那便有了答案。</p>

        <h1 id="事业">
          <a href="#事业" class="heading-link"><i class="fas fa-link"></i></a>事业</h1>
      <p>最后我想谈谈学习事业</p>
<p>我很愧疚自己没有远大的目标，很多的时候我是在模仿，别人怎么样，我变怎么样。大家都朝着计算机跑去，我也便来了。大家浩浩荡荡地抢占着保研，我便也裹挟地前进，我也很无奈，但却是囿于生活，所有的诗和远方，脱离了经济的土壤，变成了无根之萍。<br>我希望在接下来的日子，我能走出一条自己的路，一条独一无二的路！</p>

        <h1 id="未来">
          <a href="#未来" class="heading-link"><i class="fas fa-link"></i></a>未来</h1>
      <p>To be a better man !</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>大学生活</category>
        <category>二十</category>
      </categories>
      <tags>
        <tag>体验</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot系列 (一) -- 启动原理解析</title>
    <url>/SpringBoot1/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>SpringBoot 通过 <code>@SpringBootApplication</code> 注解及<code>SpringApplication.run()</code>方法，进行启动类的配置加载：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<a id="more"></a>

        <h1 id="SpringBootApplication">
          <a href="#SpringBootApplication" class="heading-link"><i class="fas fa-link"></i></a>@SpringBootApplication</h1>
      <p>查看源代码可知：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>({ElementType.TYPE}) <span class="comment">// 定义注解的作用目标，接口、类、枚举、注解</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">// 定义注解的保留策略，注解会在class字节码文件中存在，在运行时可以通过反射获取到</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">// 说明该注解将被包含在javadoc中</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">// 说明子类可以继承父类中的该注解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前四个为元注解，指注解的注解</span></span><br><span class="line"><span class="comment">// 后面三个注解，为@SpringBootApplication的核心</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">// 点开源码为@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = {<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = {TypeExcludeFilter<span class="class">.<span class="keyword">class</span>}</span></span><br><span class="line"><span class="class">), @<span class="title">Filter</span>(</span></span><br><span class="line"><span class="class">    <span class="title">type</span> </span>= FilterType.CUSTOM,</span><br><span class="line">    classes = {AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>}</span></span><br><span class="line"><span class="class">)}</span></span><br><span class="line"><span class="class">)</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="Configuration">
          <a href="#Configuration" class="heading-link"><i class="fas fa-link"></i></a>@Configuration</h2>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 配置类也是IoC容器中的一个组件</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration {</span><br><span class="line">    <span class="meta">@AliasFor</span>(</span><br><span class="line">        annotation = Component<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">    )</span></span><br><span class="line">    String value() default "";</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="ComponentScan">
          <a href="#ComponentScan" class="heading-link"><i class="fas fa-link"></i></a>@ComponentScan</h2>
      <p><code>@ComponentScan</code>这个注解在 Spring 中很重要，它对应 XML 配置中的元素，<code>@ComponentScan</code>的功能其实就是自动扫描并加载符合条件的组件（比如<code>@Component</code>和<code>@Repository</code>等）或者 bean 定义，最终将这些 bean 定义加载到 IoC 容器中。</p>
<p>我们可以通过 basePackages 等属性来细粒度的定制<code>@ComponentScan</code>自动扫描的范围，如果不指定，则默认 Spring 框架实现会从声明<code>@ComponentScan</code>所在类的 package 进行扫描。</p>

        <h2 id="EnableAutoConfiguration">
          <a href="#EnableAutoConfiguration" class="heading-link"><i class="fas fa-link"></i></a>@EnableAutoConfiguration</h2>
      <p><strong>开启自动配置功能</strong></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>({ElementType.TYPE})</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> <span class="comment">// 自动配置包  </span></span><br><span class="line"><span class="meta">@Import</span>({AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>}) </span></span><br><span class="line"><span class="class">// @<span class="title">Import</span> 注解可以普通类导入到 <span class="title">IoC</span>容器中</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="AutoConfigurationPackage">
          <a href="#AutoConfigurationPackage" class="heading-link"><i class="fas fa-link"></i></a>@AutoConfigurationPackage</h3>
      <p>通过查看<code>@AutoConfigurationPackage</code>源码</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class">// 仍然采用的是@<span class="title">Import</span>注解将这个类导入 <span class="title">IoC</span> 容器中</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>我好奇地打开了这个类的实现方法</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>{</span><br><span class="line">    register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>在此处进行断点Debug发现：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/aElEIf.png" alt="metadata">
      <br>在 metadata 元信息中获得了我们导入的类：<code>cn.geminiplanet.springboot.helloworld</code><br>Amazing !!!</p>

        <h3 id="Import-AutoConfigurationImportSelector-class">
          <a href="#Import-AutoConfigurationImportSelector-class" class="heading-link"><i class="fas fa-link"></i></a>Import({AutoConfigurationImportSelector.class})</h3>
      <p>导入需要组件的选择器,将所有需要导入的组件以全类名的方式返回。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) {</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) {</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    }</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这里内部使用 SpringFactoriesLoader,从指定的配置文件META-INF/spring.factories加载配置, 自动配置类就生效了。</p>

        <h1 id="SpringApplication">
          <a href="#SpringApplication" class="heading-link"><i class="fas fa-link"></i></a>SpringApplication</h1>
      <blockquote>
<p>以下这一部分内容，我没怎么弄懂，来源：<span class="exturl"><a class="exturl__link" href="http://www.51gjie.com/javaweb/1042.html" target="_blank" rel="noopener">http://www.51gjie.com/javaweb/1042.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<p><strong>SpringApplication 是 SpringBoot 驱动 Spring 应用上下文的引导类，他的run() 方法启动 Spring 应用，实质上是为 Spring 应用创建并初始化 Spring 上下文。</strong></p>

        <h2 id="执行流程">
          <a href="#执行流程" class="heading-link"><i class="fas fa-link"></i></a>执行流程</h2>
      <ol>
<li>初始化监听器，以及添加到SpringApplication的自定义监听器。</li>
<li>发布ApplicationStartedEvent事件，如果想监听ApplicationStartedEvent事件，你可以这样定义：public class ApplicationStartedListener implements ApplicationListener，然后通过SpringApplication.addListener(..)添加进去即可。</li>
<li>装配参数和环境，确定是web环境还是非web环境。</li>
<li>装配完环境后，就触发ApplicationEnvironmentPreparedEvent事件。</li>
<li>如果SpringApplication的showBanner属性被设置为true，则打印启动的Banner。</li>
<li>创建ApplicationContext，会根据是否是web环境，来决定创建什么类型的ApplicationContext。</li>
<li>装配Context的环境变量，注册Initializers、beanNameGenerator等。</li>
<li>发布ApplicationPreparedEvent事件。</li>
<li>注册springApplicationArguments、springBootBanner，加载资源等</li>
<li>遍历调用所有SpringApplicationRunListener的contextLoaded()方法。</li>
<li>调用ApplicationContext的refresh()方法,装配context beanfactory等非常重要的核心组件。</li>
<li>查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。</li>
<li>发布ApplicationReadyEvent事件，启动完毕，表示服务已经可以开始正常提供服务了。通常我们这里会监听这个事件来打印一些监控性质的日志，表示应用正常启动了。</li>
</ol>
<p>SpringBoot会触发其他的一些事件，这些事件按下列顺序触发：<br>（1）ApplicationStartingEvent：项目刚启动时触发，此时除了注册监听器和初始器之外，其他所有处理都没有开始；<br>（2）ApplicationEnvironmentPreparedEvent：上下文得到环境信息之后触发，此时上下文创建还没有创建；<br>（3）ApplicationPreparedEvent：bean的定义信息加载完成之后触发，此时bean还没有初始化；<br>（4）ApplicationReadyEvent：在所有bean初始化完毕，所有回调处理完成，系统准备处理服务请求时触发；<br>（5）ApplicationFailedEvent：启动过程出现异常时候触发。</p>

        <h2 id="SpringApplication-run">
          <a href="#SpringApplication-run" class="heading-link"><i class="fas fa-link"></i></a>SpringApplication.run()</h2>
      <p>如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p>
<ol>
<li>根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li>
<li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li>
<li>推断并设置main方法的定义类。<br>它会执行以下步骤：</li>
<li>创建一个合适的ApplicationContext实例 （取决于classpath）。</li>
<li>注册一个CommandLinePropertySource，以便将命令行参数作为Spring properties。</li>
<li>刷新application context，加载所有单例beans。</li>
<li>激活所有CommandLineRunner beans。</li>
</ol>

        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="http://tengj.top/2017/03/09/springboot3/" target="_blank" rel="noopener">http://tengj.top/2017/03/09/springboot3/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/yixiaogang109/article/details/7328466" target="_blank" rel="noopener">https://blog.csdn.net/yixiaogang109/article/details/7328466</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="http://www.51gjie.com/javaweb/1042.html" target="_blank" rel="noopener">http://www.51gjie.com/javaweb/1042.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Spring Framework</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>SpringBootApplication</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务小记(MicroServices)</title>
    <url>/MicroServices/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p><strong>微服务是一种热门的架构风格</strong>，由Martin Flowler在2014年一篇文章带火。<span class="exturl"><a class="exturl__link" href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">MicroServices</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/aA5jht.png" alt="MicroServices">
      </p>
<a id="more"></a>
<p>在图片的左边是常见的<strong>单体应用</strong>，它将所有功能都打包成一个独立单元的应用程序，每一个业务功能不可分割。</p>
<p>在图片右边对应着<strong>微服务，一个应用由一组小型服务组成</strong>，可以通过HTTP的方式进行互通。每一个功能元素最终都是一个可独立替换和独立升级的软件单元。</p>

        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener">https://martinfowler.com/articles/microservices.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/65502802" target="_blank" rel="noopener">https://www.zhihu.com/question/65502802</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Spring Framework</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Guide</title>
    <url>/Spring-Guide/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p><strong>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</strong><br>它包含以下核心模块：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/ak6x8H.png" alt="SpringFramework">
      </p>
<a id="more"></a>

        <h1 id="RestController-vs-Controller">
          <a href="#RestController-vs-Controller" class="heading-link"><i class="fas fa-link"></i></a>@RestController vs @Controller</h1>
      
        <h2 id="Controller">
          <a href="#Controller" class="heading-link"><i class="fas fa-link"></i></a>@Controller</h2>
      <p><code>Controller</code>返回一个页面视图，对应传统的Spring MVC应用，应用于前后端不分离的开发。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/akgMSH.png" alt="Controller">
      </p>

        <h2 id="RestController">
          <a href="#RestController" class="heading-link"><i class="fas fa-link"></i></a>@RestController</h2>
      <p><code>RestController</code>返回JSON或XML格式的对象数据，属于RESTFUL Web服务，是目前主流的前后端分离开发。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/akgy7V.png" alt="RestController">
      </p>

        <h2 id="Controller-ResponseBody">
          <a href="#Controller-ResponseBody" class="heading-link"><i class="fas fa-link"></i></a>@Controller + @ResponseBody</h2>
      <p><code>@Controller + @ResponseBody = @RestController</code></p>
<blockquote>
<p><code>@ResponseBody</code>注解的作用是将 <code>Controller</code>的方法返回对象转换为指定的格式后，写入到 HTTP 响应(Response)对象的 body,通常来返回 JSON 数据。<br>PS：注解不是 Spring 所特有的，而且 Java 语言的特性，可以看我之前写过的 Java 注解篇</p>
</blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/ak2cDI.png" alt="@Controller + @ResponseBody">
      </p>

        <h1 id="MVC-vs-RESTful">
          <a href="#MVC-vs-RESTful" class="heading-link"><i class="fas fa-link"></i></a>MVC vs RESTful</h1>
      
        <h2 id="MVC">
          <a href="#MVC" class="heading-link"><i class="fas fa-link"></i></a>MVC</h2>
      <p><strong>Spring MVC 是一个模型 - 视图 - 控制器（MVC）的Web框架</strong>，建立在中央前端控制器servlet（DispatcherServlet），它负责发送每个请求到合适的处理程序，使用视图来最终返回响应结果的概念。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/28/akRvwt.png" alt="MVC">
      </p>

        <h2 id="RESTful">
          <a href="#RESTful" class="heading-link"><i class="fas fa-link"></i></a>RESTful</h2>
      <p>RESTful是一种网络应用程序的设计风格和开发方式，只要一个架构符合REST原则，就可以称为RESTful架构。<br>RESTFUL特点包括：</p>
<ol>
<li>每一个URI代表1种资源；</li>
<li>客户端使用GET、POST、PUT、DELETE4个表示操作方式的动词对服务端资源进行操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源；</li>
<li>通过操作资源的表现形式来操作资源；</li>
<li>资源的表现形式是XML或者HTML；</li>
<li>客户端与服务端之间的交互在请求之间是无状态的，从客户端到服务端的每个请求都必须包含理解请求所必需的信息。</li>
</ol>

        <h1 id="IOC-amp-AOP">
          <a href="#IOC-amp-AOP" class="heading-link"><i class="fas fa-link"></i></a>IOC &amp; AOP</h1>
      
        <h2 id="IOC">
          <a href="#IOC" class="heading-link"><i class="fas fa-link"></i></a>IOC</h2>
      <p><strong>IoC(全称为Invere of Control,控制翻转)，是一种设计思想，它将原本在程序中手动创建对象的控制权交给 Spring 框架来管理。</strong> IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上是个 Map(key,value), Map 中存放的是各种对象。<br><strong>通俗来讲，IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong></p>

        <h2 id="AOP">
          <a href="#AOP" class="heading-link"><i class="fas fa-link"></i></a>AOP</h2>
      <p><strong>AOP(全称为Aspect-Oriented Programming,面向切面编程),通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。</strong><br>AOP是OOP(面向对象编程)的延续，OOP把系统看作多个对象的交互，AOP把系统分解为不同的关注点，称为切面(Aspect)。AOP的理念：就是将分散在各个业务逻辑代码中相同的代码通过横向切割的方式抽取到一个独立的模块中！</p>

        <h1 id="Bean">
          <a href="#Bean" class="heading-link"><i class="fas fa-link"></i></a>Bean</h1>
      <p><strong>在 Spring 中，构成应用程序主干并由Spring IoC容器管理的对象称为Bean。</strong>Bean是一个由Spring IoC容器实例化、组装和管理的对象。<br>Bean规范如下：</p>
<ol>
<li>所有属性为private</li>
<li>提供默认构造方法</li>
<li>提供getter和setter</li>
<li>实现serializable接口</li>
</ol>

        <h2 id="Component-vs-Bean">
          <a href="#Component-vs-Bean" class="heading-link"><i class="fas fa-link"></i></a>@Component vs @Bean</h2>
      
        <h3 id="Component">
          <a href="#Component" class="heading-link"><i class="fas fa-link"></i></a>@Component</h3>
      <p><code>@Component</code> 注解作用于类,通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中(我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 Bean 容器中)。</p>

        <h3 id="Bean-1">
          <a href="#Bean-1" class="heading-link"><i class="fas fa-link"></i></a>@Bean</h3>
      <p><code>@Bean</code> 注解作用于方法,通常是我们在标有该注解的方法中定义产生这个 Bean ,<code>@Bean</code> 告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p>
<blockquote>
<p><code>@Bean</code>注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 Bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 <code>@Bean</code>来实现。</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="Bean注解">
          <a href="#Bean注解" class="heading-link"><i class="fas fa-link"></i></a>Bean注解</h2>
      <p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li><code>@Component</code> ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用 <code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>

        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/SpringInterviewQuestions" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/SpringInterviewQuestions</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://dzone.com/articles/spring-framework-restcontroller-vs-controller（图片来源）" target="_blank" rel="noopener">https://dzone.com/articles/spring-framework-restcontroller-vs-controller（图片来源）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1" target="_blank" rel="noopener">https://javarevisited.blogspot.com/2017/08/difference-between-restcontroller-and-controller-annotations-spring-mvc-rest.html?m=1</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://www.yiibai.com/spring_mvc/" target="_blank" rel="noopener">https://www.yiibai.com/spring_mvc/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://baike.baidu.com/item/RESTful" target="_blank" rel="noopener">https://baike.baidu.com/item/RESTful</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Spring Framework</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>IOC</tag>
        <tag>Bean</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML语言教程</title>
    <url>/YAML/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>在 SpringBoot 我们通常使用( application.yml )来配置全局文件。<br><strong>YAML（发音/ˈjæməl/）是一个可读性高，用来表达数据序列化的格式，远比 JSON 格式方便。</strong></p>
<a id="more"></a>

        <h1 id="YAML语法">
          <a href="#YAML语法" class="heading-link"><i class="fas fa-link"></i></a>YAML语法</h1>
      
        <h2 id="YAML基本语法">
          <a href="#YAML基本语法" class="heading-link"><i class="fas fa-link"></i></a>YAML基本语法</h2>
      <ul>
<li><strong>使用缩进表示层级关系</strong></li>
<li><strong>缩进时不允许使用Tab键，只允许使用空格。</strong></li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li>大小写敏感</li>
<li>‘#’表示注释，从这个字符一直到行尾，都会被解析器忽略。</li>
</ul>

        <h2 id="YAML支持的三种数据结构">
          <a href="#YAML支持的三种数据结构" class="heading-link"><i class="fas fa-link"></i></a>YAML支持的三种数据结构</h2>
      <ul>
<li>对象：键值对的集合</li>
<li>数组：一组按次序排列的值</li>
<li>字面量：单个的、不可再分的值</li>
</ul>

        <h1 id="值的写法">
          <a href="#值的写法" class="heading-link"><i class="fas fa-link"></i></a>值的写法</h1>
      
        <h2 id="字面量-数字、字符串、布尔">
          <a href="#字面量-数字、字符串、布尔" class="heading-link"><i class="fas fa-link"></i></a>字面量(数字、字符串、布尔)</h2>
      <ul>
<li>k:v ：字面直接来写；</li>
<li>字符串默认不用加上单引号或者双引号；</li>
<li>‘’ ：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</li>
<li>“” ：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</li>
</ul>
<blockquote>
<p>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi<br> name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi</p>
</blockquote>

        <h2 id="对象、Map-属性和值">
          <a href="#对象、Map-属性和值" class="heading-link"><i class="fas fa-link"></i></a>对象、Map(属性和值)</h2>
      <figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">friends:</span></span><br><span class="line">    <span class="attr">lastName:</span> <span class="string">Gemini</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">20</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="数组-List、Set">
          <a href="#数组-List、Set" class="heading-link"><i class="fas fa-link"></i></a>数组(List、Set)</h2>
      <p>用- 值表示数组中的一个元素</p>
<figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span></span><br><span class="line"><span class="string">‐</span> <span class="string">cat</span></span><br><span class="line"><span class="string">‐</span> <span class="string">dog</span></span><br><span class="line"><span class="string">‐</span> <span class="string">pig</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>行内表示</p>
<figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">pets:</span> <span class="string">[cat,dog,pig]</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="引用">
          <a href="#引用" class="heading-link"><i class="fas fa-link"></i></a>引用</h2>
      <p>锚点 &amp; 和别名 * ，可以用来引用。</p>
<figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="meta">*showell</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>转为 JavaScript 代码如下:</p>
<figure class="highlight javascript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">[ <span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span> ]</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="Demo">
          <a href="#Demo" class="heading-link"><i class="fas fa-link"></i></a>Demo</h1>
      <figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/demo?characterEncoding=utf-8&amp;serverTimezone=UTC&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">mapper-locations:</span> <span class="string">"classpath:/mybatis/mapper/*.xml,classpath:/mybatis/mapper/extend/ *.xml"</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">cn.geminiplanet.springbootdemo.mapper:</span> <span class="string">debug</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/07/yaml.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>wiki.suncaper.net</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker运行Mysql镜像</title>
    <url>/Docker-Mysql/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>最近在进行Spring Boot学习，在配置数据库时想要使用Docker下载Mysql镜像，但是过程中遇到了挺多问题，故记录下解决过程。<br><strong>本篇文章内容包含利用Docker运行Mysql镜像，完成数据库配置。</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjmpMq.png" alt="Docker-Mysql">
      </p>
<a id="more"></a>

        <h1 id="启用Hyper-V">
          <a href="#启用Hyper-V" class="heading-link"><i class="fas fa-link"></i></a>启用Hyper-V</h1>
      <p>打开控制面板–&gt;程序–&gt;启用或关闭windows功能，勾选Hyper-V,然后点击确定即可。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/Ujm2yq.png" alt="Hyper-V">
      </p>

        <h1 id="安装Docker">
          <a href="#安装Docker" class="heading-link"><i class="fas fa-link"></i></a>安装Docker</h1>
      <p>下载地址：<span class="exturl"><a class="exturl__link" href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="启动Docker">
          <a href="#启动Docker" class="heading-link"><i class="fas fa-link"></i></a>启动Docker</h1>
      <p>打开windows命令行模式，输入docker version或docker -v查看，若出现如下信息则安装成功。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjnQcn.png" alt="docker version">
      </p>

        <h1 id="国内镜像加速">
          <a href="#国内镜像加速" class="heading-link"><i class="fas fa-link"></i></a>国内镜像加速</h1>
      <p>阿里云镜像加速地址：<span class="exturl"><a class="exturl__link" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>获取专属加速器地址，如下图：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjuCUU.png" alt="阿里云镜像">
      <br>打开docker，右键Settings–&gt;Daemon–&gt;Registry mirrors复制刚才的专属加速器地址到此即可，这样就完成了国内镜像加速。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjuFC4.png" alt="mirrors">
      </p>

        <h1 id="拉取Mysql镜像">
          <a href="#拉取Mysql镜像" class="heading-link"><i class="fas fa-link"></i></a>拉取Mysql镜像</h1>
      <p>官网：<span class="exturl"><a class="exturl__link" href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">https://hub.docker.com/_/mysql</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight properties"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 默认安装最新版本</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">pull mysql</span></span><br><span class="line"><span class="comment"># 查看镜像</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">images</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjulPe.png" alt="Mysql镜像">
      </p>

        <h1 id="启动Mysql实例">
          <a href="#启动Mysql实例" class="heading-link"><i class="fas fa-link"></i></a>启动Mysql实例</h1>
      <figure class="highlight routeros"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name some-mysql -e <span class="attribute">MYSQL_ROOT_PASSWORD</span>=my-secret-pw -d mysql:tag</span><br><span class="line"><span class="comment"># 其中some-mysql是您要分配给容器的名称，</span></span><br><span class="line"><span class="comment"># my-secret-pw是要为MySQL根用户设置的密码，</span></span><br><span class="line"><span class="comment"># tag是指定所需MySQL版本的标签。</span></span><br><span class="line">eg:</span><br><span class="line">docker <span class="builtin-name">run</span> --name mysql -e <span class="attribute">MYSQL_ROOT_PASSWORD</span>=123456 -d mysql</span><br></pre></td></tr></tbody></table></div></figure>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjKGYF.png" alt="Mysql实例">
      </p>

        <h1 id="进入Mysql命令行">
          <a href="#进入Mysql命令行" class="heading-link"><i class="fas fa-link"></i></a>进入Mysql命令行</h1>
      <figure class="highlight properties"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 根据容器名称mysql使用命令进入容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">exec -it mysql bash</span></span><br><span class="line"><span class="comment"># 进入Mysql</span></span><br><span class="line"><span class="attr">mysql</span> <span class="string">-u root -p</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjK0w6.png" alt="Mysql命令行">
      </p>

        <h1 id="问题解决">
          <a href="#问题解决" class="heading-link"><i class="fas fa-link"></i></a>问题解决</h1>
      
        <h2 id="安装镜像失败">
          <a href="#安装镜像失败" class="heading-link"><i class="fas fa-link"></i></a>安装镜像失败</h2>
      <figure class="highlight yaml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="literal">no</span> <span class="string">matching</span> <span class="string">manifest</span> <span class="string">for</span> <span class="string">windows/amd64</span> <span class="number">10.0</span><span class="number">.18362</span> <span class="string">in</span> <span class="string">the</span> <span class="string">manifest</span> <span class="string">list</span> <span class="string">entries</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>解决方法：</strong><br>打开docker，右键Settings–&gt;Daemon–&gt;点击 Basic 设置 “experimental”: true。</p>
<blockquote>
<p>解决manifest 匹配失败问题</p>
</blockquote>

        <h2 id="启动Mysql实例失败">
          <a href="#启动Mysql实例失败" class="heading-link"><i class="fas fa-link"></i></a>启动Mysql实例失败</h2>
      <figure class="highlight subunit"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">Error </span>response from daemon: The virtual machine could not be started because a required feature is not installed.</span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>解决方法：</strong><br>打开 CMD 执行</p>
<figure class="highlight cpp"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">BCDEdit /<span class="built_in">set</span> hypervisorlaunchtype <span class="keyword">auto</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>重启计算机</p>

        <h1 id="Docker常用命令">
          <a href="#Docker常用命令" class="heading-link"><i class="fas fa-link"></i></a>Docker常用命令</h1>
      <figure class="highlight stylus"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="selector-class">.docker</span> images <span class="comment">// 查看镜像</span></span><br><span class="line"><span class="number">2</span><span class="selector-class">.docker</span> run 镜像名称   <span class="comment">// 生成一个正在运行的容器实例</span></span><br><span class="line"><span class="number">3</span><span class="selector-class">.docker</span> stop 容器名称   <span class="comment">// 停止容器</span></span><br><span class="line"><span class="number">4</span><span class="selector-class">.docker</span> rm 容器名称  <span class="comment">// 删除容器</span></span><br><span class="line"><span class="number">5</span><span class="selector-class">.docker</span> start 容器名称  <span class="comment">// 启动容器</span></span><br><span class="line"><span class="number">6</span><span class="selector-class">.docker</span> restart 容器名称  <span class="comment">//重启容器</span></span><br><span class="line"><span class="number">7</span><span class="selector-class">.docker</span> rmi 镜像名称  <span class="comment">// 删除镜像</span></span><br><span class="line"><span class="number">8</span><span class="selector-class">.docker</span> exec -it 容器名称 /bin/bash  <span class="comment">// 进入容器</span></span><br><span class="line"><span class="number">9</span><span class="selector-class">.docker</span> ps  <span class="comment">// 显示正在运行的所有容器</span></span><br><span class="line"><span class="number">10</span><span class="selector-class">.docker</span> ps -<span class="selector-tag">a</span>  <span class="comment">// 显示所有容器（包括已经停止的）</span></span><br><span class="line"><span class="number">11</span><span class="selector-class">.docker</span> pull 镜像名称:版本号  <span class="comment">// 拉取镜像</span></span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/zhixie/p/11854659.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhixie/p/11854659.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/zhixie/p/11845748.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhixie/p/11845748.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/zjoch/archive/2011/12/12/2285177.html" target="_blank" rel="noopener">https://www.cnblogs.com/zjoch/archive/2011/12/12/2285177.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://stackoverflow.com/questions/57431890/error-response-from-daemon-hcsshimcreatecomputesystem-the-virtual-machine-co" target="_blank" rel="noopener">https://stackoverflow.com/questions/57431890/error-response-from-daemon-hcsshimcreatecomputesystem-the-virtual-machine-co</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Mysql</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode体验篇</title>
    <url>/LeetCode-Day1/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>作为LeetCode新手，我选择了HOT100里的一下简单和中等及困难的题目来刷。<br>本篇文章是自己一周刷题的心得，主要内容为刷题的<strong>心路历程、收获以及解题方法</strong>。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/24/UjVUyV.png" alt="LeetCode">
      </p>
<a id="more"></a>

        <h2 id="心路历程">
          <a href="#心路历程" class="heading-link"><i class="fas fa-link"></i></a>心路历程</h2>
      <p>一开始刷题的时候我是相当抗拒的，完全不会做。不会做的原因主要有两个方面：<br><strong>1. 常用的库函数方法的使用</strong></p>
<blockquote>
<p>对于这一点是新手非常容易懵逼，解决途径可以一开始先查API，后面用多了常用方法就记住了。</p>
</blockquote>
<p><strong>2. 特殊的解题技巧</strong></p>
<blockquote>
<p>这个最好的方法就是不断地刷题积累经验，特别是注意复习总结，我现在的计划是每周日总结一下这周刷的题。</p>
</blockquote>

        <h1 id="2-两数相加">
          <a href="#2-两数相加" class="heading-link"><i class="fas fa-link"></i></a>2 两数相加</h1>
      <p>题目：<span class="exturl"><a class="exturl__link" href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="解题历程">
          <a href="#解题历程" class="heading-link"><i class="fas fa-link"></i></a>解题历程</h2>
      <ol>
<li>学会使用定义的类来使用链表<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">ListNode L = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">L.next = <span class="keyword">new</span> ListNode(val);</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>异常判断(考虑链表为空的情况)<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 使用三目运算符</span></span><br><span class="line"><span class="keyword">int</span> x = (l1 == <span class="keyword">null</span> ? <span class="number">0</span> : l1.val);</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>特殊情况处理(最后一位是否为0)<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(add != <span class="number">0</span>){</span><br><span class="line">    l.next = <span class="keyword">new</span> ListNode(add);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

</li>
</ol>

        <h2 id="完整代码">
          <a href="#完整代码" class="heading-link"><i class="fas fa-link"></i></a>完整代码</h2>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode {</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) { val = x; }</span></span><br><span class="line"><span class="comment"> * }</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>{</span><br><span class="line">        ListNode pre = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode l = pre;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> || l2 != <span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">int</span> x = l1 == <span class="keyword">null</span> ? <span class="number">0</span>: l1.val;</span><br><span class="line">            <span class="keyword">int</span> y = l2 == <span class="keyword">null</span> ? <span class="number">0</span>: l2.val;</span><br><span class="line">            val = x + y + add;</span><br><span class="line">        </span><br><span class="line">            add = val / <span class="number">10</span>;</span><br><span class="line">            val = val % <span class="number">10</span> ;</span><br><span class="line">            l.next = <span class="keyword">new</span> ListNode(val);</span><br><span class="line">            l = l.next;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="keyword">null</span>){l1 = l1.next;}</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="keyword">null</span>){l2 = l2.next;}</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(add != <span class="number">0</span>){</span><br><span class="line">           l.next = <span class="keyword">new</span> ListNode(add);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 注意返回的链表</span></span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="3-无重复字符的最长子串">
          <a href="#3-无重复字符的最长子串" class="heading-link"><i class="fas fa-link"></i></a>3 无重复字符的最长子串</h1>
      
        <h1 id="4-寻找两个正序数组的中位数">
          <a href="#4-寻找两个正序数组的中位数" class="heading-link"><i class="fas fa-link"></i></a>4 寻找两个正序数组的中位数</h1>
      
        <h1 id="5-最长回文子串">
          <a href="#5-最长回文子串" class="heading-link"><i class="fas fa-link"></i></a>5 最长回文子串</h1>
      
        <h1 id="10-正则表达式匹配">
          <a href="#10-正则表达式匹配" class="heading-link"><i class="fas fa-link"></i></a>10 正则表达式匹配</h1>
      
        <h1 id="20-有效的括号">
          <a href="#20-有效的括号" class="heading-link"><i class="fas fa-link"></i></a>20 有效的括号</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Hash table that takes care of the mappings.</span></span><br><span class="line">  <span class="keyword">private</span> HashMap&lt;Character, Character&gt; mappings;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Initialize hash map with mappings. This simply makes the code easier to read.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.mappings = <span class="keyword">new</span> HashMap&lt;Character, Character&gt;();</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">')'</span>, <span class="string">'('</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">'}'</span>, <span class="string">'{'</span>);</span><br><span class="line">    <span class="keyword">this</span>.mappings.put(<span class="string">']'</span>, <span class="string">'['</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize a stack to be used in the algorithm.</span></span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;Character&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) {</span><br><span class="line">      <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If the current character is a closing bracket.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.mappings.containsKey(c)) {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the top element of the stack. If the stack is empty, set a dummy value of '#'</span></span><br><span class="line">        <span class="keyword">char</span> topElement = stack.empty() ? <span class="string">'#'</span> : stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the mapping for this bracket doesn't match the stack's top element, return false.</span></span><br><span class="line">        <span class="keyword">if</span> (topElement != <span class="keyword">this</span>.mappings.get(c)) {</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">      } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// If it was an opening bracket, push to the stack.</span></span><br><span class="line">        stack.push(c);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the stack still contains elements, then it is an invalid expression.</span></span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>HOT100</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode刷题之旅</title>
    <url>/LeetCode-Day0/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>看着身边很多朋友都陆陆续续入坑LeetCode，博主也打算开启自己的LeetCode之旅。<br>现在是先定一个小目标，一天先刷一道题，后面再慢慢地增加。<br><strong>So Study with me📖!</strong></p>
<a id="more"></a>

        <h1 id="刷题路线">
          <a href="#刷题路线" class="heading-link"><i class="fas fa-link"></i></a>刷题路线</h1>
      
        <h2 id="Tags">
          <a href="#Tags" class="heading-link"><i class="fas fa-link"></i></a>Tags</h2>
      <ul>
<li>数组、链表<br>包含基本排序算法、二分查找、链表的一系列操作。</li>
<li>栈、队列、堆<br>利用栈、队列互相实现，堆的使用</li>
<li>二叉树与图<br>主要是遍历算法和节点的计算：二叉树四种遍历方式、广度优先遍历（BFS）和广度优先遍历（DFS），节点到节点距离等等。</li>
<li>哈希表<br>使用标准库自带的模板或者函数就很简单了，一般会与其它数据结构相结合来提升时间复杂度。</li>
<li>字符串<br>操作字符串的操作也很多，本质上可以看作是数组的操作。另外字符串的一些匹配和寻求字串的算法还是非常具有思考价值的。KMP，马拉车等等。</li>
<li>递归<br>重点掌握边界判断条件。</li>
<li>回溯<br>重点掌握边界判断条件。</li>
<li>分治<br>重点掌握如何划分子问题。</li>
<li>动态规划<br>题太多了，可从一阶dp到二阶dp理解不同的状态方程。</li>
<li>贪心及其它<br>这个就很容易理解了，遇到贪心题应该要偷笑了。</li>
</ul>
<p>来源：<span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/36738189/answer/1004876884" target="_blank" rel="noopener">https://www.zhihu.com/question/36738189/answer/1004876884</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="HOT-100">
          <a href="#HOT-100" class="heading-link"><i class="fas fa-link"></i></a>HOT 100</h2>
      <p>官网：<span class="exturl"><a class="exturl__link" href="https://leetcode-cn.com/problemset/hot-100/" target="_blank" rel="noopener">https://leetcode-cn.com/problemset/hot-100/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="Easy-Medium-Hard">
          <a href="#Easy-Medium-Hard" class="heading-link"><i class="fas fa-link"></i></a>Easy-Medium-Hard</h2>
      <p>先按照复习的Tags来刷，在Tags里按照难度来刷<br><strong>数据结构与算法</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URmIaQ.png" alt="数据结构与算法">
      </p>

        <h2 id="Type">
          <a href="#Type" class="heading-link"><i class="fas fa-link"></i></a>Type</h2>
      <p>按照不同的类型来刷</p>
<ol>
<li>Pattern: Sliding window，滑动窗口类型</li>
<li>Pattern: two points, 双指针类型</li>
<li>Pattern: Fast &amp; Slow pointers, 快慢指针类型</li>
<li>Pattern: Merge Intervals，区间合并类型</li>
<li>Pattern: Cyclic Sort，循环排序</li>
</ol>
<p>详情见知乎：<span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/36738189/answer/908664455" target="_blank" rel="noopener">https://www.zhihu.com/question/36738189/answer/908664455</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="我的刷题计划">
          <a href="#我的刷题计划" class="heading-link"><i class="fas fa-link"></i></a>我的刷题计划</h1>
      
        <h2 id="初期计划">
          <a href="#初期计划" class="heading-link"><i class="fas fa-link"></i></a>初期计划</h2>
      <p><strong>对于入门小白，我打算先把HOT 100按照顺序刷完，并把每题按照Tags分类，刷完之后，依照Tags做一个总结。同时每天记录一下自己刷的题。</strong></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>刷题路线</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven入门介绍</title>
    <url>/Maven/</url>
    <content><![CDATA[<h1 id="What-is-Maven？">
          <a href="#What-is-Maven？" class="heading-link"><i class="fas fa-link"></i></a>What is Maven？</h1>
      <p>Maven是一个<strong>Java项目管理和构建工具</strong>，它可以定义项目结构、项目依赖，并使用统一的方式进行自动化构建，是Java项目不可缺少的工具。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/18/UgJM0x.png" alt="Maven">
      </p>
<a id="more"></a>

        <h1 id="Maven介绍">
          <a href="#Maven介绍" class="heading-link"><i class="fas fa-link"></i></a>Maven介绍</h1>
      <p>在Java项目开发中，我们常常需要引入一些依赖包，通常都要把jar包放入<code>classpath</code>下。</p>
<p>其次，我们要确定项目的目录结构。比如，<code>src</code>目录存放Java源码，<code>resource</code>目录存放配置文件，<code>bin</code>目录存放编译生成的<code>.class</code>文件。</p>
<p>此外，我们还需要配置环境，比如JDK版本等一系列的配置问题。</p>
<p><strong>这个时候，前辈们就开发出了Maven，专门为Java项目打造的管理和构建工具。</strong></p>

        <h1 id="Maven项目结构">
          <a href="#Maven项目结构" class="heading-link"><i class="fas fa-link"></i></a>Maven项目结构</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/18/UgNBAx.png" alt="Maven项目结构">
      <br>项目的根目录<code>a-maven-project</code>是<strong>项目名</strong>，<br>它有一个<strong>项目描述文件</strong><code>pom.xml</code>，<br>存放<strong>Java源码</strong>的目录是<code>src/main/java</code>，<br>存放<strong>资源文件</strong>的目录是<code>src/main/resources</code>，<br>存放<strong>测试源码</strong>的目录是<code>src/test/java</code>，<br>存放<strong>测试资源</strong>的目录是<code>src/test/resources</code>。<br>最后，所有编译、打包生成的文件都放在<code>target</code>目录里。这些就是一个Maven项目的标准目录结构。</p>

        <h2 id="Pom">
          <a href="#Pom" class="heading-link"><i class="fas fa-link"></i></a>Pom</h2>
      <p><strong>Pom是指项目对象模型(Project Object Model),是Maven工作的基础。</strong>在执行task或者goal时，Maven会去项目根目录下读取<code>pom.xml</code>获得需要的配置信息。</p>
<p><strong>pom.xml文件如下：</strong></p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">...</span>&gt;</span>// 类似于Java的包名</span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">        // 所使用的object model版本，为了确保稳定的使用，这个元素是强制性的。</span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itranswarp.learnjava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        // 是项目创建团体或组织的唯一标志符，通常是域名倒写</span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>// 类似于Java的类名</span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>// 开发版本</span><br><span class="line">	<span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span>// 打包的方式，默认为jar</span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        // 表示依赖，在子节点dependencies中添加具体依赖的groupId artifactId和version </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    // 使用dependency声明一个依赖后，Maven就会自动下载这个依赖包并把它放到classpath中。</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="依赖管理">
          <a href="#依赖管理" class="heading-link"><i class="fas fa-link"></i></a>依赖管理</h1>
      <p>Maven定义了几种依赖关系，分别是<code>compile</code>、<code>test</code>、<code>runtime</code>和<code>provided</code>：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/18/UgwBse.png" alt="依赖关系">
      <br>其中，默认的<code>compile</code>是最常用的，Maven会把这种类型的依赖直接放入classpath。</p>

        <h2 id="命令行编译">
          <a href="#命令行编译" class="heading-link"><i class="fas fa-link"></i></a>命令行编译</h2>
      <p>在命令中，进入到pom.xml所在目录，输入以下命令：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">$ mvn clean <span class="keyword">package</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>即可在<code>target</code>目录下获得编译后自动打包的jar。</p>

        <h2 id="镜像加速">
          <a href="#镜像加速" class="heading-link"><i class="fas fa-link"></i></a>镜像加速</h2>
      <p>中国区用户可以使用阿里云提供的Maven镜像仓库。使用Maven镜像仓库需要一个配置，在用户主目录下进入<code>.m2</code>目录，创建一个<code>settings.xml</code>配置文件，内容如下：</p>
<figure class="highlight xml"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 国内推荐阿里云的Maven镜像 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="构建流程">
          <a href="#构建流程" class="heading-link"><i class="fas fa-link"></i></a>构建流程</h1>
      
        <h2 id="Build-LifeCycle">
          <a href="#Build-LifeCycle" class="heading-link"><i class="fas fa-link"></i></a>Build LifeCycle</h2>
      <p><strong>Build LifeCycle是指一个项目build的过程</strong>。Maven的 Build LifeCycle 分为三种，分别为<code>default</code>（处理项目的部署）、<code>clean</code>（处理项目的清理）、<code>site</code>（处理项目的文档生成）。他们都包含不同的 lifecycle。</p>
<p>Build LifeCycle 是由 phases 构成的，下面重点介绍 default Build LifeCycle 几个重要的 phase：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">validate    验证项目是否正确以及必须的信息是否可用</span><br><span class="line">compile     编译源代码</span><br><span class="line">test    测试编译后的代码，即执行单元测试代码</span><br><span class="line"><span class="keyword">package</span>     打包编译后的代码，在target目录下生成<span class="keyword">package</span>文件</span><br><span class="line">integration-test    处理<span class="keyword">package</span>以便需要时可以部署到集成测试环境</span><br><span class="line">verify      检验<span class="keyword">package</span>是否有效并且达到质量标准</span><br><span class="line">install     安装<span class="keyword">package</span>到本地仓库，方便本地其它项目使用</span><br><span class="line">deploy  部署，拷贝最终的<span class="keyword">package</span>到远程仓库和替他开发这或项目共享，在集成或发布环境完成</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="Goal">
          <a href="#Goal" class="heading-link"><i class="fas fa-link"></i></a>Goal</h2>
      <p><strong>Goal代表一个特定任务。</strong></p>
<p>其实我们类比一下就明白了：</p>
<ul>
<li>lifecycle 相当于 Java 的 package，它包含一个或多个 phase；</li>
<li>phase 相当于 Java 的 class，它包含一个或多个 goal；</li>
<li>goal 相当于 class 的 method，它其实才是真正干活的。</li>
</ul>

        <h2 id="常用命令">
          <a href="#常用命令" class="heading-link"><i class="fas fa-link"></i></a>常用命令</h2>
      <p><code>mvn clean</code>：清理所有生成的class和jar；<br><code>mvn clean compile</code>：先清理，再执行到<code>compile</code>；<br><code>mvn clean test：</code>先清理，再执行到<code>test</code>，因为执行<code>test</code>前必须执行<code>compile</code>，所以这里不必指定<code>compile</code>；<br><code>mvn clean package：</code>先清理，再执行到<code>package</code>。</p>

        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309301146648610" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1252599548343744/1309301146648610</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://www.trinea.cn/android/maven/" target="_blank" rel="noopener">https://www.trinea.cn/android/maven/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（七）-- 类文件结构</title>
    <url>/Class/</url>
    <content><![CDATA[<h1 id="概述">
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      <p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），<strong>它不面向任何特定的处理器，只面向虚拟机</strong>。<br>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了<strong>解释型语言可移植</strong>的特点。<br>所以 Java 程序运行时比较高效，而且，<strong>由于字节码并不针对一种特定的机器</strong>，因此，Java 程序<strong>无须重新编译</strong>便可在多种不同操作系统的计算机上运行。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URi1MQ.png" alt="class">
      <br><strong>可以说<code>.class</code>文件是不同的语言在 Java 虚拟机之间的重要桥梁，同时也是支持 Java 跨平台很重要的一个原因。</strong></p>
<a id="more"></a>

        <h1 id="Class文件结构总结">
          <a href="#Class文件结构总结" class="heading-link"><i class="fas fa-link"></i></a>Class文件结构总结</h1>
      <p>根据 Java 虚拟机规范，<strong>类文件由单个 ClassFile 结构组成</strong>：</p>
<figure class="highlight angelscript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">ClassFile {</span><br><span class="line">    <span class="comment">// ClassFile中的文件结构只有两种数据类型：“无符号”和“表”</span></span><br><span class="line">    <span class="comment">// 无符号数：以U开头，后面的数字表示字节数</span></span><br><span class="line">    <span class="comment">// 表：以_info结尾</span></span><br><span class="line">    类型           名称     数量(除特别声明外，默认为<span class="number">1</span>)</span><br><span class="line">    u4             magic; <span class="comment">//Class 文件的标志</span></span><br><span class="line">    u2             minor_version;<span class="comment">//Class 的小版本号</span></span><br><span class="line">    u2             major_version;<span class="comment">//Class 的大版本号</span></span><br><span class="line">    u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];<span class="comment">//常量池</span></span><br><span class="line">    u2             access_flags;<span class="comment">//Class 的访问标记</span></span><br><span class="line">    u2             this_class;<span class="comment">//当前类</span></span><br><span class="line">    u2             super_class;<span class="comment">//父类</span></span><br><span class="line">    u2             <span class="built_in">int</span>erfaces_count;<span class="comment">//接口</span></span><br><span class="line">    u2             <span class="built_in">int</span>erfaces[<span class="built_in">int</span>erfaces_count];<span class="comment">//一个类可以实现多个接口</span></span><br><span class="line">    u2             fields_count;<span class="comment">//Class 文件的字段属性</span></span><br><span class="line">    field_info     fields[fields_count];<span class="comment">//一个类会可以有个字段</span></span><br><span class="line">    u2             methods_count;<span class="comment">//Class 文件的方法数量</span></span><br><span class="line">    method_info    methods[methods_count];<span class="comment">//一个类可以有个多个方法</span></span><br><span class="line">    u2             attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">    attribute_info attributes[attributes_count];<span class="comment">//属性表集合</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>Class文件字节码结构组织示意图</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URitI0.png" alt="class">
      </p>

        <h2 id="魔数">
          <a href="#魔数" class="heading-link"><i class="fas fa-link"></i></a>魔数</h2>
      <figure class="highlight monkey"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">u4             magic; //<span class="class"><span class="keyword">Class</span> 文件的标志</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>每个 Class 文件的头四个字节称为魔数（Magic Number）,也就是<code>0xCAFEBABE</code>,它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。</strong></p>
<p>程序设计者很多时候都喜欢用一些特殊的数字表示固定的文件类型或者其它特殊的含义。</p>

        <h2 id="Class文件版本">
          <a href="#Class文件版本" class="heading-link"><i class="fas fa-link"></i></a>Class文件版本</h2>
      <figure class="highlight jboss-cli"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">u2             minor_<span class="keyword">version</span>;<span class="string">//Class</span> 的小版本号</span><br><span class="line">u2             major_<span class="keyword">version</span>;<span class="string">//Class</span> 的大版本号</span><br></pre></td></tr></tbody></table></div></figure>
<p>紧接着魔数的四个字节存储的是 Class 文件的版本号：第五和第六是<strong>次版本号</strong>，第七和第八是<strong>主版本号</strong>。</p>
<blockquote>
<p>高版本的 Java 虚拟机可以执行低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行高版本编译器生成的 Class 文件。所以，我们在实际开发的时候要确保开发的的 JDK 版本和生产环境的 JDK 版本保持一致。</p>
</blockquote>

        <h2 id="常量池">
          <a href="#常量池" class="heading-link"><i class="fas fa-link"></i></a>常量池</h2>
      <figure class="highlight angelscript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">u2             constant_pool_count;<span class="comment">//常量池的数量</span></span><br><span class="line">cp_info        constant_pool[constant_pool_count<span class="number">-1</span>];<span class="comment">//常量池</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1<strong>（常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”</strong>）。</p>
<p>常量池主要存放两大常量：<strong>字面量和符号引用</strong>。字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面6类常量：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
<p>常量池中每一项常量都是一个表，这17种表有一个共同的特点：<strong>开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/17/UyJ7i4.png" alt="常量池">
      <br><code>.class</code> 文件可以通过<code>javap -v class类名</code>指令来看一下其常量池中的信息(<code>javap -v  class类名-&gt; temp.txt</code> ：将结果输出到 temp.txt 文件)。</p>

        <h2 id="访问标志">
          <a href="#访问标志" class="heading-link"><i class="fas fa-link"></i></a>访问标志</h2>
      <p>在常量池结束之后，紧接着的两个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个<code>Class</code>是类还是接口，是否为 <code>public</code> 或者 <code>abstract</code> 类型，如果是类的话是否声明为 <code>final</code> 等等。</p>
<p><strong>类访问和属性修饰符:</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/17/UyNUz9.png" alt="类访问和属性修饰符">
      <br>我们定义了一个 Employee 类</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.snailclimb.bean;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>{</span><br><span class="line">   ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>通过<code>javap -v class类名</code>指令来看一下类的访问标志。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URiaGT.png" alt="类的访问标志">
      </p>

        <h2 id="当前类索引-父类索引与接口索引集合">
          <a href="#当前类索引-父类索引与接口索引集合" class="heading-link"><i class="fas fa-link"></i></a>当前类索引,父类索引与接口索引集合</h2>
      <figure class="highlight ceylon"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">u<span class="number">2</span>             <span class="keyword">this</span><span class="number">_</span><span class="keyword">class</span>;<span class="comment">//当前类</span></span><br><span class="line">u<span class="number">2</span>             <span class="keyword">super</span><span class="number">_</span><span class="keyword">class</span>;<span class="comment">//父类</span></span><br><span class="line">u<span class="number">2</span>             interfaces<span class="number">_</span>count;<span class="comment">//接口</span></span><br><span class="line">u<span class="number">2</span>             interfaces[interfaces<span class="number">_</span>count];<span class="comment">//一个类可以实现多个接口</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 <code>java.lang.Object</code> 之外，所有的 java 类都有父类，<strong>因此除了 <code>java.lang.Object</code> 外，所有 Java 类的父类索引都不为 0。</strong></p>
<p>接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按<code>implents</code>(如果这个类本身是接口的话则是<code>extends</code>) 后的接口顺序从左到右排列在接口索引集合中。</p>

        <h2 id="字段表集合">
          <a href="#字段表集合" class="heading-link"><i class="fas fa-link"></i></a>字段表集合</h2>
      <figure class="highlight less"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">u2</span>             <span class="selector-tag">fields_count</span>;<span class="comment">//Class 文件的字段的个数</span></span><br><span class="line"><span class="selector-tag">field_info</span>     <span class="selector-tag">fields</span><span class="selector-attr">[fields_count]</span>;<span class="comment">//一个类会可以有个字段</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>字段表（field info）用于描述接口或类中声明的变量。</strong>字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URidRU.png" alt="字段表">
      </p>
<ul>
<li><code>access_flags:</code>字段的作用域（<code>public</code> ,<code>private</code>,<code>protected</code>修饰符），是实例变量还是类变量（<code>static</code>修饰符）,可否被序列化（<code>transient</code> 修饰符）,可变性（<code>final</code>）,可见性（<code>volatile</code> 修饰符，是否强制从主内存读写）。</li>
<li><code>name_index:</code> 对常量池的引用，表示的字段的名称；</li>
<li><code>descriptor_index:</code> 对常量池的引用，表示字段和方法的描述符；</li>
<li><code>attributes_count:</code> 一个字段还会拥有一些额外的属性，attributes_count 存放属性的个数；</li>
<li><code>attributes[attributes_count]:</code> 存放具体属性具体内容。</li>
</ul>
<p>上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型这些都是无法固定的，只能引用常量池中常量来描述。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/17/UyrYvD.png" alt="字段访问标志">
      </p>

        <h2 id="方法表集合">
          <a href="#方法表集合" class="heading-link"><i class="fas fa-link"></i></a>方法表集合</h2>
      <figure class="highlight less"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">u2</span>             <span class="selector-tag">methods_count</span>;<span class="comment">//Class 文件的方法的数量</span></span><br><span class="line"><span class="selector-tag">method_info</span>    <span class="selector-tag">methods</span><span class="selector-attr">[methods_count]</span>;<span class="comment">//一个类可以有个多个方法</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</p>
<p><strong>Class 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。</strong>方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/19/URiDsJ.png" alt="方法表结构">
      <br><strong>方法表的 access_flag 取值：</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/17/Uysise.png" alt="access_flag">
      </p>

    <div class="note-plugin success no-icon">
      
      <p>因为<code>volatile</code>修饰符和<code>transient</code>修饰符不可以修饰方法，所以方法表的访问标志中没有这两个对应的标志，但是增加了<code>synchronized</code>、<code>native</code>、<code>abstract</code>等关键字修饰方法，所以也就多了这些关键字对应的标志。</p>
    </div>
  

        <h2 id="属性表集合">
          <a href="#属性表集合" class="heading-link"><i class="fas fa-link"></i></a>属性表集合</h2>
      <figure class="highlight less"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">u2</span>             <span class="selector-tag">attributes_count</span>;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line"><span class="selector-tag">attribute_info</span> <span class="selector-tag">attributes</span><span class="selector-attr">[attributes_count]</span>;<span class="comment">//属性表集合</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。</strong>与 Class 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>

        <h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>这篇文章的写作顺序有点太靠后了，应该推前到前面阅读。同时我自己写完之后也只是了解了个大概，我觉得应该举一个.class文件的例子，层层分析下来的效果最好。同时这篇文章整合JavaGuide博客和《深入理解Java虚拟机》，最后推荐大家进一步阅读<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html" target="_blank" rel="noopener">这篇博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p>

        <h2 id="参考链接">
          <a href="#参考链接" class="heading-link"><i class="fas fa-link"></i></a>参考链接</h2>
      <ol>
<li>《深入理解Java虚拟机》</li>
<li><span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84?id=%e5%8f%82%e8%80%83" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84?id=%e5%8f%82%e8%80%83</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>字节码</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（六）-- 字节码执行机制(Part 3)</title>
    <url>/Class-Execution-3/</url>
    <content><![CDATA[<h1 id="动态类型语言支持">
          <a href="#动态类型语言支持" class="heading-link"><i class="fas fa-link"></i></a>动态类型语言支持</h1>
      <p><strong>动态类型语言，就是类型检查的主体过程在运行期，而非编译期的编程语言。</strong></p>
<p>动/静态类型语言各自的优点？</p>
<ul>
<li>动态类型语言：灵活性高，开发效率高。</li>
<li>静态类型语言：编译器提供了严谨的类型检查，类型相关的问题能在编码的时候就发现。<a id="more"></a>

</li>
</ul>

        <h1 id="动态类型语言">
          <a href="#动态类型语言" class="heading-link"><i class="fas fa-link"></i></a>动态类型语言</h1>
      <p>根据前面提到的动态类型语言的定义，我们将举两个例子来介绍一下<strong>什么是“类型检查”和什么是“在编译期还是运行期进行”</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> [][][] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>][<span class="number">0</span>][-<span class="number">1</span>];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>上面这段Java代码能够正常编译，但运行的时候会出现<code>NegativeArraySizeException</code>异常。</p><p>在《Java虚拟机规范》中明确规定了<code>NegativeArraySizeException</code>是一个运行时异常（<code>Runtime Exception</code>），通俗一点说，运行时异常就是指只要代码不执行到这一行就不会出现问题。</p><p>与运行时异常相对应的概念是连接时异常，例如很常见的<code>NoClassDefFoundError</code>便属于连接时异常，即使导致连接时异常的代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常。</p>
    </div>
  
<p>不过，在C语言里，<strong>语义相同的代码就会在GCC编译期就直接报错</strong>，而不是等到运行时才出现异常。</p>
<p>由此看来，一门语言的哪一种检查行为要在运行期进行，哪一种检查要在编译期进行并没有什么必然的因果逻辑关系，<strong>关键是在语言规范中人为设立的约定</strong>。</p>
<p>Java虚拟机层面提供的动态类型支持：</p>
<ul>
<li><code>invokedynamic</code> 指令 <blockquote>
<p><code>Lambda</code> 表达式就是通过 <code>invokedynamic</code> 指令实现的。</p>
</blockquote>
</li>
<li><code>java.lang.invoke</code> 包</li>
</ul>

        <h1 id="java-lang-invoke包">
          <a href="#java-lang-invoke包" class="heading-link"><i class="fas fa-link"></i></a>java.lang.invoke包</h1>
      <p>这个包的主要目的是在之前单纯依靠符号引用来确定调用的目标方法这条路之外，<strong>提供一种新的动态确定目标方法的机制，称为“方法句柄”（MethodHandle）。</strong></p>

        <h2 id="方法句柄的使用">
          <a href="#方法句柄的使用" class="heading-link"><i class="fas fa-link"></i></a>方法句柄的使用</h2>
      <ol>
<li>获得方法的参数描述，第一个参数是方法返回值的类型，之后的参数是方法的入参。<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"> MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">``` </span><br><span class="line"><span class="number">2</span>. 获取一个普通方法的调用</span><br><span class="line">```Java</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 需要的参数：</span></span><br><span class="line"><span class="comment">  * 1. 被调用方法所属类的类对象</span></span><br><span class="line"><span class="comment">  * 2. 方法名</span></span><br><span class="line"><span class="comment">  * 3. MethodType 对象 mt</span></span><br><span class="line"><span class="comment">  * 4. 调用该方法的对象</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> MethodHandle.lookup().findVirtual(receiver.getClass(), <span class="string">"方法名"</span>, mt).bindTo(receiver);</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>获取一个父类方法的调用：<figure class="highlight"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要的参数：</span></span><br><span class="line"><span class="comment"> * 1. 被调用方法所属类的类对象</span></span><br><span class="line"><span class="comment"> * 2. 方法名</span></span><br><span class="line"><span class="comment"> * 3. MethodType 对象 mt</span></span><br><span class="line"><span class="comment"> * 4. 调用这个方法的类的类对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">MethodHandle.lookup().findSpecial(GrandFather.class, "方法名", mt, getClass());</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>通过 <code>MethodHandle mh</code> 执行方法：<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">invoke() 和 invokeExact() 的区别：</span></span><br><span class="line"><span class="comment">- invokeExact() 要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内</span></span><br><span class="line"><span class="comment">- invoke() 允许更加松散的调用方式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">mh.invoke(<span class="string">"Hello world"</span>);</span><br><span class="line">mh.invokeExact(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></tbody></table></div></figure>

</li>
</ol>

        <h2 id="使用示例">
          <a href="#使用示例" class="heading-link"><i class="fas fa-link"></i></a>使用示例</h2>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodHandleTest</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String s)</span> </span>{</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        obj的静态类型是Object，是没有println方法的，</span></span><br><span class="line"><span class="comment">        但通过方法句柄，无论obj最终是哪个实现类，下面这句都能正确调用到println方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Object obj = System.currentTimeMillis() % <span class="number">2</span> == <span class="number">0</span> ? System.out : <span class="keyword">new</span> ClassA();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        invoke()和invokeExact()的区别：</span></span><br><span class="line"><span class="comment">        - invokeExact()要求更严格，要求严格的类型匹配，方法的返回值类型也在考虑范围之内</span></span><br><span class="line"><span class="comment">        - invoke()允许更加松散的调用方式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        getPrintlnMH(obj).invoke(<span class="string">"Hello world"</span>);</span><br><span class="line">        getPrintlnMH(obj).invokeExact(<span class="string">"Hello world"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> MethodHandle <span class="title">getPrintlnMH</span><span class="params">(Object receiver)</span> </span></span><br><span class="line"><span class="function">        	<span class="keyword">throws</span> NoSuchMethodException, IllegalAccessException </span>{</span><br><span class="line">        <span class="comment">/* MethodType代表方法类型，第一个参数是方法返回值的类型，之后的参数是方法的入参 */</span></span><br><span class="line">        MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        lookup()方法来自于MethodHandles.lookup，</span></span><br><span class="line"><span class="comment">        这句的作用是在指定类中查找符合给定的方法名称、方法类型，并且符合调用权限的方法句柄</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        因为这里调用的是一个虚方法，按照Java语言的规则，方法第一个参数是隐式的，代表该方法的接收者，</span></span><br><span class="line"><span class="comment">        也即是this指向的对象，这个参数以前是放在参数列表中进行传递，现在提供了bindTo()方法来完成这件事情</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> MethodHandles.lookup().findVirtual(receiver.getClass(), <span class="string">"println"</span>, mt).bindTo(receiver);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><code>MethodHandles.lookup</code> 中 3 个方法对应的字节码指令：</p>
<ul>
<li><code>findStatic()</code>：对应 <code>invokestatic</code></li>
<li><code>findVirtual()：</code>对应 <code>invokevirtual</code> &amp; <code>invokeinterface</code></li>
<li><code>findSpecial()：</code>对应 <code>invokespecial</code></li>
</ul>
<p><code>MethodHandle</code> 和 <code>Reflection</code>的区别</p>
<ul>
<li><strong>本质区别：</strong> 它们都在模拟方法调用，但是<ul>
<li><code>Reflection</code> 模拟的是 Java 代码层次的调用；</li>
<li><code>MethodHandle</code> 模拟的是字节码层次的调用。</li>
</ul>
</li>
<li><strong>包含信息的区别：</strong><ul>
<li><code>Reflection</code> 的 <code>Method</code>对象包含的信息多，包括：方法签名、方法描述符、方法的各种属性的Java端表达方式、方法执行权限等；</li>
<li><code>MethodHandle</code> 对象包含的信息比较少，既包含与执行该方法相关的信息。</li>
</ul>
</li>
</ul>

        <h1 id="实战演示">
          <a href="#实战演示" class="heading-link"><i class="fas fa-link"></i></a>实战演示</h1>
       <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GrandFather</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"I am grandfather"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Father</span> <span class="keyword">extends</span> <span class="title">GrandFather</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"I am father"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>{</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">thinking</span><span class="params">()</span></span>{</span><br><span class="line">            <span class="keyword">try</span>{</span><br><span class="line">                <span class="comment">// 获取方法的类型</span></span><br><span class="line">                MethodType mt = MethodType.methodType(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                <span class="comment">// 实现动态方法调用</span></span><br><span class="line">                MethodHandle mh = lookup().findSpecial(GrandFather.class,"thinking",mt,getClass());</span><br><span class="line">                <span class="comment">// 执行该方法</span></span><br><span class="line">                mh.invoke(<span class="keyword">this</span>);</span><br><span class="line">            }<span class="keyword">catch</span>(Throwable e){</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        (<span class="keyword">new</span> Test().<span class="keyword">new</span> Son()).thinking();</span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">        实现了调用祖父类的方法</span></span><br><span class="line"><span class="comment">        输出：</span></span><br><span class="line"><span class="comment">        I am grandfather </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p><strong>在Java程序中，可以通过<code>“super”</code>关键字很方便地调用到父类中的方法，但却无法访问祖类的方法呢？</strong></p><p>原因是在<code>Son</code>类的<code>thinking()</code>方法中根本无法获取到一个实际类型是<code>GrandFather</code>的对象引用，而<code>invokevirtual</code>指令的分派逻辑是固定的，只能按照方法接收者的实际类型进行分派，这个逻辑完全固化在虚拟机中，程序员无法改变。</p>
    </div>
  


        <h1 id="基于栈的字节码解释执行引擎">
          <a href="#基于栈的字节码解释执行引擎" class="heading-link"><i class="fas fa-link"></i></a>基于栈的字节码解释执行引擎</h1>
      <p>前面一章我们提到，<strong>基于栈的解释执行，是真正地执行方法地字节码</strong>。这里的栈是Part 1中提到的，<strong>栈帧中的操作数栈</strong>。</p>

        <h2 id="解释执行">
          <a href="#解释执行" class="heading-link"><i class="fas fa-link"></i></a>解释执行</h2>
      <p>先通过 <code>javac</code> 将代码编译成字节码，虚拟机再通过加载字节码文件，<strong>解释执行</strong>字节码文件生成机器码，解释执行的流程如下：</p>
<figure class="highlight clean"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">词法分析 -&gt; 语法分析 -&gt; 形成抽象语法树 -&gt; 遍历语法树生成线性字节码指令流</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="指令集分类">
          <a href="#指令集分类" class="heading-link"><i class="fas fa-link"></i></a>指令集分类</h1>
      
        <h2 id="基于栈的指令集">
          <a href="#基于栈的指令集" class="heading-link"><i class="fas fa-link"></i></a>基于栈的指令集</h2>
      <ul>
<li><strong>优点：</strong><ul>
<li>可移植：寄存器由硬件直接提供，程序如果直接依赖这些硬件寄存器，会不可避免的受到硬件的约束；</li>
<li>代码更紧凑：字节码中每个字节对应一条指令，多地址指令集中还需要存放参数；</li>
<li>编译器实现更简单：不需要考虑空间分配问题，所需的空间都在栈上操作。</li>
</ul>
</li>
<li><strong>缺点：</strong> 执行速度稍慢<ul>
<li>完成相同的功能，需要更多的指令，因为出入栈本身就产生相当多的指令；</li>
<li>频繁的栈访问导致频繁的内存访问，对于处理器而言，内存是执行速度的瓶颈。</li>
</ul>
</li>
</ul>
<p><strong>示例：两数相加</strong></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">iconst_1  <span class="comment">// 把常量1入栈</span></span><br><span class="line">iconst_1</span><br><span class="line">iadd      <span class="comment">// 把栈顶两元素出栈相加，结果再放回栈顶</span></span><br><span class="line">istore_0  <span class="comment">// 把栈顶值存入局部变量表第0个Slot中</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="基于寄存器的指令集">
          <a href="#基于寄存器的指令集" class="heading-link"><i class="fas fa-link"></i></a>基于寄存器的指令集</h1>
      <p><strong>示例：两数相加</strong></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">mov  eax, <span class="number">1</span> <span class="comment">// 把EAX寄存器的值设为1</span></span><br><span class="line">add  eax, <span class="number">1</span> <span class="comment">// 把这个值加1，结果就保存在EAX寄存器里面</span></span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="执行过程分析">
          <a href="#执行过程分析" class="heading-link"><i class="fas fa-link"></i></a>执行过程分析</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Architecture</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Architecture architecture = <span class="keyword">new</span> Architecture();</span><br><span class="line">        architecture.calc();</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    calc函数的字节码分析：</span></span><br><span class="line"><span class="comment">    public int calc();</span></span><br><span class="line"><span class="comment">    descriptor: ()I</span></span><br><span class="line"><span class="comment">    flags: ACC_PUBLIC</span></span><br><span class="line"><span class="comment">    Code:</span></span><br><span class="line"><span class="comment">    stack=2, locals=4, args_size=1 </span></span><br><span class="line"><span class="comment">    // stack=2，说明需要深度为2的操作数栈</span></span><br><span class="line"><span class="comment">    // locals=4，说明需要4个Slot的局部变量表</span></span><br><span class="line"><span class="comment">    // args_size=1, 说明方法参数的个数为1，这里为默认隐藏的this</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    0: bipush 100                  // 将单字节的整型常数值push到操作数栈</span></span><br><span class="line"><span class="comment">    2: istore_1                    // 将操作数栈顶的整型值出栈并存放到第一个局部变量Slot中</span></span><br><span class="line"><span class="comment">    3: sipush 200</span></span><br><span class="line"><span class="comment">    6: istore_2</span></span><br><span class="line"><span class="comment">    7: sipush 300</span></span><br><span class="line"><span class="comment">    10: istore_3</span></span><br><span class="line"><span class="comment">    11: iload_1                    // 将局部变量表第一个Slot中的整型值复制到操作数栈顶</span></span><br><span class="line"><span class="comment">    12: iload_2</span></span><br><span class="line"><span class="comment">    13: iadd                       // 将操作数栈中头两个元素出栈并相加，将结果重新入栈</span></span><br><span class="line"><span class="comment">    14: iload_3</span></span><br><span class="line"><span class="comment">    15: imul                       // 将操作数栈中头两个元素出栈并相乘，将结果重新入栈</span></span><br><span class="line"><span class="comment">    16: ireturn                    // 返回指令，结束方法执行，将操作数栈顶的整型值返回给此方法的调用者</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="参考链接">
          <a href="#参考链接" class="heading-link"><i class="fas fa-link"></i></a>参考链接</h1>
      <ol>
<li>《深入理解Java虚拟机》</li>
<li><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md" target="_blank" rel="noopener">https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_02-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.md" target="_blank" rel="noopener">https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_02-%E5%9F%BA%E4%BA%8E%E6%A0%88%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E.md</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>字节码</tag>
        <tag>动态类型语言支持</tag>
        <tag>基于栈的字节码解释执行引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（五）-- 字节码执行机制(Part 2)</title>
    <url>/Class-Execution-2/</url>
    <content><![CDATA[<h1 id="方法调用">
          <a href="#方法调用" class="heading-link"><i class="fas fa-link"></i></a>方法调用</h1>
      <p>Java 的方法的执行分为两个部分：<br><strong>1. 方法调用：确定被调用的方法是哪一个；<br>2. 基于栈的解释执行：真正地执行方法的字节码。</strong></p>
<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本（即调用哪一个方法）</strong>，暂时还未涉及方法内部的具体运行过程。</p>
<a id="more"></a>

    <div class="note-plugin success no-icon">
      
      <p>一切方法的调用在 Class 文件中存储的都是常量池中的符号引用，而不是方法实际运行时的入口地址（直接引用），直到类加载的时候，甚至是实际运行的时候才回去会去确定要被运行的方法的直接引用。</p>
    </div>
  


        <h1 id="解析调用">
          <a href="#解析调用" class="heading-link"><i class="fas fa-link"></i></a>解析调用</h1>
      <p><strong>解析(Resolution),指的是在类加载的解析阶段就完成方法调用。</strong></p>
<p>解析调用能够成立的条件：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可变的，<strong>即“编译期可知，运行期不可变”。</strong></p>

    <div class="note-plugin success no-icon">
      
      <p><strong>满足这个要求的方法有两类：静态方法、私有方法</strong><br>前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。</p>
    </div>
  


        <h2 id="方法调用字节码指令">
          <a href="#方法调用字节码指令" class="heading-link"><i class="fas fa-link"></i></a>方法调用字节码指令</h2>
      <p><strong>调用不同类型的方法，字节码指令集里设计了不同的指令。</strong>在Java虚拟机支持以下5条方法调用字节码指令，分别是：</p>
<ul>
<li><code>invokestatic</code>：调用静态方法；</li>
<li><code>invokespecial</code>：调用构造器<init>方法、私有方法、父类方法；</init></li>
<li><code>invokevirtual</code>：调用所有虚方法，除了静态方法、构造器方法、私有方法、父类方法、final 方法的其他方法叫虚方法；</li>
<li><code>invokeinterface</code>：调用接口方法，会在运行时确定一个该接口的实现对象；</li>
<li><code>invokedynamic</code>：在运行时动态解析出调用点限定符引用的方法，再执行该方法。</li>
</ul>
<blockquote>
<p>前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而<code>invokedynamic</code>指令的分派逻辑是由用户设定的引导方法来决定的，其实从 dynamic 的意思就看的出来。<br>这是因为其他 4 种方法的第一个参数都是<strong>被调用的方法的符号引用，是在编译时确定的，所以它们缺乏动态类型语言支持</strong>，因为动态类型语言只有在运行期才能确定接收者的类型，即变量的类型检查的主体过程在运行期，而非编译期。</p>
</blockquote>

    <div class="note-plugin success no-icon">
      
      <p><strong>因此解析调用对应的方法调用指令为：</strong></p><ul><li><code>invokestatic</code>：调用静态方法；</li><li><code>invokespecial</code>：调用构造器<init>方法、私有方法、父类方法；</init></li><li>被final修饰的方法（尽管它使用<code>invokevirtual</code>指令调用）</li></ul>
    </div>
  


        <h1 id="分派调用">
          <a href="#分派调用" class="heading-link"><i class="fas fa-link"></i></a>分派调用</h1>
      <p>在介绍分派调用前，我们先来介绍一下 Java 所具备的面向对象的 3 个基本特征：封装，继承，多态。</p>
<p>其中多态最基本的体现就是重载和重写了，<strong>重载和重写的一个重要特征就是方法名相同，其他各种不同：</strong></p>
<ul>
<li>重载：发生在同一个类中，入参必须不同，返回类型、访问修饰符、抛出的异常都可以不同；</li>
<li>重写：发生在子父类中，入参和返回类型必须相同，访问修饰符大于等于被重写的方法，不能抛出新的异常。</li>
</ul>
<p>相同的方法名实际上给虚拟机的调用带来了困惑，<strong>因为虚拟机需要判断，它到底应该调用哪个方法，而这个过程会在分派调用中体现出来。</strong>其中：</p>
<ul>
<li><strong>方法重载 —— 静态分派</strong></li>
<li><strong>方法重写 —— 动态分派</strong></li>
</ul>

        <h2 id="静态分派">
          <a href="#静态分派" class="heading-link"><i class="fas fa-link"></i></a>静态分派</h2>
      <p>在介绍静态分派前，我们先来介绍一下什么是变量的<strong>静态类型和实际类型</strong>。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>{</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>{</span><br><span class="line">    	System.out.println(<span class="string">"Hello guy!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>{</span><br><span class="line">    	System.out.println(<span class="string">"Hello man!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>{</span><br><span class="line">    	System.out.println(<span class="string">"Hello woman!"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        StaticDispatch sr = <span class="keyword">new</span> StaticDispatch();</span><br><span class="line">        sr.sayHello(man);</span><br><span class="line">        sr.sayHello(woman);</span><br><span class="line">        <span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">        Hello guy!</span></span><br><span class="line"><span class="comment">        Hello guy!</span></span><br><span class="line"><span class="comment">        因为是根据变量的静态类型，也就是左面的类型：Human 来判断调用哪个方法，</span></span><br><span class="line"><span class="comment">        所以调用的都是 public void sayHello(Human guy)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 简单讲解 */</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际类型发生变化</span></span><br><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">man = <span class="keyword">new</span> Woman();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态类型发生变化</span></span><br><span class="line">sr.sayHello((Man) man);   <span class="comment">// 输出：Hello man!</span></span><br><span class="line">sr.sayHello((Woman) man); <span class="comment">// 输出：Hello woman!</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>其中 <code>Human</code> 称为变量的静态类型，<code>Man</code> 称为变量的实际类型。<br>在重载时，编译器是通过方法参数的静态类型，而不是实际类型，来判断应该调用哪个方法的。</strong></p>
<p><strong>所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派的最典型应用表现就是方法重载。</strong>静态分派发生在javac编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。</p>

        <h2 id="动态分派">
          <a href="#动态分派" class="heading-link"><i class="fas fa-link"></i></a>动态分派</h2>
      <p><strong>动态分派就是在运行时，根据实际类型确定方法执行版本的分派过程。</strong></p>
<p>动态分派的过程：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>{</span><br><span class="line">  	  <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        	System.out.println(<span class="string">"Hello man"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>{</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        	System.out.println(<span class="string">"Hello woman"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Human man = <span class="keyword">new</span> Man();</span><br><span class="line">        Human woman = <span class="keyword">new</span> Woman();</span><br><span class="line">        man.sayHello();</span><br><span class="line">        woman.sayHello();</span><br><span class="line">        man = woman;</span><br><span class="line">        man.sayHello();</span><br><span class="line">        <span class="comment">/* 输出</span></span><br><span class="line"><span class="comment">        Hello man</span></span><br><span class="line"><span class="comment">        Hello woman</span></span><br><span class="line"><span class="comment">        Hello woman</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>显然这里选择调用的方法版本是不可能再根据静态类型来决定的，因为静态类型同样都是 <code>Human</code> 的两个变量 <code>man</code> 和 <code>woman</code> 在调用<code>sayHello()</code>方法时产生了不同的行为，甚至变量 <code>man</code> 在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同。</p>
<p><strong><code>javap</code> 输出字节码分析：</strong></p>
<figure class="highlight angelscript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">javap -verbose DynamicDispatch</span><br><span class="line"><span class="keyword">public</span> static <span class="built_in">void</span> main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">        stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: new           #<span class="number">2</span>      <span class="comment">// class com/jvm/ch8/DynamicDispatch$Man</span></span><br><span class="line">        <span class="number">3</span>: dup</span><br><span class="line">        <span class="number">4</span>: invokespecial #<span class="number">3</span>      <span class="comment">// Method com/jvm/ch8/DynamicDispatch$Man."&lt;init&gt;":()V</span></span><br><span class="line">        <span class="number">7</span>: astore_1</span><br><span class="line">        <span class="number">8</span>: new           #<span class="number">4</span>      <span class="comment">// class com/jvm/ch8/DynamicDispatch$Woman</span></span><br><span class="line">        <span class="number">11</span>: dup</span><br><span class="line">        <span class="number">12</span>: invokespecial #<span class="number">5</span>     <span class="comment">// Method com/jvm/ch8/DynamicDispatch$Woman."&lt;init&gt;":()V</span></span><br><span class="line">        <span class="number">15</span>: astore_2</span><br><span class="line">        <span class="number">16</span>: aload_1		        <span class="comment">// 把刚创建的对象的引用压到操作数栈顶，</span></span><br><span class="line">                                <span class="comment">// 供之后执行sayHello时确定是执行哪个对象的sayHello</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">6</span>    <span class="comment">// 方法调用</span></span><br><span class="line">        <span class="number">20</span>: aload_2             <span class="comment">// 把刚创建的对象的引用压到操作数栈顶，</span></span><br><span class="line">                                <span class="comment">// 供之后执行sayHello时确定是执行哪个对象的sayHello</span></span><br><span class="line">        <span class="number">21</span>: invokevirtual #<span class="number">6</span>    <span class="comment">// 方法调用</span></span><br><span class="line">        <span class="number">24</span>: aload_2</span><br><span class="line">        <span class="number">25</span>: astore_1</span><br><span class="line">        <span class="number">26</span>: aload_1</span><br><span class="line">        <span class="number">27</span>: invokevirtual #<span class="number">6</span>    <span class="comment">// Method com/jvm/ch8/DynamicDispatch$Human.sayHello:()V</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><code>invokevirtual</code>指令的运行时解析过程:</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的<strong>实际类型</strong>，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回<code>java.lang.IllegalAccessError</code>异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<p>正是因为<code>invokevirtual</code>指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的<code>invokevirtual</code>指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法版本，<strong>这个过程就是Java语言中方法重写的本质。</strong></p>
<p><strong>我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</strong></p>
<p><strong>字段永远不参与多态</strong>，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHasNoPolymorphic</span></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>{</span><br><span class="line">            money = <span class="number">2</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"I am Father,i have $"</span> + money);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>{</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> money = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>{</span><br><span class="line">            money = <span class="number">4</span>;</span><br><span class="line">            showMeTheMoney();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMeTheMoney</span><span class="params">()</span></span>{</span><br><span class="line">            System.out.println(<span class="string">"I am Son,i have $"</span> + money);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        Father gay = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(<span class="string">"This gay has $"</span> + gay.money);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>本来不想打上面的代码，但是这个输出里面涉及的知识很多，我觉得大多数人的都不知道正确的输出。<br><strong>正确输出：</strong></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">I am Son,i have $<span class="number">0</span></span><br><span class="line">I am Son,i have $<span class="number">4</span></span><br><span class="line">This gay has $<span class="number">2</span></span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p><strong>惊不惊喜，意不意外</strong><br>输出两句都是<code>“I am Son”</code>，这是因为<code>Son</code>类在创建的时候，首先隐式调用了<code>Father</code>的构造函数，而<code>Father</code>构造函数中对<code>showMeTheMoney()</code>的调用是一次虚方法调用，实际执行的版本是<code>Son::showMeTheMoney()</code>方法，所以输出的是<code>“Iam Son”</code>，这点经过前面的分析相信读者是没有疑问的了。</p><p>而这时候虽然父类的<code>money</code>字段已经被初始化成2了，但<code>Son::showMeTheMoney()</code>方法中访问的却是子类的<code>money</code>字段，这时候结果自然还是0，因为它要到子类的构造函数执行时才会被初始化。<code>main()</code>的最后一句通过静态类型访问到了父类中的<code>money</code>，输出了2。</p>
    </div>
  

        <h2 id="单分派与多分派">
          <a href="#单分派与多分派" class="heading-link"><i class="fas fa-link"></i></a>单分派与多分派</h2>
      <p><strong>方法的接收者与方法的参数统称为方法的宗量,据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。</strong></p>
<ol>
<li>Java 语言的静态分派属于多分派，根据 <strong>方法接收者的静态类型</strong> 和 <strong>方法参数类型</strong> 两个宗量进行选择。</li>
<li>Java 语言的动态分派属于单分派，只根据 <strong>方法接收者的实际类型</strong> 一个宗量进行选择。</li>
</ol>

        <h2 id="虚拟机动态分派的实现">
          <a href="#虚拟机动态分派的实现" class="heading-link"><i class="fas fa-link"></i></a>虚拟机动态分派的实现</h2>
      <p>动态分派在虚拟机中执行的非常频繁，而且方法查找的过程要在类的方法元数据中搜索合适的目标，从性能上考虑，不太可能进行如此频繁的搜索，需要进行性能上的优化。</p>
<p><strong>一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表(VirtualMethod Table)。</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/16/UDyNqA.png" alt="虚方法表">
      </p>

    <div class="note-plugin success no-icon">
      
      <p><strong>虚方法表中存放着各个方法的实际入口地址。</strong><br>如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p><p>在图中，<code>Son</code>重写了来自<code>Father</code>的全部方法，因此<code>Son</code>的方法表没有指向<code>Father</code>类型数据的箭头。但是<code>Son</code>和<code>Father</code>都没有重写来自<code>Object</code>的方法，所以它们的方法表中所有从<code>Object</code>继承来的方法都指向了<code>Object</code>的数据类型。</p>
    </div>
  


        <h1 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h1>
      <ol>
<li>《深入理解Java虚拟机》</li>
<li><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md" target="_blank" rel="noopener">https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>字节码</tag>
        <tag>方法调用</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（四）-- 字节码执行机制(Part 1)</title>
    <url>/Class-Execution-1/</url>
    <content><![CDATA[<h1 id="运行时栈帧结构">
          <a href="#运行时栈帧结构" class="heading-link"><i class="fas fa-link"></i></a>运行时栈帧结构</h1>
      <p>Java虚拟机以方法作为最基本的执行单元，<code>“栈帧”（Stack Frame）</code>则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的<code>虚拟机栈（Virtual Machine Stack）</code>的栈元素。</p>
<p><strong>每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。</strong></p>
<a id="more"></a>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/15/Uw3Trd.png" alt="Stack Frame">
      </p>

        <h1 id="局部变量表">
          <a href="#局部变量表" class="heading-link"><i class="fas fa-link"></i></a>局部变量表</h1>
      <p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>

    <div class="note-plugin success no-icon">
      
      <p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>
    </div>
  
<ul>
<li>最小单位：变量槽（Variable Slot）<ul>
<li>一个 Slot 中可以存放：boolean，byte，char，short，int，float，reference，returnAddress (少见)；</li>
</ul>
</li>
<li>虚拟机可通过局部变量表中的 reference 做到：<ul>
<li>查找 Java 堆中的实例对象的起始地址或索引；</li>
<li>查找方法区中的 Class 对象。</li>
</ul>
</li>
</ul>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。</p>

    <div class="note-plugin warning no-icon">
      
      <p>如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
    </div>
  

        <h2 id="变量槽复用">
          <a href="#变量槽复用" class="heading-link"><i class="fas fa-link"></i></a>变量槽复用</h2>
      <p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的变量槽是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。</p>
<p><strong>但是变量槽的复用也会影响系统的垃圾收集行为。</strong></p>

    <div class="note-plugin info no-icon">
      
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="comment">// 向内存中填充64MB的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    System.gc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>-verbose:gc 查看运行结果：<figure class="highlight angelscript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">68813</span>K-&gt;<span class="number">66304</span>K(<span class="number">123904</span>K), <span class="number">0.0034797</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66304</span>K-&gt;<span class="number">66204</span>K(<span class="number">123904</span>K), <span class="number">0.0086225</span> secs]  </span><br><span class="line"><span class="comment">// 没有被回收</span></span><br></pre></td></tr></tbody></table></div></figure>因为在执行System.gc()时，变量placeholder还处于作用域之内，虚拟机自然不敢回收掉placeholder的内存。<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 修改作用域</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="params">()</span></span>{</span><br><span class="line">    {</span><br><span class="line">    <span class="comment">// 向内存中填充64MB的数据</span></span><br><span class="line">    <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    }</span><br><span class="line">    System.gc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>再次查看执行结果：发现依旧没有被回收<p>我们再尝试再System.gc()调用前加入一行“int a=0；”</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">byte</span>[] placeholder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; <span class="comment">// 新加一个赋值操作</span></span><br><span class="line">    System.gc();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>-verbose:gc 输出：<figure class="highlight angelscript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">[GC (System.gc())  <span class="number">68813</span>K-&gt;<span class="number">66320</span>K(<span class="number">123904</span>K), <span class="number">0.0017394</span> secs]</span><br><span class="line">[Full GC (System.gc())  <span class="number">66320</span>K-&gt;<span class="number">668</span>K(<span class="number">123904</span>K), <span class="number">0.0084337</span> secs]  </span><br><span class="line"><span class="comment">// 内存被回收了</span></span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  
<p><strong>placeholder能否被回收的根本原因就是：</strong><br><strong>局部变量表中的变量槽是否还存有关于 placeholder 数组对象的引用。</strong><br>第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，再没有发生过任何对局部变量表的读写操作， placeholder 原本所占用的变量槽还没有被其他变量所复用，所以作为GC Roots一部分的局部变量表仍然保持着对它的关联。<br>第二次修改后，int a 占用了原来 placeholder 所在的 Slot，所以可以被 GC 掉了。</p>

        <h1 id="操作数栈">
          <a href="#操作数栈" class="heading-link"><i class="fas fa-link"></i></a>操作数栈</h1>
      <p><strong>操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。</strong></p>

    <div class="note-plugin success no-icon">
      
      <p>同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。</p>
    </div>
  

<ul>
<li>元素可以是任意 Java 类型，32 位数据占 1 个栈容量，64 位数据占 2 个栈容量；</li>
<li>Java 虚拟机的解释执行称为：基于栈的执行引擎，其中 “栈” 指的就是操作数栈；</li>
</ul>
<p>另外在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。</p>

    <div class="note-plugin success no-icon">
      
      <p>让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了，重叠的过程如下图所示。</p>
    </div>
   
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/15/UwLbgs.png" alt="Operand Stack">
      </p>

        <h1 id="动态链接">
          <a href="#动态链接" class="heading-link"><i class="fas fa-link"></i></a>动态链接</h1>
      <p><strong>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</strong></p>

    <div class="note-plugin info no-icon">
      
      <p>我们知道Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。</p><ol><li>这些符号引用一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。</li><li>另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。</li></ol>
    </div>
   


        <h1 id="方法返回地址">
          <a href="#方法返回地址" class="heading-link"><i class="fas fa-link"></i></a>方法返回地址</h1>
      <p><strong>当一个方法开始执行后，只有两种方式退出这个方法。</strong></p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令。</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理。</li>
</ol>
<p>无论采用何种退出方式，在方法退出之后，<strong>都必须返回到最初方法被调用时的位置</strong>，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。</p>
<p>方法推出操作有：<strong>等同于把当前栈帧出栈</strong></p>
<ol>
<li>恢复上层方法的局部变量表和操作数栈；</li>
<li>把返回值压入调用者栈帧的操作数栈；</li>
<li>调整 PC 计数器指向方法调用后面的指令。</li>
</ol>

        <h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>距离上次看JVM的文章以前过去一个多月了，现在再重新开始感觉很吃力，写的进度很慢。其次是关于字节码执行机制的文章很少，我之前也没有了解过这个，写的时候只能参考《深入理解Java虚拟机》。最后限于篇幅和精力，这篇文章只写了字节码执行机制的一部分，后续会补上。</p>

        <h2 id="参考资料">
          <a href="#参考资料" class="heading-link"><i class="fas fa-link"></i></a>参考资料</h2>
      <ol>
<li><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/02-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E_01-%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.md" target="_blank" rel="noopener">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>《深入理解Java虚拟机》</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>字节码</tag>
        <tag>运行时栈帧结构</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/ArrayList/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p><strong><code>ArrayList</code> 的底层是数组队列，相当于动态数组。</strong>与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p>它继承于 <code>AbstractList</code>，实现了 <code>List, RandomAccess, Cloneable, java.io.Serializable</code> 这些接口。<span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/ArrayList" target="_blank" rel="noopener">JavaGuide</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="核心源码">
          <a href="#核心源码" class="heading-link"><i class="fas fa-link"></i></a>核心源码</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Predicate;</span><br><span class="line"><span class="keyword">import</span> java.util.function.UnaryOperator;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">// 继承自<span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;，<span class="title">E</span>为泛型中的通配符，表示元素，一般集合用<span class="title">E</span>，类用<span class="title">T</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">        // 实现这四个接口</span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认初始容量大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空数组（用于空实例）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">     <span class="comment">//用于默认大小空实例的共享空数组实例。</span></span><br><span class="line">      <span class="comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将ArrayList中的元素存入数组缓存区去</span></span><br><span class="line"><span class="comment">     * ArrayList的容量是此数组缓冲区的长度。</span></span><br><span class="line"><span class="comment">     * 当初始为空数组elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA时，添加第一个元素后，数组容易变为DEFAULT_CAPACITY = 10</span></span><br><span class="line"><span class="comment">     * 对于使用transient关键词修饰有疑问，为什么不进行序列化？？？</span></span><br><span class="line"><span class="comment">     * 待解决</span></span><br><span class="line"><span class="comment">     * 我在StackOverFlow上找到了答案：</span></span><br><span class="line"><span class="comment">     * ArrayList在序列化的时候会调用writeObject，直接将size和element写入ObjectOutputStream；反序列化时调用readObject，从ObjectInputStream获取size和element，再恢复到elementData。</span></span><br><span class="line"><span class="comment">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 为什么不直接用elementData来序列化，而采用上诉的方式来实现序列化呢？原因在于elementData是一个缓存数组，它通常会预留一些容量，等容量不足时再扩充容量，那么有些空间可能就没有实际存储元素，采用上诉的方式来实现序列化时，就可以保证只序列化实际存储的那些元素，而不是整个数组，从而节省空间和时间。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList 所包含的元素个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">//如果传入的参数等于0，创建空数组</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">//其他情况，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *默认无参构造函数</span></span><br><span class="line"><span class="comment">     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个包含指定集合的元素的列表，其顺序由集合的迭代器返回。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">        <span class="comment">//将指定集合转换为数组</span></span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="comment">//如果elementData数组的长度不为0</span></span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）      </span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                //将原来不是<span class="title">Object</span>类型的<span class="title">elementData</span>数组的内容，赋值给新的<span class="title">Object</span>类型的<span class="title">elementData</span>数组</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 其他情况，用空数组代替</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) {</span><br><span class="line">            <span class="comment">// 这里是一个条件运算符，如果size为0，则elementData为空数组=EMPTY_ELEMENTDATA，若不为0则采用Arrays.copyOf方法，根据size修改修改ArrayList实例的大小</span></span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"><span class="comment">//下面是ArrayList的扩容机制</span></span><br><span class="line"><span class="comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span></span><br><span class="line"><span class="comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span></span><br><span class="line"><span class="comment">// 这同时也是为什么上一步的trimToSize()需要修改容量的原因</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span></span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line">        <span class="comment">//如果最小容量大于已有的最大容量</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) {</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">   <span class="comment">//得到最小扩容量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</span><br><span class="line">              <span class="comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span></span><br><span class="line">            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    }</span><br><span class="line">  <span class="comment">//判断是否需要扩容</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span></span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 要分配的最大数组大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ArrayList扩容的核心方法。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">        <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span></span><br><span class="line">        <span class="comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span></span><br><span class="line">        <span class="comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//比较minCapacity和 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中的元素数。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表不包含元素，则返回 true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">//注意=和==的区别</span></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果此列表包含指定的元素，则返回true 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line">        <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="comment">//equals()方法比较</span></span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">            <span class="comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span></span><br><span class="line">            v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">            v.modCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        } <span class="keyword">catch</span> (CloneNotSupportedException e) {</span><br><span class="line">            <span class="comment">// 这不应该发生，因为我们是可以克隆的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。 </span></span><br><span class="line"><span class="comment">     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span></span><br><span class="line"><span class="comment">     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object[] toArray() {</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; </span></span><br><span class="line"><span class="comment">     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。 </span></span><br><span class="line"><span class="comment">     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。 </span></span><br><span class="line"><span class="comment">     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span></span><br><span class="line"><span class="comment">     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。） </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) {</span><br><span class="line">        <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">            <span class="comment">// 新建一个运行时类型的数组</span></span><br><span class="line">            <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">            <span class="comment">//调用System提供的arraycopy()方法实现数组之间的复制</span></span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">            a[size] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Positional Access Operations</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回此列表中指定位置的元素。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用指定的元素替换此列表中指定位置的元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>{</span><br><span class="line">        <span class="comment">//对index进行界限检查</span></span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="comment">//返回原来在这个位置的元素</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>{</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment">     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment">     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>{</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        <span class="comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">        <span class="comment">/* public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</span></span><br><span class="line"><span class="comment">            src:源数组;</span></span><br><span class="line"><span class="comment">            srcPos:源数组要复制的起始位置;</span></span><br><span class="line"><span class="comment">            dest:目的数组;</span></span><br><span class="line"><span class="comment">            destPos:目的数组放置的起始位置;</span></span><br><span class="line"><span class="comment">            length:复制的长度. */</span></span><br><span class="line"></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">      <span class="comment">//从列表中删除的元素 </span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span></span><br><span class="line"><span class="comment">     *返回true，如果此列表包含指定的元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) {</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) {</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Private remove method that skips bounds checking and does not</span></span><br><span class="line"><span class="comment">     * return the value removed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中删除所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把数组中所有的元素的值设为null</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>{</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span></span><br><span class="line"><span class="comment">     *将任何后续元素移动到左侧（减少其索引）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>{</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear to let GC do its work</span></span><br><span class="line">        <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) {</span><br><span class="line">            elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        size = newSize;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查给定的索引是否在范围内。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * add和addAll使用的rangeCheck的一个版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回IndexOutOfBoundsException细节信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">outOfBoundsMsg</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Index: "</span>+index+<span class="string">", Size: "</span>+size;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从此列表中删除指定集合中包含的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>{</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="comment">//如果此列表被修改则返回true</span></span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 仅保留此列表中包含在指定集合中的元素。</span></span><br><span class="line"><span class="comment">     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>{</span><br><span class="line">        Objects.requireNonNull(c);</span><br><span class="line">        <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 迭代器部分没有怎么了解</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span></span><br><span class="line"><span class="comment">     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *返回列表中的列表迭代器（按适当的顺序）。 </span></span><br><span class="line"><span class="comment">     *返回的列表迭代器是fail-fast 。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ListItr(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *以正确的顺序返回该列表中的元素的迭代器。 </span></span><br><span class="line"><span class="comment">     *返回的迭代器是fail-fast 。 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="Demo">
          <a href="#Demo" class="heading-link"><i class="fas fa-link"></i></a>Demo</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> list;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span></span>{</span><br><span class="line">         ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">         System.out.printf(<span class="string">"Before add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         arrayList.add(<span class="number">1</span>);</span><br><span class="line">         arrayList.add(<span class="number">3</span>);</span><br><span class="line">         arrayList.add(<span class="number">5</span>);</span><br><span class="line">         arrayList.add(<span class="number">7</span>);</span><br><span class="line">         arrayList.add(<span class="number">9</span>);</span><br><span class="line">         System.out.printf(<span class="string">"After add:arrayList.size() = %d\n"</span>,arrayList.size());</span><br><span class="line"></span><br><span class="line">         System.out.println(<span class="string">"Printing elements of arrayList"</span>);</span><br><span class="line">         <span class="comment">// 三种遍历方式打印元素</span></span><br><span class="line">         <span class="comment">// 第一种：通过迭代器遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过迭代器遍历:"</span>);</span><br><span class="line">         Iterator&lt;Integer&gt; it = arrayList.iterator();</span><br><span class="line">         <span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">             System.out.print(it.next() + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种：通过索引值遍历</span></span><br><span class="line">         System.out.print(<span class="string">"通过索引值遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrayList.size(); i++){</span><br><span class="line">             System.out.print(arrayList.get(i) + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第三种：for循环遍历</span></span><br><span class="line">         System.out.print(<span class="string">"for循环遍历:"</span>);</span><br><span class="line">         <span class="keyword">for</span>(Integer number : arrayList){</span><br><span class="line">             System.out.print(number + <span class="string">" "</span>);</span><br><span class="line">         }</span><br><span class="line"></span><br><span class="line">         <span class="comment">// toArray用法</span></span><br><span class="line">         <span class="comment">// 第一种方式(最常用)</span></span><br><span class="line">         Integer[] integer = arrayList.toArray(<span class="keyword">new</span> Integer[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 第二种方式(容易理解)</span></span><br><span class="line">         Integer[] integer1 = <span class="keyword">new</span> Integer[arrayList.size()];</span><br><span class="line">         arrayList.toArray(integer1);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 抛出异常，java不支持向下转型</span></span><br><span class="line">         <span class="comment">//Integer[] integer2 = new Integer[arrayList.size()];</span></span><br><span class="line">         <span class="comment">//integer2 = arrayList.toArray();</span></span><br><span class="line">         System.out.println();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">         arrayList.add(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// 删除指定位置上的元素</span></span><br><span class="line">         arrayList.remove(<span class="number">2</span>);    </span><br><span class="line">         <span class="comment">// 删除指定元素</span></span><br><span class="line">         arrayList.remove((Object)<span class="number">3</span>);</span><br><span class="line">         <span class="comment">// 判断arrayList是否包含5</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList contains 5 is: "</span> + arrayList.contains(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 清空ArrayList</span></span><br><span class="line">         arrayList.clear();</span><br><span class="line">         <span class="comment">// 判断ArrayList是否为空</span></span><br><span class="line">         System.out.println(<span class="string">"ArrayList is empty: "</span> + arrayList.isEmpty());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p><strong>运行结果</strong><br>Before add:arrayList.size() = 0<br>After add:arrayList.size() = 5<br>Printing elements of arrayList<br>通过迭代器遍历:1 3 5 7 9<br>通过索引值遍历:1 3 5 7 9<br>for循环遍历:1 3 5 7 9<br>ArrayList contains 5 is: true<br>ArrayList is empty: true</p>
    </div>
  
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合(Collection)</title>
    <url>/Collection/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p><strong>什么是集合（Collection）？集合就是“由若干个确定的元素所构成的整体”。</strong><br>在Java中，如果一个Java对象可以在内部持有若干其他Java对象，并对外提供访问接口，我们把这种Java对象称为集合。<br><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265109905179456" target="_blank" rel="noopener">廖雪峰</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" target="_blank" rel="noopener">JavaGuide</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="集合概览">
          <a href="#集合概览" class="heading-link"><i class="fas fa-link"></i></a>集合概览</h1>
      <p>从下图可以看出，在 <code>Java</code> 中除了以<code>Map</code>结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。<br>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UN9vl9.png" alt="Collection">
      </p>

        <h1 id="Why-need-it">
          <a href="#Why-need-it" class="heading-link"><i class="fas fa-link"></i></a>Why need it?</h1>
      <p><strong>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，</strong>这个容器就是数组，但是，使用数组存储对象具有一定的弊端， 因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。 但是集合提高了数据存储的灵活性，<strong>Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据。</strong></p>

        <h1 id="集合框架">
          <a href="#集合框架" class="heading-link"><i class="fas fa-link"></i></a>集合框架</h1>
      
        <h2 id="List">
          <a href="#List" class="heading-link"><i class="fas fa-link"></i></a>List</h2>
      <ul>
<li><strong><code>Arraylist：</code></strong>Object[ ]数组</li>
<li><strong><code>Vector：</code></strong>Object[ ]数组</li>
<li><strong><code>LinkedList：</code></strong>双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>

        <h2 id="Set">
          <a href="#Set" class="heading-link"><i class="fas fa-link"></i></a>Set</h2>
      <ul>
<li><strong><code>HashSet</code>（无序，唯一）</strong>: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><strong><code>LinkedHashSet</code></strong>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。</li>
<li><strong><code>TreeSet</code>（有序，唯一）</strong>： 红黑树(自平衡的排序二叉树)</li>
</ul>

        <h2 id="Map">
          <a href="#Map" class="heading-link"><i class="fas fa-link"></i></a>Map</h2>
      <ul>
<li><code>HashMap</code>： JDK1.8 之前 <code>HashMap</code> 由数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 <code>HashMap</code> 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>

        <h1 id="List-1">
          <a href="#List-1" class="heading-link"><i class="fas fa-link"></i></a>List</h1>
      <p>在集合类中，<code>List</code>是最基础的一种集合：它是一种有序列表。</p>
<p><code>List</code>的行为和数组几乎完全相同：<code>List</code>内部按照放入元素的先后顺序存放，每个元素都可以通过索引确定自己的位置，<code>List</code>的索引和数组一样，从0开始。</p>
<p>数组和<code>List</code>类似，也是有序结构，如果我们使用数组，在添加和删除元素的时候，会非常不方便。例如，从一个已有的数组<code>{'A', 'B', 'C', 'D', 'E'}</code>中删除索引为<code>2</code>的元素：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNPt8e.png" alt="List">
      </p>
<p><strong>这个“删除”操作实际上是把<code>'C'</code>后面的元素依次往前挪一个位置，而“添加”操作实际上是把指定位置以后的元素都依次向后挪一个位置，腾出来的位置给新加的元素。这两种操作，用数组实现非常麻烦。</strong></p>
<p><strong>因此，在实际应用中，需要增删元素的有序列表，我们使用最多的是<code>ArrayList</code>。</strong>实际上，<code>ArrayList</code>在内部使用了数组来存储所有元素。例如:</p>
<ol>
<li>一个<code>ArrayList</code>拥有5个元素，实际数组大小为6（即有一个空位）：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNPza6.png" alt="ArrayList1">
      </li>
<li>当添加一个元素并指定索引到<code>ArrayList</code>时，<code>ArrayList</code>自动移动需要移动的元素：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNi1Mj.png" alt="ArrayList2">
      </li>
<li>然后，往内部指定索引的数组位置添加一个元素，然后把<code>size</code>加1：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNiJZq.png" alt="ArrayList3">
      </li>
<li>继续添加元素，但是数组已满，没有空闲位置的时候，<code>ArrayList</code>先创建一个更大的新数组，然后把旧数组的所有元素复制到新数组，紧接着用新数组取代旧数组：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNiWWD.png" alt="ArrayList4">
      </li>
<li>现在，新数组就有了空位，可以继续添加一个元素到数组末尾，同时<code>size</code>加1：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/14/UNFEpF.png" alt="ArrayList5">
      </li>
</ol>
<p>可见，<code>ArrayList</code>把添加和删除的操作封装起来，让我们操作<code>List</code>类似于操作数组，却不用关心内部元素如何移动。</p>

        <h1 id="Iterator-迭代器">
          <a href="#Iterator-迭代器" class="heading-link"><i class="fas fa-link"></i></a>Iterator 迭代器</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>{</span><br><span class="line">    <span class="comment">//集合中是否还有元素</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//获得集合中的下一个元素</span></span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p>
<p><strong>迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</strong></p>

        <h2 id="作用">
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a>作用</h2>
      <p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p>Java中的<code>Iterator</code>功能比较简单，并且只能单向移动：</p>
<p>　　(1) 使用方法<code>iterator()</code>要求容器返回一个<code>Iterator</code>。第一次调用<code>Iterator</code>的<code>next()</code>方法时，它返回序列的第一个元素。注意：<code>iterator()</code>方法是<code>java.lang.Iterable</code>接口,被<code>Collection</code>继承。</p>
<p>　　(2) 使用<code>next()</code>获得序列中的下一个元素。</p>
<p>　　(3) 使用<code>hasNext()</code>检查序列中是否还有元素。</p>
<p>　　(4) 使用<code>remove()</code>将迭代器新返回的元素删除。</p>
<p>　　<code>Iterator</code>是Java迭代器最简单的实现，为<code>List</code>设计的<code>ListIterator</code>具有更多的功能，它可以从两个方向遍历<code>List</code>，也可以从<code>List</code>中插入和删除元素。<span class="exturl"><a class="exturl__link" href="https://www.nowcoder.com/questionTerminal/8863f297b1fc4bbca6de95528b6051e1" target="_blank" rel="noopener">牛客网</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="使用">
          <a href="#使用" class="heading-link"><i class="fas fa-link"></i></a>使用</h2>
      <p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下迭代器 <code>Iterator</code> 的使用。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 泛型Map</span></span><br><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"Java"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"C++"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"PHP"</span>);</span><br><span class="line"><span class="comment">// 使用方法iterator()要求容器返回一个Iterator。</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line"><span class="comment">// while循环，调用hasNext()方法，直到序列中无元素</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) {</span><br><span class="line">  <span class="comment">// 调用next()方法，获取序列中的下一个元素</span></span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry = iterator.next();</span><br><span class="line">  <span class="comment">// 遍历输出每个元素的Key、Value</span></span><br><span class="line">  System.out.println(entry.getKey() + entry.getValue());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/Generic/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。<br><strong>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</strong><br><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102638843296" target="_blank" rel="noopener">廖雪峰</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>、<span class="exturl"><a class="exturl__link" href="https://www.runoob.com/java/java-generics.html" target="_blank" rel="noopener">菜鸟</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="什么是泛型？">
          <a href="#什么是泛型？" class="heading-link"><i class="fas fa-link"></i></a>什么是泛型？</h1>
      <p>在讲解什么是泛型之前，我们先观察Java标准库提供的<code>ArrayList</code>，它可以看作“可变长度”的数组，因为用起来比数组更方便。</p>
<p>实际上<code>ArrayList</code>内部就是一个<code>Object[]</code>数组，配合存储一个当前分配的长度，就可以充当“可变数组”：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Object[] array;<span class="comment">//是私有属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object e)</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果用上述<code>ArrayList</code>存储<code>String</code>类型，会有这么几个缺点：</p>
<ul>
<li>需要强制转型；</li>
<li>不方便，易出错。</li>
</ul>
<p>例如，代码必须这么写：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line"><span class="comment">// 获取到Object，必须强制转型为String:</span></span><br><span class="line">String first = (String) list.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">list.add(<span class="keyword">new</span> Integer(<span class="number">123</span>));</span><br><span class="line"><span class="comment">// ERROR: ClassCastException:</span></span><br><span class="line"><span class="comment">// 发生"误转型",Integer转为String</span></span><br><span class="line">String second = (String) list.get(<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></div></figure>

<p>为了解决这个问题，我们必须把<code>ArrayList</code>变成一种模板：<code>ArrayList&lt;T&gt;</code>，代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> T[] array;<span class="comment">// T可以是任意的class</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T e)</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{...}</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>{...}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这样一来，我们就实现了：编写一次模版，可以创建任意类型的<code>ArrayList</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建可以存储String的ArrayList:</span></span><br><span class="line">ArrayList&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Float的ArrayList:</span></span><br><span class="line">ArrayList&lt;Float&gt; floatList = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="comment">// 创建可以存储Person的ArrayList:</span></span><br><span class="line">ArrayList&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br></pre></td></tr></tbody></table></div></figure>

<p>因此，泛型就是定义一种模板，例如<code>ArrayList&lt;T&gt;</code>，然后在代码中为用到的类创建对应的<code>ArrayList&lt;类型&gt;</code>，由编译器针对类型作检查。</p>

        <h2 id="小结">
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <ol>
<li><p>泛型就是编写模板代码来适应任意类型；</p>
</li>
<li><p>泛型的好处是使用时不必对类型进行强制转换，它通过编译器对类型进行检查；</p>
</li>
<li><p>注意泛型的继承关系：可以把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>List&lt;Integer&gt;</code>（T不能变！），但不能把<code>ArrayList&lt;Integer&gt;</code>向上转型为<code>ArrayList&lt;Number&gt;</code>（T不能变成父类）。</p>
</li>
</ol>

        <h1 id="使用泛型">
          <a href="#使用泛型" class="heading-link"><i class="fas fa-link"></i></a>使用泛型</h1>
      <p>使用<code>ArrayList</code>时，如果不定义泛型类型时，泛型类型实际上就是<code>Object</code>。<br>当我们定义泛型类型<code>&lt;String&gt;</code>后，<code>List&lt;T&gt;</code>的泛型接口变为强类型<code>List&lt;String&gt;</code>：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 无编译器警告:</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"Hello"</span>);</span><br><span class="line">list.add(<span class="string">"World"</span>);</span><br><span class="line"><span class="comment">// 无强制转型:</span></span><br><span class="line">String first = list.get(<span class="number">0</span>);</span><br><span class="line">String second = list.get(<span class="number">1</span>);</span><br></pre></td></tr></tbody></table></div></figure>

<p>编译器如果能自动推断出泛型类型，就可以省略后面的泛型类型。例如，对于下面的代码：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;Number&gt;();</span><br></pre></td></tr></tbody></table></div></figure>
<p>编译器看到泛型类型<code>List&lt;Number&gt;</code>就可以自动推断出后面的<code>ArrayList&lt;T&gt;</code>的泛型类型必须是<code>ArrayList&lt;Number&gt;</code>，因此，可以把代码简写为：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 可以省略后面的Number，编译器可以自动推断泛型类型：</span></span><br><span class="line">List&lt;Number&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="泛型接口">
          <a href="#泛型接口" class="heading-link"><i class="fas fa-link"></i></a>泛型接口</h2>
      <p><strong>除了<code>ArrayList&lt;T&gt;</code>使用了泛型，还可以在接口中使用泛型。</strong>例如，<code>Arrays.sort(Object[])</code>可以对任意数组进行排序，但待排序的元素必须实现<code>Comparable&lt;T&gt;</code>这个泛型接口：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparable</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回-1: 当前实例比参数o小</span></span><br><span class="line"><span class="comment">     * 返回0: 当前实例与参数o相等</span></span><br><span class="line"><span class="comment">     * 返回1: 当前实例比参数o大</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(T o)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>可以直接对<code>String</code>数组进行排序：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String[] ss = <span class="keyword">new</span> String[] { <span class="string">"Orange"</span>, <span class="string">"Apple"</span>, <span class="string">"Pear"</span> };</span><br><span class="line">        Arrays.sort(ss);</span><br><span class="line">        System.out.println(Arrays.toString(ss));</span><br><span class="line">        <span class="comment">// [Apple, Orange, Pear]</span></span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这是因为<code>String</code>本身已经实现了<code>Comparable&lt;String&gt;</code>接口。如果换成我们自定义的<code>Person</code>类型就会得到<code>ClassCastException</code>，即无法将<code>Person</code>转型为<code>Comparable</code>。我们修改代码，让<code>Person</code>实现<code>Comparable&lt;T&gt;</code>接口：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// sort</span></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Person[] ps = <span class="keyword">new</span> Person[] {</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Bob"</span>, <span class="number">61</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="number">88</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">"Lily"</span>, <span class="number">75</span>),</span><br><span class="line">        };</span><br><span class="line">        Arrays.sort(ps);</span><br><span class="line">        System.out.println(Arrays.toString(ps));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt; </span>{</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> score;</span><br><span class="line">    Person(String name, <span class="keyword">int</span> score) {</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(other.name);</span><br><span class="line">        <span class="comment">// 可以正确实现按name进行排序。</span></span><br><span class="line">        <span class="comment">// [Alice,88, Bob,61, Lily,75]</span></span><br><span class="line">        <span class="comment">// 按score从高到低排序</span></span><br><span class="line">        <span class="comment">// return this.score &gt; other.score ? -1 : this.score == other.score ? 0 : 1;</span></span><br><span class="line">        <span class="comment">// [Alice,88, Lily,75, Bob,61]</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.score;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="通配符">
          <a href="#通配符" class="heading-link"><i class="fas fa-link"></i></a>通配符</h2>
      <ul>
<li>？ 表示不确定的 Java 类型</li>
<li>T (type) 表示具体的一个 Java 类型</li>
<li>K V (key value) 分别代表 Java 键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>

        <h2 id="小结-1">
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <ol>
<li><p>使用泛型时，把泛型参数<code>&lt;T&gt;</code>替换为需要的<code>class</code>类型，例如：<code>ArrayList&lt;String&gt;，ArrayList&lt;Number&gt;</code>等；</p>
</li>
<li><p>可以省略编译器能自动推断出的类型，例如：<code>List&lt;String&gt; list = new ArrayList&lt;&gt;();</code>；</p>
</li>
<li><p>不指定泛型参数类型时，编译器会给出警告，且只能将<code>&lt;T&gt;</code>视为<code>Object</code>类型；</p>
</li>
<li><p>可以在接口中定义泛型类型，实现此接口的类必须实现正确的泛型类型</p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解(Annotation)</title>
    <url>/Annotation/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p><strong>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。</strong><br>本文章将从使用注解、定义注解、处理注解三个角度讨论一下注解的特性。<br><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1265102413966176" target="_blank" rel="noopener">参考链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="使用注解">
          <a href="#使用注解" class="heading-link"><i class="fas fa-link"></i></a>使用注解</h1>
      <p>什么是注解？</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// this is a component:</span></span><br><span class="line"><span class="meta">@Resource</span>(<span class="string">"hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>{</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(@Param String name)</span> </span>{</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p><strong>注释与注解的不同？</strong><br>注释会被编译器直接忽略，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
    </div>
  

        <h2 id="注解的作用">
          <a href="#注解的作用" class="heading-link"><i class="fas fa-link"></i></a>注解的作用</h2>
      <p>从JVM的角度看，注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定。</p>
<p>Java的注解可以分为三类：</p>
<ol>
<li>由编译器使用的注解
    <div class="note-plugin info no-icon">
      
      <ul><li><code>@Override：</code>让编译器检查该方法是否正确地实现了覆写；</li><li><code>@SuppressWarnings：</code>告诉编译器忽略此处代码产生的警告。</li></ul><p>这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。</p>
    </div>
  </li>
<li>由工具处理<code>.class</code>文件使用的注解
    <div class="note-plugin info no-icon">
      
      <p>比如有些工具会在加载<code>class</code>的时候，对<code>class</code>做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
    </div>
  </li>
<li>在程序运行期能够读取的注解
    <div class="note-plugin info no-icon">
      
      <p>它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
    </div>
  

</li>
</ol>

        <h2 id="使用注解-1">
          <a href="#使用注解-1" class="heading-link"><i class="fas fa-link"></i></a>使用注解</h2>
      <p>定义一个注解时，还可以定义配置参数。配置参数可以包括：</p>
<ul>
<li>所有基本类型；</li>
<li>String；</li>
<li>枚举类型；</li>
<li>基本类型、String、Class以及枚举的数组。</li>
</ul>
<p>注解示例：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>{</span><br><span class="line">    <span class="meta">@Check</span>(min=<span class="number">0</span>, max=<span class="number">100</span>, value=<span class="number">55</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(value=<span class="number">99</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span>(<span class="number">99</span>) <span class="comment">// @Check(value=99)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p><code>@Check</code>就是一个注解。第一个<code>@Check(min=0, max=100, value=55)</code>明确定义了三个参数，第二个<code>@Check(value=99)</code>只定义了一个<code>value</code>参数，它实际上和<code>@Check(99</code>)是完全一样的。最后一个<code>@Check</code>表示所有参数都使用默认值。</p>
    </div>
  

        <h2 id="小结">
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <ul>
<li><p>注解（Annotation）是Java语言用于工具处理的标注：</p>
</li>
<li><p>注解可以配置参数，没有指定配置的参数使用默认值；</p>
</li>
<li><p>如果参数名称是value，且只有一个参数，那么可以省略参数名称。</p>
</li>
</ul>

        <h1 id="定义注解">
          <a href="#定义注解" class="heading-link"><i class="fas fa-link"></i></a>定义注解</h1>
      <p><strong>Java语言使用<code>@interface</code>语法来定义注解（Annotation）</strong>，它的格式如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）。最常用的参数应当命名为<code>value</code>。</p>

        <h2 id="元注解">
          <a href="#元注解" class="heading-link"><i class="fas fa-link"></i></a>元注解</h2>
      <p><strong>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。</strong><br>Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>

        <h3 id="Target">
          <a href="#Target" class="heading-link"><i class="fas fa-link"></i></a>@Target</h3>
      <p>最常用的元注解是<code>@Target</code>。<strong>使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</strong></p>
<ul>
<li>类或接口：<code>ElementType.TYPE</code>；</li>
<li>字段：<code>ElementType.FIELD</code>；</li>
<li>方法：<code>ElementType.METHOD</code>；</li>
<li>构造方法：<code>ElementType.CONSTRUCTOR</code>；</li>
<li>方法参数：<code>ElementType.PARAMETER</code>。</li>
</ul>
<p>Eg:</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="comment">// 定义注解@Report可用在方法上，我们必须添加一个@Target(ElementType.METHOD)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义注解@Report可用在方法或字段上，可以把@Target注解参数变为数组{ ElementType.METHOD, ElementType.FIELD }：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>({</span><br><span class="line">    ElementType.METHOD,</span><br><span class="line">    ElementType.FIELD</span><br><span class="line">})</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>实际上<code>@Target</code>定义的<code>value</code>是<code>ElementType[]</code>数组，只有一个元素时，可以省略数组的写法。</p>
    </div>
  

        <h3 id="Retention">
          <a href="#Retention" class="heading-link"><i class="fas fa-link"></i></a>@Retention</h3>
      <p><strong>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</strong></p>
<ul>
<li>仅编译期：<code>RetentionPolicy.SOURCE</code>；</li>
<li>仅class文件：<code>RetentionPolicy.CLASS</code>；</li>
<li>运行期：<code>RetentionPolicy.RUNTIME</code>。</li>
</ul>

    <div class="note-plugin success no-icon">
      
      <p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解：</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  

        <h2 id="如何定义Annotation">
          <a href="#如何定义Annotation" class="heading-link"><i class="fas fa-link"></i></a>如何定义Annotation</h2>
      <ol>
<li>用<code>@interface</code>定义注解：<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>添加参数、默认值：<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 把最常用的参数定义为value()，推荐所有参数都尽量设置默认值。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>用元注解配置注解：<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Report {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">level</span><span class="params">()</span> <span class="keyword">default</span> "info"</span>;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 其中，必须设置@Target和@Retention，@Retention一般设置为RUNTIME，因为我们自定义的注解通常要求在运行期读取。一般情况下，不必写@Inherited和@Repeatable。</span></span><br></pre></td></tr></tbody></table></div></figure>

</li>
</ol>

        <h2 id="小结-1">
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <ol>
<li><p>Java使用<code>@interface</code>定义注解：</p>
</li>
<li><p>可定义多个参数和默认值，核心参数使用<code>value</code>名称；</p>
</li>
<li><p>必须设置<code>@Target</code>来指定<code>Annotation</code>可以应用的范围；</p>
</li>
<li><p>应当设置<code>@Retention(RetentionPolicy.RUNTIME)</code>便于运行期读取该<code>Annotation</code>。</p>
</li>
</ol>

        <h1 id="处理注解">
          <a href="#处理注解" class="heading-link"><i class="fas fa-link"></i></a>处理注解</h1>
      <p>Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p>
<ul>
<li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li>
<li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到<code>class</code>的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>因此，我们只讨论如何读取<code>RUNTIME</code>类型的注解。</p>
<p>因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation</code>.<code>Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括：</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><code>Class.isAnnotationPresent(Class)</code></li>
<li><code>Field.isAnnotationPresent(Class)</code></li>
<li><code>Method.isAnnotationPresent(Class)</code></li>
<li><code>Constructor.isAnnotationPresent(Class)</code></li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 获取Person定义的@Report注解:</span></span><br><span class="line">Report report = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Report</span>.<span class="title">class</span>)</span>;</span><br><span class="line"><span class="keyword">int</span> type = report.type();</span><br><span class="line">String level = report.level();</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="使用注解-2">
          <a href="#使用注解-2" class="heading-link"><i class="fas fa-link"></i></a>使用注解</h2>
      <p>注解如何使用，完全由程序自己决定。例如，JUnit是一个测试框架，它会自动运行所有标记为<code>@Test</code>的方法。</p>
<p>我们来看一个<code>@Range</code>注解，我们希望用它来定义一个<code>String</code>字段的规则：字段长度满足<code>@Range</code>的参数定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Range {</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>在某个JavaBean中，我们可以使用该注解：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="meta">@Range</span>(min=<span class="number">1</span>, max=<span class="number">20</span>)</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Range</span>(max=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">public</span> String city;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p><strong>但是，定义了注解，本身对程序逻辑没有任何影响。我们必须自己编写代码来使用注解。</strong>这里，我们编写一个<code>Person</code>实例的检查方法，它可以检查<code>Person</code>实例的<code>String</code>字段长度是否满足<code>@Range</code>的定义：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(Person person)</span> <span class="keyword">throws</span> IllegalArgumentException, ReflectiveOperationException </span>{</span><br><span class="line">    <span class="comment">// 遍历所有Field:</span></span><br><span class="line">    <span class="keyword">for</span> (Field field : person.getClass().getFields()) {</span><br><span class="line">        <span class="comment">// 获取Field定义的@Range:</span></span><br><span class="line">        Range range = field.getAnnotation(Range<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 如果@Range存在:</span></span><br><span class="line">        <span class="keyword">if</span> (range != <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 获取Field的值:</span></span><br><span class="line">            Object value = field.get(person);</span><br><span class="line">            <span class="comment">// 如果值是String:</span></span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) {</span><br><span class="line">                String s = (String) value;</span><br><span class="line">                <span class="comment">// 判断值是否满足@Range的min/max:</span></span><br><span class="line">                <span class="keyword">if</span> (s.length() &lt; range.min() || s.length() &gt; range.max()) {</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid field: "</span> + field.getName());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>这样一来，我们通过<code>@Range</code>注解，配合<code>check()</code>方法，就可以完成<code>Person</code>实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射(Reflection)</title>
    <url>/Reflection/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>本篇文章会从Class类、访问字段等角度深度理解Java反射的特性。<br>同时文章基本上都是直接照搬廖雪峰的反射博客，他真的写的太好了，通俗易懂，我有种班门弄斧的感觉，甚至产生放弃写博客的念头。<br><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264799402020448" target="_blank" rel="noopener">廖雪峰博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="简述">
          <a href="#简述" class="heading-link"><i class="fas fa-link"></i></a>简述</h1>
      <p><strong>Java的反射是指程序在运行期间可以拿到一个对象的所有信息。</strong><br>正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">" "</span> + p.getLastName();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>怎么办？有童鞋会说：强制转型啊！</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>{</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">" "</span> + p.getLastName();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p>
<p><strong>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</strong></p>

        <h1 id="Class类">
          <a href="#Class类" class="heading-link"><i class="fas fa-link"></i></a>Class类</h1>
      <p><code>JVM</code>在执行过程中动态记载<code>class</code>类，<code>JVM</code>在第一次读取到一种<code>class</code>类型时，将其加载进内存中。<br>每加载一种<code>class</code>,<code>JVM</code>就为其创建一个<code>Class</code>类型的实例，并关联起来。</p>

    <div class="note-plugin success no-icon">
      
      <p>这里的<code>Class</code>类型是一个名叫<code>Class</code>的<code>class</code>:</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Class</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Class</span><span class="params">()</span> </span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  
<p>通过<code>Class</code>实例获取<code>class</code>信息的方法称为反射（Reflection）。<br>获取<code>Class</code>实例的方法有以下三种。</p>

        <h2 id="class方法">
          <a href="#class方法" class="heading-link"><i class="fas fa-link"></i></a>class方法</h2>
      <p>直接通过一个<code>class</code>的静态变量<code>class</code>获取：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">Class cls = String<span class="class">.<span class="keyword">class</span></span>;</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="getClass-方法">
          <a href="#getClass-方法" class="heading-link"><i class="fas fa-link"></i></a>getClass()方法</h2>
      <p>如果我们有一个实例变量，可以通过该实例变量提供的<code>getClass()</code>方法获取：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls = s.getClass();</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="Class-forName-方法">
          <a href="#Class-forName-方法" class="heading-link"><i class="fas fa-link"></i></a>Class.forName()方法</h2>
      <p>如果知道一个<code>class</code>的完整类名，可以通过静态方法<code>Class.forName()</code>获取：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">Class cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>因为<code>Class</code>实例在<code>JVM</code>中是唯一的，所以，上述方法获取的<code>Class</code>实例是同一个实例。可以用<code>==</code>比较两个<code>Class</code>实例：</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">Class cls1 = String<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">String s = <span class="string">"Hello"</span>;</span><br><span class="line">Class cls2 = s.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> sameClass = cls1 == cls2; <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  

        <h1 id="访问字段">
          <a href="#访问字段" class="heading-link"><i class="fas fa-link"></i></a>访问字段</h1>
      <p>对任意的一个<code>Object</code>实例，只要我们获取了它的<code>Class</code>，就可以获取它的一切信息。<br>我们先看看如何通过<code>Class</code>实例获取字段信息。<code>Class</code>类提供了以下几个方法来获取字段：</p>
<ul>
<li><strong><code>Field getField(name)：</code></strong>根据字段名获取某个public的field（包括父类）
    <div class="note-plugin success no-icon">
      
      <p>即获取name所对应的Public的字段</p>
    </div>
  </li>
<li><strong><code>Field getDeclaredField(name)：</code></strong>根据字段名获取当前类的某个field（不包括父类）
    <div class="note-plugin success no-icon">
      
      <p>即获取name所对应的字段，可以是Public，也可以是Private</p>
    </div>
  </li>
<li><strong><code>Field[] getFields()：</code></strong>获取所有public的field（包括父类）</li>
<li><strong><code>Field[] getDeclaredFields()：</code></strong>获取当前类的所有field（不包括父类）</li>
</ul>
<p>实例代码：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 上面提到第一种的class方法获取Class实例</span></span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public字段"score":</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">"score"</span>));</span><br><span class="line">        <span class="comment">// 获取继承的public字段"name":</span></span><br><span class="line">        System.out.println(stdClass.getField(<span class="string">"name"</span>));</span><br><span class="line">        <span class="comment">// 获取private字段"grade":</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredField(<span class="string">"grade"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> grade;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>字段、继承的<code>public</code>字段以及<code>private</code>字段，打印出的<code>Field</code>类似：</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.score</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.name</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.grade</span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  
<p>一个<code>Field</code>对象包含了一个字段的所有信息：</p>
<ul>
<li><code>getName()：</code>返回字段名称，例如，<code>"name"</code>；</li>
<li><code>getType()：</code>返回字段类型，也是一个<code>Class</code>实例，例如，<code>String.class</code>；</li>
<li><code>getModifiers()：</code>返回字段的修饰符，它是一个<code>int</code>，不同的<code>bit</code>表示不同的含义。</li>
</ul>
<p>以<code>String</code>类的<code>value</code>字段为例，它的定义是：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们用反射获取该字段的信息，代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">Field f = String.class.getDeclaredField("value");</span><br><span class="line">f.getName(); <span class="comment">// "value"</span></span><br><span class="line">f.getType(); <span class="comment">// class [B 表示byte[]类型</span></span><br><span class="line"><span class="keyword">int</span> m = f.getModifiers();</span><br><span class="line">Modifier.isFinal(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isPublic(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isProtected(m); <span class="comment">// false</span></span><br><span class="line">Modifier.isPrivate(m); <span class="comment">// true</span></span><br><span class="line">Modifier.isStatic(m); <span class="comment">// false</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="获取字段值">
          <a href="#获取字段值" class="heading-link"><i class="fas fa-link"></i></a>获取字段值</h2>
      <p>利用反射拿到字段的一个<code>Field</code>实例只是第一步，我们还可以拿到一个实例对应的该字段的值。</p>
<p>例如，对于一个<code>Person</code>实例，我们可以先拿到<code>name</code>字段对应的<code>Field</code>，再获取这个实例的<code>name</code>字段的值：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 上面提到的第二种方法getClass()获取Class实例</span></span><br><span class="line">        Object p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        Object value = f.get(p);</span><br><span class="line">        System.out.println(value); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上述代码先获取<code>Class</code>实例，再获取<code>Field</code>实例，然后，用<code>Field.get(Object)</code>获取指定实例的指定字段的值。</p>
<p>运行代码，如果不出意外，会得到一个<code>IllegalAccessException</code>，这是因为<code>name</code>被定义为一个<code>private</code>字段，正常情况下，<code>Main</code>类无法访问<code>Person</code>类的<code>private</code>字段。要修复错误，可以将<code>private</code>改为<code>public</code>，或者，在调用<code>Object value = f.get(p);</code>前，先写一句：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">f.setAccessible(<span class="keyword">true</span>);</span><br></pre></td></tr></tbody></table></div></figure>
<p>调用<code>Field.setAccessible(true)</code>的意思是，别管这个字段是不是<code>public</code>，一律允许访问。</p>
<p>可以试着加上上述语句，再运行代码，就可以打印出<code>private</code>字段的值。</p>

    <div class="note-plugin success no-icon">
      
      <p><strong>有童鞋会问：如果使用反射可以获取<code>private</code>字段的值，那么类的封装还有什么意义？</strong></p><p>答案是正常情况下，我们总是通过<code>p.name</code>来访问<code>Person</code>的<code>name</code>字段，编译器会根据<code>public</code>、<code>protected</code>和<code>private</code>决定是否允许访问字段，这样就达到了数据封装的目的。</p><p>而反射是一种非常规的用法，使用反射，首先代码非常繁琐，其次，它更多地是给工具或者底层框架来使用，目的是在不知道目标实例任何信息的情况下，获取特定字段的值。</p><p>此外，<code>setAccessible(true)</code>可能会失败。如果<code>JVM</code>运行期存在<code>SecurityManager</code>，那么它会根据规则进行检查，有可能阻止<code>setAccessible(true)</code>。例如，某个<code>SecurityManager</code>可能不允许对<code>java</code>和<code>javax</code>开头的<code>package</code>的类调用<code>setAccessible(true)</code>，这样可以保证<code>JVM</code>核心库的安全。</p>
    </div>
  

        <h2 id="设置字段值">
          <a href="#设置字段值" class="heading-link"><i class="fas fa-link"></i></a>设置字段值</h2>
      <p>通过<code>Field</code>实例既然可以获取到指定实例的字段值，自然也可以设置字段的值。</p>
<p>设置字段值是通过<code>Field.set(Object, Object)</code>实现的，<strong>其中第一个<code>Object</code>参数是指定的实例，第二个<code>Object</code>参数是待修改的值。</strong>示例代码如下：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// reflection</span></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 创建Person对象实例</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Xiao Ming"</span>);</span><br><span class="line">        <span class="comment">// 获取实例name</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Ming"</span></span><br><span class="line">        <span class="comment">// 通过getClass()获取Class实例</span></span><br><span class="line">        Class c = p.getClass();</span><br><span class="line">        <span class="comment">// 通过getDeclaredField(name)获取Field实例</span></span><br><span class="line">        Field f = c.getDeclaredField(<span class="string">"name"</span>);</span><br><span class="line">        <span class="comment">// 对于private字段，调用setAccessible()来允许访问</span></span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 使用Field.set(obj,obj)来修改实例的字段值</span></span><br><span class="line">        f.set(p, <span class="string">"Xiao Hong"</span>);</span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// "Xiao Hong"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin info no-icon">
      
      <p>运行上述代码，打印的<code>name</code>字段从<code>Xiao Ming</code>变成了<code>Xiao Hong</code>，说明通过反射可以直接修改字段的值。</p><p>同样的，修改非<code>public</code>字段，需要首先调用<code>setAccessible(true)</code>。</p>
    </div>
  


        <h2 id="小结">
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <ol>
<li><code>Java</code>的反射API提供的<code>Field</code>类封装了字段的所有信息：</li>
<li>通过<code>Class</code>实例的方法可以获取<code>Field</code>实例：<code>getField()</code>，<code>getFields()</code>，<code>getDeclaredField()</code>，<code>getDeclaredFields()</code>；</li>
<li>通过<code>Field</code>实例可以获取字段信息：<code>getName()</code>，<code>getType()</code>，<code>getModifiers()</code>；</li>
<li>通过<code>Field</code>实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用<code>setAccessible(true)</code>来访问非<code>public</code>字段。</li>
<li>通过反射读写字段是一种非常规方法，它会破坏对象的封装。</li>
</ol>

        <h1 id="调用方法">
          <a href="#调用方法" class="heading-link"><i class="fas fa-link"></i></a>调用方法</h1>
      <p>我们已经能通过<code>Class</code>实例获取所有<code>Field</code>对象，同样的，可以通过<code>Class</code>实例获取所有<code>Method</code>信息。<code>Class</code>类提供了以下几个方法来获取<code>Method：</code></p>
<ul>
<li><strong><code>Method getMethod(name, Class...)：</code></strong>获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><strong><code>Method getDeclaredMethod(name, Class...)：</code></strong>获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><strong><code>Method[] getMethods()：</code></strong>获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><strong><code>Method[] getDeclaredMethods()：</code></strong>获取当前类的所有<code>Method</code>（不包括父类）</li>
</ul>
<p>示例代码：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Class stdClass = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取public方法getScore，参数为String:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getScore"</span>, String<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="comment">// 获取继承的public方法getName，无参数:</span></span><br><span class="line">        System.out.println(stdClass.getMethod(<span class="string">"getName"</span>));</span><br><span class="line">        <span class="comment">// 获取private方法getGrade，参数为int:</span></span><br><span class="line">        System.out.println(stdClass.getDeclaredMethod(<span class="string">"getGrade"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">(String type)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">99</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getGrade</span><span class="params">(<span class="keyword">int</span> year)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin info no-icon">
      
      <p>上述代码首先获取<code>Student</code>的<code>Class</code>实例，然后，分别获取<code>public</code>方法、继承的<code>public</code>方法以及<code>private</code>方法，打印出的<code>Method</code>类似：</p><figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> Student.getScore(java.lang.String)</span><br><span class="line"><span class="keyword">public</span> java.lang.String Person.getName()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> Student.getGrade(<span class="keyword">int</span>)</span><br></pre></td></tr></tbody></table></div></figure>
    </div>
  
<p>一个<code>Method</code>对象包含一个方法的所有信息：</p>
<ul>
<li><code>getName()：</code>返回方法名称，例如：<code>"getScore"</code>；</li>
<li><code>getReturnType()：</code>返回方法返回值类型，也是一个<code>Class</code>实例，例如：String.class；</li>
<li><code>getParameterTypes()：</code>返回方法的参数类型，是一个<code>Class</code>数组，例如：<code>{String.class, int.class}</code>；</li>
<li><code>getModifiers()：</code>返回方法的修饰符，它是一个<code>int</code>，不同的<code>bit</code>表示不同的含义。</li>
</ul>

        <h2 id="小结-1">
          <a href="#小结-1" class="heading-link"><i class="fas fa-link"></i></a>小结</h2>
      <p>Java的反射API提供的Method对象封装了方法的所有信息：</p>
<ol>
<li>通过<code>Class</code>实例的方法可以获取<code>Method</code>实例：<code>getMethod()</code>，<code>getMethods()</code>，<code>getDeclaredMethod()</code>，<code>getDeclaredMethods()</code>；</li>
<li>通过<code>Method</code>实例可以获取方法信息：<code>getName()</code>，<code>getReturnType()</code>，<code>getParameterTypes()</code>，<code>getModifiers()</code>；</li>
<li>通过<code>Method</code>实例可以调用某个对象的方法：<code>Object invoke(Object instance, Object... parameters)</code>；</li>
<li>通过设置<code>setAccessible(true)</code>来访问非<code>public</code>方法；</li>
<li>通过反射调用方法时，仍然遵循多态原则。</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>Java枚举(enum)</title>
    <url>/enumerate/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>上学期上Java课时都没有听说过枚举的概念，这次偶然在JavaGuide博客中看到了，就想写一些枚举相关知识。本篇文章会较为深入地讲解一下枚举的强大功能。<br>写这边博客的时候，又发现了廖雪峰的Java教程也写的很好，可以配套食用。<br><span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95" target="_blank" rel="noopener">JavaGuide</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424" target="_blank" rel="noopener">廖雪峰</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="简介">
          <a href="#简介" class="heading-link"><i class="fas fa-link"></i></a>简介</h1>
      <p><strong>Java枚举其实是指一种特殊的类，它一般用来表示一组常量。</strong></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PizzaStatus {</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY, </span><br><span class="line">    DELIVERED; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>上面的代码为了避免定义常量，将和Pizza有关的常量都放入了枚举类中。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">System.out.println(PizzaStatus.ORDERED.name());<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED);<span class="comment">//ORDERED</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());<span class="comment">//class java.lang.String</span></span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());<span class="comment">//class shuang.kou.enumdemo.enumtest.PizzaStatus</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="Why-need-it">
          <a href="#Why-need-it" class="heading-link"><i class="fas fa-link"></i></a>Why need it?</h1>
      <p>在Java中我们想要定义常量，完全可以用<code>static final</code>来定义,比如我们想要定义周一到周日这几个常量。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekday</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MON = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THU = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRI = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAT = <span class="number">6</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>但是当用这些常量来表示一组枚举值时，会产生一个严重的问题，编译器无法检查每个值的合理性。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (weekday == <span class="number">6</span> || weekday == <span class="number">7</span>) {</span><br><span class="line">    <span class="keyword">if</span> (tasks == Weekday.MON) {</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>在上面的代码中，编译和运行都不会报错，但是存在两个问题：</p><ol><li><code>weekday</code>定义的常量范围为<code>0~6</code>，但此处值为<code>7</code>，编译器无法检查不在枚举中的<code>int</code>值；</li><li>定义的常量仍可以和其他变量比较，违背了最初的意愿</li></ol>
    </div>
  
<p><strong>因此以枚举方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong><br><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1260473188087424" target="_blank" rel="noopener">廖雪峰枚举</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="比较">
          <a href="#比较" class="heading-link"><i class="fas fa-link"></i></a>==比较</h1>
      <p>使用<code>enum</code>定义的枚举类是一种引用类型。<br>而引用类型比较，要使用<code>equals()</code>方法，如果使用<code>==</code>比较，它比较的是两个引用类型的变量是否是同一个对象。因此，引用类型比较，要始终使用<code>equals()</code>方法，但<code>enum</code>类型可以除外。<br>引用类型与基本数据类型分类见下表，<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/truelove12358/article/details/60143499" target="_blank" rel="noopener">图片来源</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/11/UlA35j.png" alt="UlA35j.png">
      <br>这是因为<code>enum</code>类型的每个变量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较。</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (day == Weekday.FRI) { <span class="comment">// ok!</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (day.equals(Weekday.SUN)) { <span class="comment">// ok, but more code!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="Switch语句">
          <a href="#Switch语句" class="heading-link"><i class="fas fa-link"></i></a>Switch语句</h1>
      <figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDeliveryTimeInDays</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">switch</span> (status) {</span><br><span class="line">        <span class="keyword">case</span> ORDERED: <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">case</span> READY: <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> DELIVERED: <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="enum类型">
          <a href="#enum类型" class="heading-link"><i class="fas fa-link"></i></a>enum类型</h1>
      <p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>有什么区别？<br>答案是没有任何区别。<code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p>
<ul>
<li>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</li>
<li>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</li>
<li>定义的每个实例都是引用类型的唯一实例；</li>
<li>可以将<code>enum</code>类型用于<code>switch</code>语句。(如上所示)</li>
</ul>
<p>我们可以定义一个<code>Color</code>枚举类:</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color {</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>通过编译器编译出的<code>class</code>大概就是这样：</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>{ <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">()</span> </span>{}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p>
<p>因为<code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例。</p>

        <h1 id="常用方法">
          <a href="#常用方法" class="heading-link"><i class="fas fa-link"></i></a>常用方法</h1>
      
        <h2 id="name">
          <a href="#name" class="heading-link"><i class="fas fa-link"></i></a>name()</h2>
      <p>返回常量名</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">String s = Weekday.SUN.name(); <span class="comment">// "SUN"</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="ordinal">
          <a href="#ordinal" class="heading-link"><i class="fas fa-link"></i></a>ordinal()</h2>
      <p>返回定义的常量的顺序，从0开始计数</p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></tbody></table></div></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>枚举</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/Java-Object-oriented/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>面向对象是Java语言的核心，涉及的知识点非常多，这篇文章主要讲解三大特征(封装、继承、多态)、接口、异常等特性。其余部分会在之后单独地另写几篇文章。<br>参考资料：<span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86?id=_2-java-%e9%9d%a2%e5%90%91%e5%af%b9%e8%b1%a1" target="_blank" rel="noopener">JavaGuide</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="三大特征">
          <a href="#三大特征" class="heading-link"><i class="fas fa-link"></i></a>三大特征</h1>
      
        <h2 id="封装">
          <a href="#封装" class="heading-link"><i class="fas fa-link"></i></a>封装</h2>
      <p><strong>封装顾名思义，就是把一个对象的状态信息(也就是属性)隐藏在对象内部，不允许外部对象直接访问对象的内部信息，但是会提供一些可以被外界访问的方法来操作属性。</strong><br>简单的说，类会提供变量和方法供外界访问使用，就叫封装。</p>

        <h2 id="继承">
          <a href="#继承" class="heading-link"><i class="fas fa-link"></i></a>继承</h2>
      <p><strong>继承，就是因为不同的类对象之间，有这个很多的共同点，因此可以创建一个具有共同点的父类，子类再继承父类。</strong></p>
<p>例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。</p>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，<strong>但不能选择性地继承父类。</strong>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ul>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），<strong>但是父类中的私有属性和方法子类是无法访问，只是拥有。</strong></li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ul>

        <h2 id="多态">
          <a href="#多态" class="heading-link"><i class="fas fa-link"></i></a>多态</h2>
      <p>多态，即表示一个对象具有多种的状态。具体表现为父类的引用指向子类的实例。简单来讲，<strong>多态就是同一个接口，使用不同的实例而执行不同操作。</strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/scyq/p/11667881.html" target="_blank" rel="noopener">多态资料</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建Animal类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>{</span><br><span class="line">	<span class="keyword">protected</span> String name;	<span class="comment">// 可被子类访问的name</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">this</span>.name = <span class="string">"Animal"</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 封装</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>{</span><br><span class="line">	Cat(){</span><br><span class="line">		name = <span class="string">"Cat"</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>{</span><br><span class="line">	Dog(){</span><br><span class="line">		name = <span class="string">"Dog"</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>{</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">board</span><span class="params">(Animal s)</span> </span>{		</span><br><span class="line">		System.out.println(s.getName());</span><br><span class="line">	}</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">		Animal animal = <span class="keyword">new</span> Animal();	<span class="comment">//创建Animal对象</span></span><br><span class="line">		Animal cat = <span class="keyword">new</span> Cat();			<span class="comment">//创建Cat对象</span></span><br><span class="line">		Animal dog = <span class="keyword">new</span> Dog();			<span class="comment">//创建Dog对象</span></span><br><span class="line">		<span class="comment">// 三块广告牌</span></span><br><span class="line">		board(animal);</span><br><span class="line">		board(cat);</span><br><span class="line">		board(dog);</span><br><span class="line">		</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// output</span></span><br><span class="line"><span class="comment">// Animal</span></span><br><span class="line"><span class="comment">// Cat</span></span><br><span class="line"><span class="comment">// Dog</span></span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="接口">
          <a href="#接口" class="heading-link"><i class="fas fa-link"></i></a>接口</h1>
      <p>在软件工程中，接口泛指供别人调用的方法或函数。在接口中，所有方法都必须是抽象方法，不能有实现。当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</p>

    <div class="note-plugin success no-icon">
      
      <p>Java的类是不允许多继承的，而C++中是允许的，但是接口是允许多继承的。</p>
    </div>
  
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Animal</span> </span>{</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MammalInt</span> <span class="keyword">implements</span> <span class="title">Animal</span></span>{</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>{</span><br><span class="line">      System.out.println(<span class="string">"Mammal eats"</span>);</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">travel</span><span class="params">()</span></span>{</span><br><span class="line">      System.out.println(<span class="string">"Mammal travels"</span>);</span><br><span class="line">   } </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">noOfLegs</span><span class="params">()</span></span>{</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>{</span><br><span class="line">      MammalInt m = <span class="keyword">new</span> MammalInt();</span><br><span class="line">      m.eat();</span><br><span class="line">      m.travel();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="异常">
          <a href="#异常" class="heading-link"><i class="fas fa-link"></i></a>异常</h1>
      
        <h2 id="异常的层次分类">
          <a href="#异常的层次分类" class="heading-link"><i class="fas fa-link"></i></a>异常的层次分类</h2>
      <p>Java中异常的层次分类见下图，<span class="exturl"><a class="exturl__link" href="https://simplesnippets.tech/exception-handling-in-java-part-1/" target="_blank" rel="noopener">图片来源</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://imgkr.cn-bj.ufileos.com/199703ce-a1b6-4968-9eb0-161a8217507e.png" alt="异常层次分类">
      </p>

        <h2 id="Throwable类常用方法">
          <a href="#Throwable类常用方法" class="heading-link"><i class="fas fa-link"></i></a>Throwable类常用方法</h2>
      <ul>
<li><strong><code>public string getMessage():</code></strong>返回异常发生时的简要描述</li>
<li><strong><code>public string toString():</code></strong>返回异常发生时的详细信息</li>
<li><strong><code>public string getLocalizedMessage():</code></strong>返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace():</code></strong>在控制台上打印 <code>Throwable</code>对象封装的异常信息</li>
</ul>

        <h2 id="try-catch-finally">
          <a href="#try-catch-finally" class="heading-link"><i class="fas fa-link"></i></a>try-catch-finally</h2>
      <ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        String str = <span class="keyword">new</span> Main().openFile();</span><br><span class="line">        System.out.println(str);</span><br><span class="line">         </span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">openFile</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            FileInputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"d:/a.txt"</span>);</span><br><span class="line">            <span class="keyword">int</span> ch = inputStream.read();</span><br><span class="line">            System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"step1"</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (FileNotFoundException e) {</span><br><span class="line">            System.out.println(<span class="string">"file not found"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"step2"</span>;</span><br><span class="line">        }<span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            System.out.println(<span class="string">"io exception"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"step3"</span>;</span><br><span class="line">        }<span class="keyword">finally</span>{</span><br><span class="line">            System.out.println(<span class="string">"finally block"</span>);</span><br><span class="line">            <span class="comment">//return "finally";</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

    <div class="note-plugin success no-icon">
      
      <p>执行结果：<br>file not found<br>finally block<br>step2</p>
    </div>
  
<p>可以看出，在try块中发生FileNotFoundException之后，就跳到第一个catch块，打印”file not found”信息，并将”step2”赋值给返回值，然后执行finally块，最后将返回值返回。<br>从这个例子说明，无论try块或者catch块中是否包含return语句，都会执行finally块。<br><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/dolphin0520/p/3769804.html" target="_blank" rel="noopener">代码来源</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/java-basic-grammer/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>最近在JavaGuide博客里面兜兜转转了几天，一边等华为的实训消息，一边随便看点Java后端开发的知识。但是这一周总感觉看了就忘，而且光看也很容易走神发呆，要不然就是去打王者啥的。决定还要按照直接写的Java后端学习路线一点点走下去，一篇篇写博客敦促自己，上个月的时候写了一些JVM相关的文章，现在把之前鸽的Java语言基础先补上。</p>
<p>这边Java基础语言主要参照<span class="exturl"><a class="exturl__link" href="https://www.runoob.com/java/java-basic-syntax.html" target="_blank" rel="noopener">菜鸟教程</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>和<span class="exturl"><a class="exturl__link" href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super?id=final-%e5%85%b3%e9%94%ae%e5%ad%97" target="_blank" rel="noopener">JavaGuide</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>完成的，<strong>计划在今明两天完成Java语言基础系列博客。</strong></p>
<a id="more"></a>

        <h1 id="基础知识">
          <a href="#基础知识" class="heading-link"><i class="fas fa-link"></i></a>基础知识</h1>
      
        <h2 id="四要素">
          <a href="#四要素" class="heading-link"><i class="fas fa-link"></i></a>四要素</h2>
      <p>任何一个Java程序都可以认为是一系列对象的集合，而对象之间通过彼此调用方法来协调工作。</p>
<ul>
<li><strong>对象：</strong>对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>
<li><strong>类：</strong>类是一个模板，它描述一类对象的行为和状态</li>
<li><strong>方法：</strong>方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>
<li><strong>实例变量：</strong>每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>
</ul>

        <h2 id="基础语法">
          <a href="#基础语法" class="heading-link"><i class="fas fa-link"></i></a>基础语法</h2>
      <ul>
<li><strong>大小写敏感：</strong>Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名：</strong>对于所有的类来说，<strong>类名的首字母应该大写</strong>。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</li>
<li><strong>方法名：</strong>所有的方法名都应该以<strong>小写字母开头</strong>。如果方法名含有若干单词，则后面的每个单词首字母大写。<blockquote>
<p>我自己方法名这块之前好像总是大写，记下了</p>
</blockquote>
</li>
<li><strong>源文件名：</strong>源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 .java。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口：</strong>所有的 Java 程序由 <strong>public static void main(String[] args) *</strong>方法开始执行。
    <div class="note-plugin success no-icon">
      
      <p>在Java小程序中，applet小程序没有main()方法，是调用init()或者run()方法来启动。</p>
    </div>
  

        <h2 id="Java标识符">
          <a href="#Java标识符" class="heading-link"><i class="fas fa-link"></i></a>Java标识符</h2>
      </li>
<li>类名、变量名以及方法名都被称为标识符。</li>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary
        <h1 id="进阶知识">
          <a href="#进阶知识" class="heading-link"><i class="fas fa-link"></i></a>进阶知识</h1>
      
        <h2 id="Java修饰符">
          <a href="#Java修饰符" class="heading-link"><i class="fas fa-link"></i></a>Java修饰符</h2>
      Java可以使用修饰符来修饰类中方法和属性。</li>
<li><strong>访问控制修饰符 :</strong>default, public , protected, private<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/10/UKgGhF.png" alt="UKgGhF.png">
      </li>
<li><strong>非访问控制修饰符 :</strong> final, abstract, static, synchronized</li>
</ul>

        <h3 id="Final修饰符">
          <a href="#Final修饰符" class="heading-link"><i class="fas fa-link"></i></a>Final修饰符</h3>
      <p>Final修饰符可以用来修饰类、方法和变量。</p>
<ol>
<li><strong>类：</strong>final修饰的类不能被继承，final类中的所有成员方法都会被隐式的指定为final方法；</li>
<li><strong>方法：</strong>final修饰的方法不能被重写；</li>
<li><strong>变量：</strong>final修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。</li>
</ol>

    <div class="note-plugin info no-icon">
      
      <p>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。类中所有的private方法都隐式地指定为final。</p>
    </div>
  


        <h3 id="Abstract修饰符">
          <a href="#Abstract修饰符" class="heading-link"><i class="fas fa-link"></i></a>Abstract修饰符</h3>
      <ol>
<li><strong>抽象类：</strong> </li>
</ol>
<ul>
<li>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</li>
<li>一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</li>
<li>抽象类可以包含抽象方法和非抽象方法。</li>
</ul>
<ol start="2">
<li><strong>抽象方法：</strong></li>
</ol>
<ul>
<li>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。抽象方法不能被声明成final和strict。</li>
<li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>
<li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</li>
</ul>

        <h3 id="Static修饰符">
          <a href="#Static修饰符" class="heading-link"><i class="fas fa-link"></i></a>Static修饰符</h3>
      <ol>
<li><strong>修饰成员变量和成员方法:</strong><br>被 static 修饰的成员方法属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。<br>被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。<br>调用格式：<code>类名.静态变量名 类名.静态方法名()</code></li>
<li><strong>静态代码块:</strong> 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li>
<li><strong>静态内部类(static修饰类的话只能修饰内部类):</strong> 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li>
<li><strong>静态导包(用来导入类中的静态资源，1.5之后的新特性):</strong> 格式为：<code>import static</code>这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li>
</ol>

        <h3 id="Synchronized修饰符">
          <a href="#Synchronized修饰符" class="heading-link"><i class="fas fa-link"></i></a>Synchronized修饰符</h3>
      <p>Synchronized关键字声明的方法同一时间只能被一个线程访问。Synchronized修饰符可以应用于四个访问修饰符。</p>

        <h2 id="Java变量">
          <a href="#Java变量" class="heading-link"><i class="fas fa-link"></i></a>Java变量</h2>
      <ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。</li>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li>
<li>局部变量：类的方法中的变量。</li>
</ul>
<figure class="highlight java"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks=<span class="number">0</span>;    <span class="comment">// 类变量</span></span><br><span class="line">    String str=<span class="string">"hello world"</span>;  <span class="comment">// 实例变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> i =<span class="number">0</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>Java语言基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>基础语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Tightly-Secure</title>
    <url>/Tightly-Secure/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/03/NOdOj1.png" alt="NOdOj1.png">
      <br>本文是一篇关于紧安全的数字签名及身份验证的密钥交换的论文分析。<br><span class="exturl"><a class="exturl__link" href="http://www.nds.ruhr-uni-bochum.de/media/nds/veroeffentlichungen/2014/12/27/main.pdf" target="_blank" rel="noopener">Practical and Tightly-Secure Digital Signatures and Authenticated Key Exchange</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>密码学</tag>
        <tag>Tightly-Secure</tag>
      </tags>
  </entry>
  <entry>
    <title>密码学的安全性</title>
    <url>/safety/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>这次做综合课设的时候，队员发了一篇关于安全性的文章，我看完觉得有一种豁然开朗的感觉。这篇文章用非常通俗的语言，总结了密码系统的安全性，把我在密码学课上零散的知识给整合了起来。我在这边的文章的基础上，做了一些简单的调整修改。<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/xdyixia/p/11610091.html" target="_blank" rel="noopener">原文链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/NqodIJ.png" alt="NqodIJ.png">
      </p>
<a id="more"></a>


        <h1 id="密码系统安全性的评估方法">
          <a href="#密码系统安全性的评估方法" class="heading-link"><i class="fas fa-link"></i></a>密码系统安全性的评估方法</h1>
      
        <h2 id="无条件安全性">
          <a href="#无条件安全性" class="heading-link"><i class="fas fa-link"></i></a>无条件安全性</h2>
      <p>这种评价方法考虑的是假定攻击者拥有无限的计算资源，但仍然无法破译该密码系统。</p>

        <h2 id="计算安全性">
          <a href="#计算安全性" class="heading-link"><i class="fas fa-link"></i></a>计算安全性</h2>
      <p>这种方法是指使用目前最好的方法攻破它所需要的计算远远超出攻击者的计算资源水平，则可以定义这个密码体制是安全的。</p>

        <h2 id="可证明安全性">
          <a href="#可证明安全性" class="heading-link"><i class="fas fa-link"></i></a>可证明安全性</h2>
      <p>这种方法是将密码系统的安全性归结为某个经过深入研究的数学难题（如大整数素因子分解、计算离散对数等），<strong>数学难题被证明求解困难</strong>。</p>

    <div class="note-plugin info no-icon">
      
      <p>这种评估方法存在的问题是它只说明了这个密码方法的安全性与某个困难问题相关，没有完全证明问题本身的安全性，并给出它们的等价性证明。</p>
    </div>
  

        <h1 id="实际安全性">
          <a href="#实际安全性" class="heading-link"><i class="fas fa-link"></i></a>实际安全性</h1>
      <p>对于实际应用中的密码系统而言，由于至少存在一种破译方法，即<strong>强力攻击法</strong>，因此<em>都不能满足无条件安全性，只提供计算安全性</em>。密码系统要达到实际安全性，就要满足以下准则：</p>
<ol>
<li>破译该密码系统的实际计算量（包括计算时间或费用）十分巨大，以致于在实际上是无法实现的。</li>
<li>破译该密码系统所需要的计算时间超过被加密信息有用的生命周期。
    <div class="note-plugin success no-icon">
      
      <p>例如，战争中发起战斗攻击的作战命令只需要在战斗打响前需要保密；<br>重要新闻消息在公开报道前需要保密的时间往往也只有几个小时。</p>
    </div>
  </li>
<li>破译该密码系统的费用超过被加密信息本身的价值。</li>
</ol>
<p>如果一个密码系统能够满足以上准则之一，就可以认为是满足实际安全性的。</p>

        <h1 id="可证明安全性-1">
          <a href="#可证明安全性-1" class="heading-link"><i class="fas fa-link"></i></a>可证明安全性</h1>
      
        <h2 id="可证明安全性体系的三大要素">
          <a href="#可证明安全性体系的三大要素" class="heading-link"><i class="fas fa-link"></i></a>可证明安全性体系的三大要素</h2>
      <p>在可证明安全体系中，有三大要素：<strong>安全模型，安全性定义和困难性问题</strong>。<br>安全模型分为<strong>安全目标和敌手能力</strong>。<br>安全目标描述了安全模型要达到什么程度的安全，例如，对于加密算法的不可区分性（Indistinguishablity 简称 <strong>IND</strong>）、对于签名算法的存在性不可伪造（Existable Unforgeble 简称 EU）等。</p>
<p>其中不可区分性（IND）也称为<strong>语义安全</strong>（Semantic scurity），其定义如下。<br><strong>敌手即使获得了密文，也不能得到其对应明文的任何信息，哪怕是 1bit 的信息。</strong><br>其形式化的表示方法为：已知 m0，m1以及 Cb=Enc(pk，mb)，其中 m0是 m0或 m1中的任意一个，即 Cb是 m0、m1其中之一的密文，敌手无法有效判断加密过程中 b 到底是 0 还是 1。</p>

        <h2 id="安全性定义">
          <a href="#安全性定义" class="heading-link"><i class="fas fa-link"></i></a>安全性定义</h2>
      <p>刻画敌手的能力，主要有四类，<strong>选择明文攻击（Chosen Plaintext Attacke 简称 CPA）</strong>、<strong>选择密文攻击（Chosen Ciphertext Attack 简称 CCA）</strong>、惟密文攻击（Ciphertext-Only Attack）、已知明文攻击（Known Plaintext Attack）。常用的刻画敌手能力是前面两类，<strong>选择明文攻击（CPA）是指由敌手选择明文并且可以得到对应的密文。选择密文攻击（CCA）是指敌手不仅可以选择明文获得密文，还能选择有限次的密文，获得对应的明文</strong>。CCA比 CPA 描述敌手的能力更强。</p>
<p>下面介绍一下常用的安全性定义。</p>
<p><strong>CPA 安全。</strong>我们把选择明文攻击（CPA）描述成一个游戏以方便我们更好的理解。首先声明一点，这个游戏的目的<strong>是在选择明文攻击的前提下攻破系统的不可区分性（Indistinguishablity）</strong>，所以下面简称这个游戏为 <strong>IND-CPA</strong>。其次，还要定义两个角色挑战者 C 和敌手 A。挑战者（challenger）的任务相当裁判，主持游戏并且对敌手的行为进行反馈。敌手顾名思义，就是去攻击当前系统，而且对于这个游戏来说是采用选择明文攻击的方法进行攻击。游戏的描述如下： </p>
<ol>
<li><p>初始化：挑战者 C 创建 IND-CPA 系统，并且将公钥发送给敌手 A。 </p>
</li>
<li><p>敌手 A 选择<strong>两个长度相同的明文 m0，m1</strong>发送给挑战者 C。挑战者 C <strong>随机选择 b∈｛0,1｝</strong>，并将 mb加密记作 cb，然后将密文cb发送给敌手 A。</p>
</li>
<li><p>敌手 A <strong>猜测</strong>挑战者 C 上一步进行加密的明文是 m0还是 m1，并且将猜测结果输出，输出结果记为 b‘。若 b‘=b，那么敌手攻击成功。</p>
</li>
</ol>
<p>敌手攻击的优势可以定义为如下函数：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/NqbGY4.png" alt="NqbGY4.png">
      <br>其中 w 是加密方案密钥的长度。因为随机猜测就有<strong>1/2</strong>的概率赢得 IND-CPA 游戏。所以<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/Nqbtp9.png" alt="Nqbtp9.png">
      <br>才是敌手经过努力得到的优势。如果对任何多项式时间的敌手 A，存在一个可忽略的优势σ，使得<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/NqbrkD.png" alt="NqbrkD.png">
      <br>那么就称<strong>这个加密算法在选择明文攻击下具有不可区分性，或者称为 IND-CPA 安全。</strong></p>

        <h2 id="困难问题">
          <a href="#困难问题" class="heading-link"><i class="fas fa-link"></i></a>困难问题</h2>
      <p>有了安全模型和安全性定义，通常使用规约到困难问题的方法来进行安全性证明。密码学中常用的困难问题有<strong>离散对数困难问题</strong>（discrete logarithm problem，简称 DLP）、<strong>CDH 问题</strong>（Computational Diffie-Hellman） 、<strong>DDH 问题</strong>（Decisional Diffie-Hellman）以及 BDH 问题（Bilinear Diffie-Hellman）。 </p>

        <h2 id="可证明安全性理论">
          <a href="#可证明安全性理论" class="heading-link"><i class="fas fa-link"></i></a>可证明安全性理论</h2>
      <p>有了前面叙述了安全模型，安全性定义，困难性问题，可证有了前面叙述了安全模型，安全性定义，困难性问题，可证明安全体系也变得可行。<br>可证明安全性是指利用<strong>“规约”</strong>的方法，将攻击密码算法或安全协议的方法规约到一个攻击困难问题上。首先确定加密体制的安全目标，如签名体制的安全目标是签名的不可伪造性（Existable Unforgeble），加密体制的安全目标是信息的不可区分性（Indistinguishablity）。然后根据安全性定义确定敌手的能力构建一个安全性模型。</p>
<p><strong>规约是复杂性理论中的概念， 一个问题P1规约到问题P2是指，已知解决问题 P1的算法 M1，我们能构造另一算法 M2，M2可以以 M1作为子程序，用来解决问题 P2。</strong></p>
<p><strong>将规约的方法应用在密码算法或安全协议的安全性证明上，例如，可以将敌手对密码算法或安全协议（P1）的攻击规约到一些已经得到深入研究的困难问题（P2）。即若敌手能够对算法或协议发起有效的攻击，就可以利用敌手构建一个算法来攻破困难问题，然而困难问题是已经被证明无法攻破的，这样就出现矛盾。根据反证法，敌手可以攻破算法或协议假设不成立，证明完毕。</strong></p>
<p>一般来说，为了证明方案 1 的安全性，我们可以将方案 1 规约到方案 2，即如果敌手 A 可以攻破方案 1，那么敌手 B 同样也可以攻击方案 2，而方案 2 已经被证明是安全的，或者是一个难题。</p>
<p>证明过程通过一个思维游戏来描述。首先，挑战者创建方案2，B 表示方案 2 中的敌手，A 表示方案 1 中的敌手。B 为了攻破方案 2，利用 A 作为子程序来攻击方案 1。B 想要利用 A，就需要对 A 进行训练，所以 B 模拟了 A 的挑战者。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/Nqbotg.png" alt="Nqbotg.png">
      <br>例如，如果要对加密算法进行安全性证明，那么方案 1 就是具体的加密算法 。 假设安全目标是信息的不可区分性（Indistinguishablity），敌手 A 的能力是可以选择明文攻击，即 CPA。敌手 B 模拟敌手 A 的挑战者，与 A 进行 IND-CPA 游戏。在游戏过程中，B 为了实现自己的目的利用 A。如果 A 无法判断自己是与 B 还是与挑战者做游戏，那么称 B 的模拟是完备的。</p>
<p><strong>对于其他加密算法或加密协议，我们必须首先确定它想要实现的安全目标，例如签名方案的不可伪造性，然后根据安全性定义确定敌手的能力构建一个安全性模型，再把对加密算法或加密协议的攻击规约到已被证明的困难问题上。 这就是可证明安全性。</strong></p>

        <h1 id="结语">
          <a href="#结语" class="heading-link"><i class="fas fa-link"></i></a>结语</h1>
      <p>可证明安全性理论是密码学理论与计算复杂性理论的一次完美结合，也是现代密码学的基石。在过去的 30 年终，现代密码学最大的突破就是把密码学体系建立在计算复杂理论上，这使得密码学从一门艺术发展成为一门严谨的学科。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>安全分析</tag>
      </tags>
  </entry>
  <entry>
    <title>Summer</title>
    <url>/summer/</url>
    <content><![CDATA[<h1 id="菊次郎的夏天">
          <a href="#菊次郎的夏天" class="heading-link"><i class="fas fa-link"></i></a>菊次郎的夏天</h1>
      <p>夏天伴随着海边吹来的暖风，和西瓜一起来了。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/02/NqENRI.png?size=400x400" style="width: 400px;height: 400px;" alt="NqENRI.png">
      <br>每年到了夏天，都想看一边菊次郎的夏天;<br>每次伤心时候，都会单曲循环播放着Summer;<br><span class="exturl"><a class="exturl__link" href="http://music.163.com/song?id=443242&amp;userid=369654532" target="_blank" rel="noopener">Summer</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>–点击播放音乐</p>
<a id="more"></a>
<p>下面一篇文章是去年看完菊次郎的夏天后，写来参加一个征文比赛的小小说。</p>

        <h1 id="汪翔的夏天">
          <a href="#汪翔的夏天" class="heading-link"><i class="fas fa-link"></i></a>汪翔的夏天</h1>
      <p>十一年前的一天下午，窗外的风吹进了房间，吹开了书本的封面，里面歪歪扭扭地写着“6年3班汪翔”，随后“嘀嘀嘀”的闹铃声响起，一个身穿蓝色条纹睡衣的小男孩，不情愿地关掉闹钟，从床上爬起，开始收拾书包，准备下午上课。</p>
<p>他走出家门，抬头望了一下天空，飘着一朵巨大的云。然后看了一眼手表，北京时间14:20，离上课只剩下10分钟，他连忙向学校跑去。</p>
<p>在他刚刚走进教室的那一刻，地板开始震动，教室的墙壁出现裂缝，天花板上的风扇掉了下来，直直地砸中了他的头部，一瞬间世界只剩下了黑暗。</p>
<p>“滴滴滴”一阵赤耳的地震预警铃声，在宜宾市公安厅响起，一辆辆救援车队，朝着长宁县疾驰而去。</p>
<p>那是一座已坍塌的楼房，在瓦砾堆中，一张稚嫩的脸的出现在眼前。那是一个小男孩，泥巴夹着杂草，涂抹在他的脸上，还依稀看得清哭过后，留下的几道泪痕，他的眼里充满着血丝，透露出绝望。他想要大声地叫喊，嘴巴不停地开合着，却发不出一丝声音。突然间，一束光照了进来，地面上传来了救援人员的声音“小孩子，你不要怕，我们正在救你”。此时地面上一个二十岁出头的救援人员，正在拼命地用手抛开瓦砾，直到双手伤痕累累，沾满鲜血也不停止。终于小男孩得救了，呼吸到了地面上新鲜的空气，喝到了一口口甘甜的水。</p>
<p>小男孩向那个救援人员问到：“叔叔，你叫什么名字?”</p>
<p>救援人员笑了笑，答道：“汪翔”。</p>

        <h1 id="友链">
          <a href="#友链" class="heading-link"><i class="fas fa-link"></i></a>友链</h1>
      <p>我发现最近半年，身边很多的朋友都陆续建了自己的博客网站。<br>不论你是陌生人，还是我的朋友，想要加友链的，都可以在下方留言自己的博客和友链备注名称。<br>相遇有缘，一起成长吧！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>大学生活</category>
        <category>小小说</category>
      </categories>
      <tags>
        <tag>体验</tag>
      </tags>
  </entry>
  <entry>
    <title>SM2算法分析</title>
    <url>/SM2/</url>
    <content><![CDATA[<h1 id="基本参数确定">
          <a href="#基本参数确定" class="heading-link"><i class="fas fa-link"></i></a>基本参数确定</h1>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 选择素域，设置椭圆曲线参数</span></span><br><span class="line"><span class="comment"># m 为256bit长</span></span><br><span class="line">default_ecc_table = {</span><br><span class="line"><span class="string">'n'</span>: <span class="string">'FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123'</span>,</span><br><span class="line"><span class="string">'p'</span>: <span class="string">'FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF'</span>,</span><br><span class="line"><span class="comment"># 基点G</span></span><br><span class="line"><span class="string">'g'</span>: <span class="string">'32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7'</span>\</span><br><span class="line">    <span class="string">'bc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0'</span>,</span><br><span class="line"><span class="string">'a'</span>: <span class="string">'FFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC'</span>,</span><br><span class="line"><span class="string">'b'</span>: <span class="string">'28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93'</span>,</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>
<a id="more"></a>

        <h1 id="加密算法">
          <a href="#加密算法" class="heading-link"><i class="fas fa-link"></i></a>加密算法</h1>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 加密函数，data消息(bytes)</span></span><br><span class="line">    msg = data.hex() <span class="comment"># 消息转化为16进制字符串</span></span><br><span class="line">    <span class="comment"># 选择随机数k</span></span><br><span class="line">    k = func.random_hex(self.para_len)</span><br><span class="line">    <span class="comment"># 进行点乘运算，计算椭圆曲线点C1=kG</span></span><br><span class="line">    C1 = self._kg(int(k,<span class="number">16</span>),self.ecc_table[<span class="string">'g'</span>])</span><br><span class="line">    <span class="comment"># 这里缺少了一步验证过程，S=hP_B</span></span><br><span class="line">    <span class="comment"># 计算椭圆曲线点kP_B</span></span><br><span class="line">    xy = self._kg(int(k,<span class="number">16</span>),self.public_key)</span><br><span class="line">    <span class="comment"># 从xy比特串中取出(x2,y2)</span></span><br><span class="line">    x2 = xy[<span class="number">0</span>:self.para_len]</span><br><span class="line">    y2 = xy[self.para_len:<span class="number">2</span>*self.para_len]</span><br><span class="line">    ml = len(msg)</span><br><span class="line">    <span class="comment"># KDF密钥派生函数，用SM3算法产生伪随机数</span></span><br><span class="line">    t = sm3.sm3_kdf(xy.encode(<span class="string">'utf8'</span>), ml/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> int(t,<span class="number">16</span>)==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 这边这个语法没搞懂，估计是取ml长的字符串，前面以0填充</span></span><br><span class="line">        form = <span class="string">'%%0%dx'</span> % ml</span><br><span class="line">        <span class="comment"># C2 = M⊕t</span></span><br><span class="line">        C2 = form % (int(msg, <span class="number">16</span>) ^ int(t, <span class="number">16</span>))</span><br><span class="line">        <span class="comment"># C3 = Hash(x2||M||y2)</span></span><br><span class="line">        C3 = sm3.sm3_hash([</span><br><span class="line">            i <span class="keyword">for</span> i <span class="keyword">in</span> bytes.fromhex(<span class="string">'%s%s%s'</span>% (x2,msg,y2))</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> bytes.fromhex(<span class="string">'%s%s%s'</span> % (C1,C3,C2))</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="解密函数">
          <a href="#解密函数" class="heading-link"><i class="fas fa-link"></i></a>解密函数</h1>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">(self, data)</span>:</span></span><br><span class="line">    <span class="comment"># 解密函数，data密文（bytes）</span></span><br><span class="line">    data = data.hex() <span class="comment"># 消息转化为16进制字符串</span></span><br><span class="line">    len_2 = <span class="number">2</span> * self.para_len</span><br><span class="line">    len_3 = len_2 + <span class="number">64</span></span><br><span class="line">    <span class="comment"># 从data中取出C1、C2、C3</span></span><br><span class="line">    C1 = data[<span class="number">0</span>:len_2]</span><br><span class="line">    C3 = data[len_2:len_3]</span><br><span class="line">    C2 = data[len_3:]</span><br><span class="line">    <span class="comment"># 利用私钥d_B,计算d_BC1=xy</span></span><br><span class="line">    xy = self._kg(int(self.private_key,<span class="number">16</span>),C1)</span><br><span class="line">    <span class="comment"># print('xy = %s' % xy)</span></span><br><span class="line">    x2 = xy[<span class="number">0</span>:self.para_len]</span><br><span class="line">    y2 = xy[self.para_len:len_2]</span><br><span class="line">    cl = len(C2)</span><br><span class="line">    <span class="comment"># 计算t=KDF(x2||y2,klen),klen=self.pare_len</span></span><br><span class="line">    t = sm3.sm3_kdf(xy.encode(<span class="string">'utf8'</span>), cl/<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">if</span> int(t, <span class="number">16</span>) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 作用同上，格式化输出</span></span><br><span class="line">        form = <span class="string">'%%0%dx'</span> % cl</span><br><span class="line">        <span class="comment"># M = C2⊕t</span></span><br><span class="line">        M = form % (int(C2,<span class="number">16</span>) ^ int(t,<span class="number">16</span>))</span><br><span class="line">        <span class="comment"># u = Hash(x2||M||y2)</span></span><br><span class="line">        u = sm3.sm3_hash([</span><br><span class="line">            i <span class="keyword">for</span> i <span class="keyword">in</span> bytes.fromhex(<span class="string">'%s%s%s'</span>% (x2,M,y2))</span><br><span class="line">        ])</span><br><span class="line">        <span class="keyword">return</span> bytes.fromhex(M)</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="签名函数">
          <a href="#签名函数" class="heading-link"><i class="fas fa-link"></i></a>签名函数</h1>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 签名函数, data消息的hash，private_key私钥，K随机数，均为16进制字符串</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sign</span><span class="params">(self, data, K)</span>:</span>  </span><br><span class="line">    E = data.hex() <span class="comment"># 消息转化为16进制字符串</span></span><br><span class="line">    e = int(E, <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># d 为16进制的私钥</span></span><br><span class="line">    d = int(self.private_key, <span class="number">16</span>)</span><br><span class="line">    k = int(K, <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算椭圆曲线点P1=kG=(x,y)</span></span><br><span class="line">    P1 = self._kg(k, self.ecc_table[<span class="string">'g'</span>])</span><br><span class="line"></span><br><span class="line">    x = int(P1[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># 计算R=(e+x)mod n</span></span><br><span class="line">    R = ((e + x) % int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>))</span><br><span class="line">    <span class="keyword">if</span> R == <span class="number">0</span> <span class="keyword">or</span> R + k == int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>):<span class="comment"># 纠错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment"># d_1 = (d+1)^(n-2) mod n</span></span><br><span class="line">    <span class="comment"># 我觉得这边的写法主要是避免了求逆的计算</span></span><br><span class="line">    d_1 = pow(d+<span class="number">1</span>, int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>) - <span class="number">2</span>, int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>))</span><br><span class="line">    <span class="comment"># s = (d+1)^-1 * (k-Rd) mod n</span></span><br><span class="line">    S = (d_1*(k + R) - R) % int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> S == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%064x%064x'</span> % (R,S)</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="验证函数">
          <a href="#验证函数" class="heading-link"><i class="fas fa-link"></i></a>验证函数</h1>
      <figure class="highlight python"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify</span><span class="params">(self, Sign, data)</span>:</span></span><br><span class="line">    <span class="comment"># 验签函数，sign签名r||s，E消息hash，public_key公钥</span></span><br><span class="line">    r = int(Sign[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">    s = int(Sign[self.para_len:<span class="number">2</span>*self.para_len], <span class="number">16</span>)</span><br><span class="line">    e = int(data.hex(), <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># t = (r + s) mod n</span></span><br><span class="line">    t = (r + s) % int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">if</span> t == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># P1 = sG</span></span><br><span class="line">    P1 = self._kg(s, self.ecc_table[<span class="string">'g'</span>])</span><br><span class="line">    <span class="comment"># P2 = tP</span></span><br><span class="line">    P2 = self._kg(t, self.public_key)</span><br><span class="line">    <span class="comment"># print(P1)</span></span><br><span class="line">    <span class="comment"># print(P2)</span></span><br><span class="line">    <span class="comment"># 有限域上的椭圆曲线加法公式</span></span><br><span class="line">    <span class="keyword">if</span> P1 == P2:</span><br><span class="line">        P1 = <span class="string">'%s%s'</span> % (P1, <span class="number">1</span>)</span><br><span class="line">        P1 = self._double_point(P1)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        P1 = <span class="string">'%s%s'</span> % (P1, <span class="number">1</span>)</span><br><span class="line">        P1 = self._add_point(P1, P2)</span><br><span class="line">        P1 = self._convert_jacb_to_nor(P1)</span><br><span class="line"></span><br><span class="line">    x = int(P1[<span class="number">0</span>:self.para_len], <span class="number">16</span>)</span><br><span class="line">    <span class="comment"># R = (e + x) mod n 验证 R=r是否成立</span></span><br><span class="line">    <span class="keyword">return</span> (r == ((e + x) % int(self.ecc_table[<span class="string">'n'</span>], base=<span class="number">16</span>)))</span><br></pre></td></tr></tbody></table></div></figure>
<p><span class="exturl"><a class="exturl__link" href="https://github.com/duanhongyi/gmssl/blob/master/gmssl/sm2.py" target="_blank" rel="noopener">完整源码</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>密码学</category>
      </categories>
      <tags>
        <tag>SM2</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门教程</title>
    <url>/docker/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/29/Nh1Saj.png" alt="Docker">
      <br>我之前一直都听过鼎鼎大名的Docker,但都没有仔细地了解一下，有一次给后端接Mysql数据库时，本来想下一个Mysql的，但是安装配置太麻烦，就直接从Docker上下了一个镜像就解决了，这就是我的Docker初体验。<br>接下来，就请乘坐我的宇宙航线，开启Docker之旅<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8">✨</span>。</p>
<a id="more"></a>

        <h1 id="What-is-Dcoker">
          <a href="#What-is-Dcoker" class="heading-link"><i class="fas fa-link"></i></a>What is Dcoker?</h1>
      <p>在讲述Docker前，我们需要了解一下的它的诞生起源，也就是<strong>Why need it?</strong></p>

        <h2 id="环境配置">
          <a href="#环境配置" class="heading-link"><i class="fas fa-link"></i></a>环境配置</h2>
      <p>软件开发过程中，遇到最麻烦的问题就各种环境的安装，从一开始的C语言到Java到数据库postgresql等,很多时候自己的程序在本机跑没有问题，但是别人的机子就跑不通。这个时候开发者经常说“<strong>it works on my machine</strong>”,其实往往在别的机子不行。<br>于是聪明的开发者就想，我能不能把环境一起安装呢?也就是说，我在安装的软件程序的时候，不仅仅安装程序应用本身，而且把它所需要的环境依赖都一同安装下来。</p>

        <h2 id="虚拟机">
          <a href="#虚拟机" class="heading-link"><i class="fas fa-link"></i></a>虚拟机</h2>
      <p>虚拟机(Virtual Machine)其实就是一种很好的解决方案，我只要使用Vmware安装Linux虚拟机，就可以在Windows系统中运行Linux虚拟环境。虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>
<ol>
<li>占用内存空间<blockquote>
<p>我自己在运行Linux虚拟机就要划分80GB的磁盘空间，而且一跑起来风扇就开始快速转动。</p>
</blockquote>
</li>
<li>启动慢<blockquote>
<p>启动操作系统虚拟多久，启动虚拟机就要多久。我因为之前划分了磁盘，每次启动要几分钟的时间。</p>
</blockquote>
</li>
<li>操作不便捷<blockquote>
<p>虚拟机是完整的操作系统，想要启动一个服务，往往需要冗余步骤。</p>
</blockquote>
</li>
</ol>

        <h2 id="Linux容器">
          <a href="#Linux容器" class="heading-link"><i class="fas fa-link"></i></a>Linux容器</h2>
      <p>针对前面提到的虚拟机存在的问题，Linux发展出另一种虚拟化技术(Linux Containers),也就是<strong>Linux容器</strong>。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/12/U3vH8f.png" alt="container">
      </p>
<blockquote>
<p>关于容器的概念我们可以把它通俗地理解为一个个集装箱，每一个集装箱之间是相互隔离运行的，但是在运输的时候又共享同一艘货轮(操作系统)，也就是说每一个容器都是一个进程，共享操作系统的资源。</p>
</blockquote>

        <h3 id="容器VS虚拟机">
          <a href="#容器VS虚拟机" class="heading-link"><i class="fas fa-link"></i></a>容器VS虚拟机</h3>
      <p>虚拟机技术是虚拟化一整套硬件，在上面运行一个完整的操作系统。<br>而容器虚拟化的是操作系统，而不是硬件，容器之间是共享同一个操作系统资源的。</p>

        <h2 id="Docker">
          <a href="#Docker" class="heading-link"><i class="fas fa-link"></i></a>Docker</h2>
      <p>Docker 属于 Linux 容器的一种<strong>封装</strong>，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p>
<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>
<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>

        <h1 id="Docker的基本概念">
          <a href="#Docker的基本概念" class="heading-link"><i class="fas fa-link"></i></a>Docker的基本概念</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/07/12/U3xAr4.png" alt="docker">
      </p>

        <h2 id="Image镜像">
          <a href="#Image镜像" class="heading-link"><i class="fas fa-link"></i></a>Image镜像</h2>
      <p>我们可以把镜像理解成是一个特殊的文件系统。</p>
<blockquote>
<p>对于Linux操作系统而言，内核模块启动后，会挂载root文件系统为其提供用户空间的支持。而Docker镜像就相当于是一个root文件系统。</p>
</blockquote>
<p>Docker 把应用程序及其依赖，打包在 image 文件里面。只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的<strong>模板</strong>。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>
<p>因为Docker在设计时，采用的是Union FS的技术，将其设计为<strong>分层存储</strong>的架构。<br><strong>因此在镜像构建时，会一层层地构建，前一层是后一层地基础。</strong>每一层构建完就不会再发生改变，后一层上的任何改变只会影响到自己这一层。可以见上图中的镜像层次分布。</p>

        <h2 id="Container容器">
          <a href="#Container容器" class="heading-link"><i class="fas fa-link"></i></a>Container容器</h2>
      <p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，<strong>容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</strong></p>

        <h2 id="Repository仓库">
          <a href="#Repository仓库" class="heading-link"><i class="fas fa-link"></i></a>Repository仓库</h2>
      <p>仓库就是一个集中存放镜像文件的地方。</p>

        <h1 id="Docker常用命令">
          <a href="#Docker常用命令" class="heading-link"><i class="fas fa-link"></i></a>Docker常用命令</h1>
      <figure class="highlight docker"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"># 启动Docker服务</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="comment"># Pull Docker镜像</span></span><br><span class="line">docker image pull library/hello-world</span><br><span class="line"><span class="comment"># 运行image镜像,生成容器实例</span></span><br><span class="line">docker container <span class="keyword">run</span><span class="bash"> hello-world</span></span><br><span class="line"><span class="comment"># 结束实例进程</span></span><br><span class="line">docker container kill[containerID]</span><br></pre></td></tr></tbody></table></div></figure>
<p>参考资料：<br><span class="exturl"><a class="exturl__link" href="https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5b260ec26fb9a00e8e4b031a#heading-6" target="_blank" rel="noopener">https://juejin.im/post/5b260ec26fb9a00e8e4b031a#heading-6</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/regex/</url>
    <content><![CDATA[<h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>在学习编程的这两年里，无数次的遇到正则表达式，不管是在Python还是Java中，正则表达式都是绕不开的话题。<br>今天打算写一篇正则表达式的总结文章，一是为了学习，二是为了日后查阅复制方便。<br>发现了Github上有一个超好的学习资料，将在上面做一些修改，作为总结。同时限于篇幅，只写了常用部分，更多内容请见<span class="exturl"><a class="exturl__link" href="https://github.com/ziishaned/learn-regex" target="_blank" rel="noopener">learn-regex</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>

        <h1 id="1-基本匹配">
          <a href="#1-基本匹配" class="heading-link"><i class="fas fa-link"></i></a>1.基本匹配</h1>
      <p>正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。 例如：一个正则表达式 the，它表示一个规则：由字母t开始，接着是h，再接着是e。<br>同时正则表达式是大小写的敏感的，所以the不会匹配The。</p>

        <h1 id="2-元字符">
          <a href="#2-元字符" class="heading-link"><i class="fas fa-link"></i></a>2.元字符</h1>
      <p>正则表达式的核心就是元字符的匹配，元字符的描述如下图所示。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/18/NeplQJ.png" alt="NeplQJ.png">
      </p>

        <h2 id="2-1点运算符">
          <a href="#2-1点运算符" class="heading-link"><i class="fas fa-link"></i></a>2.1点运算符.</h2>
      <p>.是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。</p>
<figure class="highlight coq"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">".ar"</span> =&gt; The car parked <span class="built_in">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-2字符集">
          <a href="#2-2字符集" class="heading-link"><i class="fas fa-link"></i></a>2.2字符集</h2>
      <p>[ ]方括号用来指定一个字符集。在[ ]方括号中使用连字符-来指定字符集的范围。<br>在方括号中的字符集不关心顺序。例如，表达式<code>[Tt]he</code> 匹配 the 和 The。</p>
<figure class="highlight coq"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[Tt]he"</span> =&gt; The car parked <span class="built_in">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>
<p>方括号中的句号就表示句号。表达式 ar[.] 匹配 ar.字符串</p>
<figure class="highlight livecodeserver"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"ar[.]"</span> =&gt; A garage is <span class="keyword">a</span> good place <span class="built_in">to</span> park <span class="keyword">a</span> car.</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="2-2-1否定字符集">
          <a href="#2-2-1否定字符集" class="heading-link"><i class="fas fa-link"></i></a>2.2.1否定字符集</h3>
      <p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头<code>[^]</code>的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个ar前面非c的任意字符。如下面的par、gar而非car。</p>
<figure class="highlight coq"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[^c]ar"</span> =&gt; The car parked <span class="built_in">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-3重复次数">
          <a href="#2-3重复次数" class="heading-link"><i class="fas fa-link"></i></a>2.3重复次数</h2>
      <p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p>

        <h3 id="2-3-1-号">
          <a href="#2-3-1-号" class="heading-link"><i class="fas fa-link"></i></a>2.3.1*号</h3>
      <p><code>*</code>号匹配在 <code>*</code>之前的字符出现<strong>大于等于0次</strong>。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p>
<figure class="highlight livecodeserver"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[a-z]*"</span> =&gt; The car parked <span class="keyword">in</span> <span class="keyword">the</span> garage <span class="comment">#21.</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p>
<figure class="highlight dart"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"\s*cat\s*"</span> =&gt; The fat cat sat <span class="keyword">on</span> the concatenation.</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="2-3-2-号">
          <a href="#2-3-2-号" class="heading-link"><i class="fas fa-link"></i></a>2.3.2+号</h3>
      <p><code>+</code>号匹配<code>+</code>号之前的字符出现 <strong>&gt;=1 次</strong>。 例如表达式<code>c.+t</code>匹配以首字母c开头以t结尾，中间跟着至少一个字符的字符串。</p>
<figure class="highlight stata"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"c.+t"</span> =&gt; The fat <span class="keyword">cat</span> sat <span class="keyword">on</span> the <span class="keyword">mat</span>.</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="2-3-3-号">
          <a href="#2-3-3-号" class="heading-link"><i class="fas fa-link"></i></a>2.3.3?号</h3>
      <p>在正则表达式中元字符 <code>?</code>标记在符号前面的字符为可选，即<strong>出现 0 或 1 次</strong>。 例如，表达式 <code>[T]?he</code> 匹配字符串 he 和 The。</p>
<figure class="highlight dart"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[T]he"</span> =&gt; The car <span class="keyword">is</span> parked <span class="keyword">in</span> the garage.</span><br><span class="line"><span class="string">"[T]?he"</span> =&gt; The car <span class="keyword">is</span> parked <span class="keyword">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-4-号">
          <a href="#2-4-号" class="heading-link"><i class="fas fa-link"></i></a>2.4{}号</h2>
      <p>在正则表达式中 <code>{}</code>是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如，表达式 <code>[0-9]{2,3}</code>匹配最少 2 位最多 3 位 0~9 的数字。</p>
<figure class="highlight livescript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[0-9]{2,3}"</span> =&gt; The number was <span class="number">9.9997</span> but we rounded <span class="literal">it</span> <span class="literal">off</span> <span class="keyword">to</span> <span class="number">10.0</span>.</span><br></pre></td></tr></tbody></table></div></figure>
<p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p>
<figure class="highlight livescript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[0-9]{2,}"</span> =&gt; The number was <span class="number">9.9997</span> but we rounded <span class="literal">it</span> <span class="literal">off</span> <span class="keyword">to</span> <span class="number">10.0</span>.</span><br></pre></td></tr></tbody></table></div></figure>
<p>如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{3} 匹配3位数字。</p>
<figure class="highlight livescript"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"[0-9]{3}"</span> =&gt; The number was <span class="number">9.9997</span> but we rounded <span class="literal">it</span> <span class="literal">off</span> <span class="keyword">to</span> <span class="number">10.0</span>.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-5-…-特征标群">
          <a href="#2-5-…-特征标群" class="heading-link"><i class="fas fa-link"></i></a>2.5(…)特征标群</h2>
      <p><code>(...)</code>里面的内容可以看作一个整体。例如，表达式 <code>(ab)*</code>匹配连续出现 0 或更多个 ab。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 b 。<br>我们还可以在 <code>()</code>中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 car 或 gar 或 par.</p>
<figure class="highlight dart"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"(c|g|p)ar"</span> =&gt; The car <span class="keyword">is</span> parked <span class="keyword">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-6-或运算符">
          <a href="#2-6-或运算符" class="heading-link"><i class="fas fa-link"></i></a>2.6|或运算符</h2>
      <p>或运算符就表示或，用作判断条件。<br>例如 <code>(T|t)he|car</code>匹配 <code>(T|t)he 或 car</code>。</p>
<figure class="highlight dart"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"(T|t)he|car"</span> =&gt; The car <span class="keyword">is</span> parked <span class="keyword">in</span> the garage.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-7-转码特殊字符">
          <a href="#2-7-转码特殊字符" class="heading-link"><i class="fas fa-link"></i></a>2.7\转码特殊字符</h2>
      <p>反斜线<code>\</code>在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code>这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线<code>\</code>。<br>例如 <code>.</code>是用来匹配除换行符外的所有字符的。如果想要匹配句子中的<code>.</code> 则要写成<code>\.</code>以下这个例子 <code>\.?</code>是选择性匹配.</p>
<figure class="highlight stata"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"(f|c|m)at\.?"</span> =&gt; The fat <span class="keyword">cat</span> sat <span class="keyword">on</span> the <span class="keyword">mat</span>.</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="2-8锚点">
          <a href="#2-8锚点" class="heading-link"><i class="fas fa-link"></i></a>2.8锚点</h2>
      <p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code>指定开头，<code>$</code>指定结尾。</p>

        <h1 id="3-简写字符集">
          <a href="#3-简写字符集" class="heading-link"><i class="fas fa-link"></i></a>3.简写字符集</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/18/NevH1J.png" alt="NevH1J.png">
      </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Test</title>
    <url>/SQL-Test/</url>
    <content><![CDATA[<h1 id="TABLE-Student">
          <a href="#TABLE-Student" class="heading-link"><i class="fas fa-link"></i></a>TABLE Student</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Student_2018091601004(</span><br><span class="line">	StudentID <span class="built_in">char</span>(<span class="number">13</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	StudentName <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	Sex <span class="built_in">char</span>(<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>
<a id="more"></a>

        <h1 id="TABLE-Teacher">
          <a href="#TABLE-Teacher" class="heading-link"><i class="fas fa-link"></i></a>TABLE Teacher</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Teacher_2018091601004(</span><br><span class="line">	TeacherID <span class="built_in">char</span>(<span class="number">7</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	TeacherName <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	Title <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">CHECK</span>(Title <span class="keyword">IN</span>(<span class="string">'教授'</span>,<span class="string">'副教授'</span>,<span class="string">'讲师'</span>))</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="TABLE-Course">
          <a href="#TABLE-Course" class="heading-link"><i class="fas fa-link"></i></a>TABLE Course</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Course_2018091601004(</span><br><span class="line">	CourseID <span class="built_in">char</span>(<span class="number">10</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">	CourseName <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	TeacherID <span class="built_in">char</span>(<span class="number">7</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	Credit <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">CHECK</span>(Credit <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> TeacherID_FK <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(TeacherID)</span><br><span class="line">	<span class="keyword">REFERENCES</span> Teacher_2018091601004(TeacherID)</span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="TABLE-Grade">
          <a href="#TABLE-Grade" class="heading-link"><i class="fas fa-link"></i></a>TABLE Grade</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Grade_2018091601004(</span><br><span class="line">	StudentID <span class="built_in">char</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	CourseID <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	Score <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">CHECK</span>(Score&gt;=<span class="number">0</span> <span class="keyword">and</span> Score&lt;=<span class="number">100</span>),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> Grade_PK PRIMARY <span class="keyword">KEY</span>(StudentID,CourseID),</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> Student_FK <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(StudentID)</span><br><span class="line">	<span class="keyword">REFERENCES</span> Student_2018091601004(StudentID)</span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>,</span><br><span class="line">	<span class="keyword">CONSTRAINT</span> CourseID <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(CourseID)</span><br><span class="line">	<span class="keyword">REFERENCES</span> Course_2018091601004(CourseID)</span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">		<span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="INSERT-Student">
          <a href="#INSERT-Student" class="heading-link"><i class="fas fa-link"></i></a>INSERT Student</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015201'</span>,<span class="string">'李同学'</span>,<span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015202'</span>,<span class="string">'赵同学'</span>,<span class="string">'女'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018091601004'</span>,<span class="string">'林俊'</span>,<span class="string">'男'</span>);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="INSERT-Teacher">
          <a href="#INSERT-Teacher" class="heading-link"><i class="fas fa-link"></i></a>INSERT Teacher</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Teacher_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'3202211'</span>,<span class="string">'张老师'</span>,<span class="string">'教授'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Teacher_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'3202212'</span>,<span class="string">'刘老师'</span>,<span class="string">'副教授'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Teacher_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'1601004'</span>,<span class="string">'林俊'</span>,<span class="string">'讲师'</span>);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="INSERT-Course">
          <a href="#INSERT-Course" class="heading-link"><i class="fas fa-link"></i></a>INSERT Course</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'C001'</span>,<span class="string">'数据库原理'</span>,<span class="string">'3202211'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'C002'</span>,<span class="string">'软件工程原理'</span>,<span class="string">'3202212'</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Course_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'C003'</span>,<span class="string">'林俊'</span>,<span class="string">'3202212'</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="INSERT-Grade">
          <a href="#INSERT-Grade" class="heading-link"><i class="fas fa-link"></i></a>INSERT Grade</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018091601004'</span>,<span class="string">'C001'</span>,<span class="number">90</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018091601004'</span>,<span class="string">'C002'</span>,<span class="number">80</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015201'</span>,<span class="string">'C001'</span>,<span class="number">92</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015201'</span>,<span class="string">'C002'</span>,<span class="number">45</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015202'</span>,<span class="string">'C001'</span>,<span class="number">56</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Grade_2018091601004 <span class="keyword">VALUES</span>(<span class="string">'2018090015202'</span>,<span class="string">'C002'</span>,<span class="number">35</span>);</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="SELECT-join-on">
          <a href="#SELECT-join-on" class="heading-link"><i class="fas fa-link"></i></a>SELECT join on</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.StudentID,A.StudentName,B.Score,C.CourseName</span><br><span class="line"><span class="keyword">FROM</span> Student_2018091601004 <span class="keyword">as</span> A <span class="keyword">join</span> Grade_2018091601004 <span class="keyword">as</span> B </span><br><span class="line"><span class="keyword">on</span> A.StudentID=B.StudentID <span class="keyword">join</span> Course_2018091601004 <span class="keyword">as</span> C </span><br><span class="line"><span class="keyword">on</span> B.CourseID=C.CourseID</span><br><span class="line"><span class="keyword">WHERE</span> A.StudentID=<span class="string">'2018091601004'</span>;</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="CREATE-VIEW">
          <a href="#CREATE-VIEW" class="heading-link"><i class="fas fa-link"></i></a>CREATE VIEW</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> View_Grade_2018091601004 <span class="keyword">as</span></span><br><span class="line"><span class="keyword">SELECT</span> A.CourseID <span class="keyword">as</span> 课程编号,</span><br><span class="line">	   A.CourseName <span class="keyword">as</span> 课程名称,</span><br><span class="line">	   B.TeacherName <span class="keyword">as</span> 任课教师,</span><br><span class="line">	   <span class="keyword">count</span>(C.StudentID) <span class="keyword">as</span> 不及格人数</span><br><span class="line"><span class="keyword">FROM</span> Course_2018091601004 <span class="keyword">as</span> A </span><br><span class="line">	<span class="keyword">join</span> Teacher_2018091601004 <span class="keyword">as</span> B <span class="keyword">on</span> A.TeacherID=B.TeacherID</span><br><span class="line">	<span class="keyword">join</span> Grade_2018091601004 <span class="keyword">as</span> C <span class="keyword">on</span> A.CourseID=C.CourseID</span><br><span class="line"><span class="keyword">WHERE</span> C.Score&lt;<span class="number">60</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">by</span> A.CourseID,B.TeacherName</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">by</span> A.CourseID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span>* <span class="keyword">FROM</span>  View_Grade_2018091601004;</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="CREATE-ROLE">
          <a href="#CREATE-ROLE" class="heading-link"><i class="fas fa-link"></i></a>CREATE ROLE</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">"Role_Student_2018091601004"</span> <span class="keyword">WITH</span> LOGIN</span><br><span class="line">NOSUPERUSER</span><br><span class="line">NOCREATEDB</span><br><span class="line">NOCREATEROLE </span><br><span class="line">INHERIT </span><br><span class="line">NOREPLICATION </span><br><span class="line"><span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">"Role_Teacher_2018091601004"</span> <span class="keyword">WITH</span> LOGIN</span><br><span class="line">NOSUPERUSER</span><br><span class="line">NOCREATEDB</span><br><span class="line">NOCREATEROLE </span><br><span class="line">INHERIT </span><br><span class="line">NOREPLICATION </span><br><span class="line"><span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span>;	</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">ROLE</span> <span class="string">"Role_TAdmin_2018091601004"</span> <span class="keyword">WITH</span> LOGIN</span><br><span class="line">NOSUPERUSER</span><br><span class="line">NOCREATEDB</span><br><span class="line">NOCREATEROLE </span><br><span class="line">INHERIT </span><br><span class="line">NOREPLICATION </span><br><span class="line"><span class="keyword">CONNECTION</span> <span class="keyword">LIMIT</span> <span class="number">-1</span>;</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="GRANT-ROLE">
          <a href="#GRANT-ROLE" class="heading-link"><i class="fas fa-link"></i></a>GRANT ROLE</h1>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> Student_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Student_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Teacher_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Student_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Course_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Student_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Grade_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Student_2018091601004"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Student_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Teacher_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span> <span class="keyword">ON</span> Teacher_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Teacher_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Course_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Teacher_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> Grade_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_Teacher_2018091601004"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Student_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_TAdmin_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Teacher_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_TAdmin_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">INSERT</span> <span class="keyword">ON</span> Course_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_TAdmin_2018091601004"</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span> <span class="keyword">ON</span> Grade_2018091601004 <span class="keyword">TO</span> <span class="string">"Role_TAdmin_2018091601004"</span>;</span><br></pre></td></tr></tbody></table></div></figure>







<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System(2)</title>
    <url>/Operating-System-2/</url>
    <content><![CDATA[<h1 id="进程">
          <a href="#进程" class="heading-link"><i class="fas fa-link"></i></a>进程</h1>
      
        <h2 id="进程与线程">
          <a href="#进程与线程" class="heading-link"><i class="fas fa-link"></i></a>进程与线程</h2>
      
        <h3 id="进程-1">
          <a href="#进程-1" class="heading-link"><i class="fas fa-link"></i></a>进程</h3>
      <p>进程是系统进行资源分配和调度的一个独立单位。<br>进程控制块(Process Control Block,PCB)描述进程的基本信息和活动过程，进而控制进程和管理进程。<br>特征：动态性、并发性、独立性、异步性。</p>

        <h3 id="线程">
          <a href="#线程" class="heading-link"><i class="fas fa-link"></i></a>线程</h3>
      <p>线程作为调度和分派的基本单位。<br>线程是进程的进一步划分，一个进程可以有多个线程，他们共享进程资源。</p>

        <h3 id="比较">
          <a href="#比较" class="heading-link"><i class="fas fa-link"></i></a>比较</h3>
      <ol>
<li>进程是资源分配的基本单位，但是线程不拥有系统资源，仅有少量能保证独立运行的资源。(一些必备的寄存器，如程序计数器等)同时线程共享进程的资源。</li>
<li>进程的切换开销大，线程是独立调动的基本单位，切换线程的开销更小。<a id="more"></a>

        <h2 id="进程状态">
          <a href="#进程状态" class="heading-link"><i class="fas fa-link"></i></a>进程状态</h2>
      
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/12/tLBcTI.png" alt="五种状态转换">
      </li>
</ol>
<ul>
<li>就绪状态：资源已经准备好了，就差CPU调度</li>
<li>阻塞状态：被某些事件给中断了，缺少必要的资源(除CPU时间)</li>
</ul>

        <h3 id="挂起与激活">
          <a href="#挂起与激活" class="heading-link"><i class="fas fa-link"></i></a>挂起与激活</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/12/tLDjUI.png" alt="挂起与激活">
      </p>
<ul>
<li>若进程处于就绪状态，挂起操作执行后，则由活动就绪转为禁止就绪</li>
<li>若进程处于阻塞状态，挂起操作执行后，则由活动阻塞转为禁止阻塞</li>
</ul>

        <h2 id="进程同步">
          <a href="#进程同步" class="heading-link"><i class="fas fa-link"></i></a>进程同步</h2>
      
        <h3 id="1-临界区">
          <a href="#1-临界区" class="heading-link"><i class="fas fa-link"></i></a>1. 临界区</h3>
      <p>对临界资源进行访问的那段代码称为临界区。<br>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>

        <h3 id="2-信号量">
          <a href="#2-信号量" class="heading-link"><i class="fas fa-link"></i></a>2. 信号量</h3>
      
        <h3 id="3-管程">
          <a href="#3-管程" class="heading-link"><i class="fas fa-link"></i></a>3. 管程</h3>
      <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network</title>
    <url>/Computer-Network/</url>
    <content><![CDATA[<h1 id="概述">
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/08/tRorRg.png" alt="tRorRg.png">
      </p>
<blockquote>
<p>第8点会考一些基本安全知识</p>
</blockquote>
<a id="more"></a>

        <h2 id="计算机网络的概念">
          <a href="#计算机网络的概念" class="heading-link"><i class="fas fa-link"></i></a>计算机网络的概念</h2>
      
        <h2 id="什么是协议？">
          <a href="#什么是协议？" class="heading-link"><i class="fas fa-link"></i></a>什么是协议？</h2>
      
        <h3 id="网络协议">
          <a href="#网络协议" class="heading-link"><i class="fas fa-link"></i></a>网络协议</h3>
      
        <h3 id="三要素">
          <a href="#三要素" class="heading-link"><i class="fas fa-link"></i></a>三要素</h3>
      
        <h3 id="和现实协议的对比">
          <a href="#和现实协议的对比" class="heading-link"><i class="fas fa-link"></i></a>和现实协议的对比</h3>
      
        <h2 id="服务">
          <a href="#服务" class="heading-link"><i class="fas fa-link"></i></a>服务</h2>
      
        <h3 id="服务划分">
          <a href="#服务划分" class="heading-link"><i class="fas fa-link"></i></a>服务划分</h3>
      <p>面向连接的不一定可靠，无连接的一定不可靠</p>

        <h2 id="网络核心">
          <a href="#网络核心" class="heading-link"><i class="fas fa-link"></i></a>网络核心</h2>
      
        <h3 id="电路交换">
          <a href="#电路交换" class="heading-link"><i class="fas fa-link"></i></a>电路交换</h3>
      <p>频分<br>时分<br>码分</p>

        <h3 id="分组交换">
          <a href="#分组交换" class="heading-link"><i class="fas fa-link"></i></a>分组交换</h3>
      <p>特点：</p>

        <h3 id="比较优缺点">
          <a href="#比较优缺点" class="heading-link"><i class="fas fa-link"></i></a>比较优缺点</h3>
      
        <h2 id="分组交换网络中延迟、丢失和吞吐量">
          <a href="#分组交换网络中延迟、丢失和吞吐量" class="heading-link"><i class="fas fa-link"></i></a>分组交换网络中延迟、丢失和吞吐量</h2>
      
        <h3 id="分组交换的4种时延">
          <a href="#分组交换的4种时延" class="heading-link"><i class="fas fa-link"></i></a>分组交换的4种时延</h3>
      <ol>
<li>节点处理时延</li>
<li>排队时延(变换剧烈)</li>
<li><strong>传输时延</strong></li>
<li><strong>传播时延</strong></li>
</ol>

        <h3 id="吞吐量">
          <a href="#吞吐量" class="heading-link"><i class="fas fa-link"></i></a>吞吐量</h3>
      <p>瓶颈链路是制约吞吐量的链路</p>

        <h2 id="协议层及服务模型">
          <a href="#协议层及服务模型" class="heading-link"><i class="fas fa-link"></i></a>协议层及服务模型</h2>
      
        <h3 id="TCP-IP协议的五层模型">
          <a href="#TCP-IP协议的五层模型" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP协议的五层模型</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/08/tRTNpF.png" alt="tRTNpF.png">
      </p>

        <h1 id="应用层">
          <a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a>应用层</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/08/tRTdX9.png" alt="tRTdX9.png">
      </p>

        <h2 id="应用层协议原理">
          <a href="#应用层协议原理" class="heading-link"><i class="fas fa-link"></i></a>应用层协议原理</h2>
      
        <h3 id="端口号">
          <a href="#端口号" class="heading-link"><i class="fas fa-link"></i></a>端口号</h3>
      <p>端口号用16位(0-65535)<br>常用端口：<br>HTTP：80<br>邮件服务：25<br>TelNet：23<br>SSH：22</p>
<p>上层需要的服务，是本层无法确保的：<br>传输层不能向上一层提供时延保证</p>

        <h2 id="Web应用和HTTP协议">
          <a href="#Web应用和HTTP协议" class="heading-link"><i class="fas fa-link"></i></a>Web应用和HTTP协议</h2>
      
        <h3 id="HTTP协议">
          <a href="#HTTP协议" class="heading-link"><i class="fas fa-link"></i></a>HTTP协议</h3>
      <p>持久和非持久连接的区别：</p>

        <h3 id="RTT">
          <a href="#RTT" class="heading-link"><i class="fas fa-link"></i></a>RTT</h3>
      
        <h3 id="Cookies">
          <a href="#Cookies" class="heading-link"><i class="fas fa-link"></i></a>Cookies</h3>
      <p>作用、原理、流程<br>4个重要方面</p>

        <h3 id="web缓存">
          <a href="#web缓存" class="heading-link"><i class="fas fa-link"></i></a>web缓存</h3>
      <p>作用、流程<br>条件GET</p>

        <h2 id="电子邮件SMTP、POP3、IMAP">
          <a href="#电子邮件SMTP、POP3、IMAP" class="heading-link"><i class="fas fa-link"></i></a>电子邮件SMTP、POP3、IMAP</h2>
      <p>用户本地到服务器的连接方式</p>

        <h2 id="DNS">
          <a href="#DNS" class="heading-link"><i class="fas fa-link"></i></a>DNS</h2>
      <p>DNS服务器提供的功能：</p>

        <h3 id="DNS的查询方法">
          <a href="#DNS的查询方法" class="heading-link"><i class="fas fa-link"></i></a>DNS的查询方法</h3>
      <p>递归：<br>迭代：</p>

        <h2 id="CDN">
          <a href="#CDN" class="heading-link"><i class="fas fa-link"></i></a>CDN</h2>
      <p>作用：<br>方案：</p>

        <h1 id="运输层">
          <a href="#运输层" class="heading-link"><i class="fas fa-link"></i></a>运输层</h1>
      
        <h2 id="UDP">
          <a href="#UDP" class="heading-link"><i class="fas fa-link"></i></a>UDP</h2>
      
        <h3 id="校验和">
          <a href="#校验和" class="heading-link"><i class="fas fa-link"></i></a>校验和</h3>
      
        <h3 id="伪首部的作用">
          <a href="#伪首部的作用" class="heading-link"><i class="fas fa-link"></i></a>伪首部的作用</h3>
      
        <h2 id="可靠数据传输原理">
          <a href="#可靠数据传输原理" class="heading-link"><i class="fas fa-link"></i></a>可靠数据传输原理</h2>
      <p>Rdt1.0-3.0<br>流水线GBN<br>选择性重传SR</p>

        <h2 id="TCP">
          <a href="#TCP" class="heading-link"><i class="fas fa-link"></i></a>TCP</h2>
      
        <h3 id="报文段结构">
          <a href="#报文段结构" class="heading-link"><i class="fas fa-link"></i></a>报文段结构</h3>
      <p>20字节的固定首部</p>

        <h3 id="TCP序号和确认">
          <a href="#TCP序号和确认" class="heading-link"><i class="fas fa-link"></i></a>TCP序号和确认</h3>
      <p>填ACK，Seq<br>序号Seq：<br>数据段中第一个字节在数据流中的位置编号<br>ACK：</p>
<p>TCP估计RTT时：不计算重发的包的–忽略重传</p>

        <h3 id="连接管理">
          <a href="#连接管理" class="heading-link"><i class="fas fa-link"></i></a>连接管理</h3>
      <p>3次握手、4次挥手 释放连接</p>

        <h3 id="拥塞控制原理">
          <a href="#拥塞控制原理" class="heading-link"><i class="fas fa-link"></i></a>拥塞控制原理</h3>
      <p>场景原因</p>
<p>简述TCP拥塞控制</p>
<p>经典图<br>窗口变化，阈值变化</p>

        <h1 id="套接字编程">
          <a href="#套接字编程" class="heading-link"><i class="fas fa-link"></i></a>套接字编程</h1>
      
        <h2 id="字节序">
          <a href="#字节序" class="heading-link"><i class="fas fa-link"></i></a>字节序</h2>
      <p>网络是大端字节序</p>

        <h2 id="基本套接字函数的使用">
          <a href="#基本套接字函数的使用" class="heading-link"><i class="fas fa-link"></i></a>基本套接字函数的使用</h2>
      <p>send和rec缺省是阻塞的</p>

        <h2 id="5种I-O模式">
          <a href="#5种I-O模式" class="heading-link"><i class="fas fa-link"></i></a>5种I/O模式</h2>
      
        <h1 id="网络层">
          <a href="#网络层" class="heading-link"><i class="fas fa-link"></i></a>网络层</h1>
      
        <h2 id="虚电路和数据报网络">
          <a href="#虚电路和数据报网络" class="heading-link"><i class="fas fa-link"></i></a>虚电路和数据报网络</h2>
      <p>区别</p>

        <h2 id="路由器结构">
          <a href="#路由器结构" class="heading-link"><i class="fas fa-link"></i></a>路由器结构</h2>
      <p>3种交换结构</p>

        <h2 id="网际协议">
          <a href="#网际协议" class="heading-link"><i class="fas fa-link"></i></a>网际协议</h2>
      
        <h3 id="IP数据包分片和重组">
          <a href="#IP数据包分片和重组" class="heading-link"><i class="fas fa-link"></i></a>IP数据包分片和重组</h3>
      <p>traceroute原理:TTL</p>

        <h3 id="IP地址划分">
          <a href="#IP地址划分" class="heading-link"><i class="fas fa-link"></i></a>IP地址划分</h3>
      <p>CIDR</p>

        <h2 id="路由算法">
          <a href="#路由算法" class="heading-link"><i class="fas fa-link"></i></a>路由算法</h2>
      <p>链路状态<br>距离向量</p>

        <h1 id="链路层">
          <a href="#链路层" class="heading-link"><i class="fas fa-link"></i></a>链路层</h1>
      <h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>进程<br>服务器<br>接口</p>

        <h2 id="奇偶校验">
          <a href="#奇偶校验" class="heading-link"><i class="fas fa-link"></i></a>奇偶校验</h2>
      
        <h2 id="CRC循环冗余码计算">
          <a href="#CRC循环冗余码计算" class="heading-link"><i class="fas fa-link"></i></a>CRC循环冗余码计算</h2>
      
        <h2 id="多路访问">
          <a href="#多路访问" class="heading-link"><i class="fas fa-link"></i></a>多路访问</h2>
      <p>ALOHA(纯、时隙)<br>效率推导了解一下：求极限</p>
<p>CSMA/CD的运行机制<br>二进制指数回退算法</p>

        <h2 id="MAC、ARP">
          <a href="#MAC、ARP" class="heading-link"><i class="fas fa-link"></i></a>MAC、ARP</h2>
      <p>IP地址不变，MAC不停变化</p>

        <h2 id="交换机">
          <a href="#交换机" class="heading-link"><i class="fas fa-link"></i></a>交换机</h2>
      <p>只学习<br>VLAN 作用</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Programming</title>
    <url>/Database-Programming/</url>
    <content><![CDATA[<h1 id="数据定义SQL语句">
          <a href="#数据定义SQL语句" class="heading-link"><i class="fas fa-link"></i></a>数据定义SQL语句</h1>
      
        <h2 id="基本数据类型">
          <a href="#基本数据类型" class="heading-link"><i class="fas fa-link"></i></a>基本数据类型</h2>
      <ol>
<li>字符串型varchar(n)、char(n)<blockquote>
<p>varchar长度可变、char固定长度</p>
</blockquote>
</li>
<li>整数型int、smallint</li>
<li>定点数型numerica(p,d)<blockquote>
<p>numeric(p,d)为定点数，p 为定点数的总位数，d 为定点数的小数位数。该数据类型可以表示带小数的数值。</p>
</blockquote>
</li>
<li>浮点数型real、double(n,d)</li>
<li>货币型money</li>
<li>逻辑性bit</li>
<li>日期型date</li>
</ol>

        <h2 id="数据库定义">
          <a href="#数据库定义" class="heading-link"><i class="fas fa-link"></i></a>数据库定义</h2>
      
        <h3 id="创建数据库">
          <a href="#创建数据库" class="heading-link"><i class="fas fa-link"></i></a>创建数据库</h3>
      <figure class="highlight"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;;</span><br><span class="line">&gt; CERATE DATABASE HR;</span><br></pre></td></tr></tbody></table></div></figure>
<a id="more"></a>

        <h3 id="修改数据库">
          <a href="#修改数据库" class="heading-link"><i class="fas fa-link"></i></a>修改数据库</h3>
      <figure class="highlight"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;[[<span class="keyword">WITH</span>] <span class="keyword">option</span>[...]];</span><br><span class="line">&gt; ALTER DATABASE demoDB RENAME TO &lt;MyDemoDB&gt;;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="删除数据库">
          <a href="#删除数据库" class="heading-link"><i class="fas fa-link"></i></a>删除数据库</h3>
      <figure class="highlight"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;;</span><br><span class="line">&gt; DROP DATABASE demoDB;</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="数据库表对象的定义">
          <a href="#数据库表对象的定义" class="heading-link"><i class="fas fa-link"></i></a>数据库表对象的定义</h2>
      
        <h3 id="数据库表创建">
          <a href="#数据库表创建" class="heading-link"><i class="fas fa-link"></i></a>数据库表创建</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Student（ </span><br><span class="line">StudentID　　　　<span class="built_in">char</span>(<span class="number">13</span>)　　PRIMARY　<span class="keyword">KEY</span>, </span><br><span class="line">StudentName　　　<span class="built_in">varchar</span>(<span class="number">10</span>)　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">StudentGender　　<span class="built_in">char</span>(<span class="number">2</span>)　　　<span class="literal">NULL</span>, </span><br><span class="line">BirthDay　　　　　<span class="built_in">date</span>　　　　 <span class="literal">NULL</span>, </span><br><span class="line">Major　　　　　　 <span class="built_in">varchar</span>(<span class="number">30</span>)　<span class="literal">NULL</span>, </span><br><span class="line">StudentPhone　　 <span class="built_in">char</span>(<span class="number">11</span>)　　<span class="literal">NULL</span> </span><br><span class="line">）;</span><br></pre></td></tr></tbody></table></div></figure>

<ol>
<li><p>列约束关键词</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">PRIMARY KEY、NOT NULL、NULL 、UNIQUE、<span class="keyword">CHECK</span>、<span class="keyword">DEFAULT</span> </span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Course( </span><br><span class="line">CourseID　　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　PRIMARY　<span class="keyword">Key</span>, </span><br><span class="line">CourseName　　 <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span>　<span class="literal">NULL</span>　<span class="keyword">UNIQUE</span>, </span><br><span class="line">CourseType　　 <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="literal">NULL</span>　<span class="keyword">CHECK</span>(CourseType <span class="keyword">IN</span>(’基础课’,’专业’,’选修’)), </span><br><span class="line">CourseCredit　<span class="built_in">smallint</span>　　<span class="literal">NULL</span>, </span><br><span class="line">CoursePeriod　<span class="built_in">smallint</span>　　<span class="literal">NULL</span>, </span><br><span class="line">TestMethod　　 <span class="built_in">char</span>(<span class="number">10</span>)　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>　<span class="keyword">DEFAULT</span>　’闭卷考试’ </span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>
</li>
<li><p>表约束关键词</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">CONSTRAINT 复合主键名_PK PRIMARY Key(列名)</span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Plan(</span><br><span class="line">CourseID　　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">TeacherID　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseRoom　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">CourseTime　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">Note　　　　　<span class="built_in">varchar</span>(<span class="number">50</span>), </span><br><span class="line"><span class="keyword">CONSTRAINT</span>　　CoursePlan_PK　　PRIMARY <span class="keyword">Key</span>(CourseID,TeacherID) </span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>
</li>
<li><p>表约束定义代理键</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">serial 代理键</span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Plan(</span><br><span class="line">CoursePlanID　<span class="built_in">serial</span>　　　 <span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseID　　　<span class="built_in">char</span>(<span class="number">4</span>)　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">TeacherID　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseRoom　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">CourseTime　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">Note　　　　　<span class="built_in">varchar</span>(<span class="number">50</span>), </span><br><span class="line"><span class="keyword">CONSTRAINT</span>　　CoursePlan_PK　　PRIMARY <span class="keyword">Key</span>(CoursePlanID) </span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>
</li>
<li><p>表约束定义外键</p>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">CONSTRAINT 外键名_FK FOREIGN KEY(列名)</span><br><span class="line">REFERENCES 关联的表名(列名)</span><br><span class="line">    ON <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　<span class="keyword">Register</span>( </span><br><span class="line">    CourseRegID　　　<span class="built_in">serial</span>　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">    CoursePlanID　　 <span class="built_in">int</span>　　　 <span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">    StudentID　　　　<span class="built_in">char</span>(<span class="number">13</span>), </span><br><span class="line">    Note　　　　　　 <span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">    <span class="keyword">CONSTRAINT</span>　　　 CourseRegID_PK　　PRIMARY <span class="keyword">Key</span>(CourseRegID), <span class="keyword">CONSTRAINT</span>　　　 CoursePlanID_FK　 <span class="keyword">FOREIGN</span> <span class="keyword">Key</span>(CoursePlanID) <span class="keyword">REFERENCES</span>　Plan(CoursePlanID) </span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>, </span><br><span class="line">    <span class="keyword">CONSTRAINT</span>　　　 StudentID_FK　<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(StudentID) <span class="keyword">REFERENCES</span>　Student(StudentID) </span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> </span><br><span class="line">);</span><br></pre></td></tr></tbody></table></div></figure>


</li>
</ol>

        <h3 id="数据库表修改">
          <a href="#数据库表修改" class="heading-link"><i class="fas fa-link"></i></a>数据库表修改</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; &lt;修改方式&gt;;</span><br></pre></td></tr></tbody></table></div></figure>

<ol>
<li>ADD<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">用于增加新列或列完整性约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ADD</span> &lt;新列名称&gt;&lt;数据类型&gt;[完整性约束];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> Email <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>DROP<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">用于删除指定列或列的完整性约束条件</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;; </span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> StudentPhone;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>RENAME<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">用于修改表名称、列名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新表名&gt;; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> &lt;原列名&gt; <span class="keyword">TO</span> &lt;新列名&gt;;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>ALTER<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">用于修改列的数据类型，</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt; <span class="keyword">TYPE</span>&lt;新的数据类型&gt;;</span><br></pre></td></tr></tbody></table></div></figure>

</li>
</ol>

        <h3 id="数据库删除">
          <a href="#数据库删除" class="heading-link"><i class="fas fa-link"></i></a>数据库删除</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;;</span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>需注意：DROP TABLE 不能直接删除由 FOREIGN KEY 约束引用的表。只有先删除FOREIGN KEY约束或引用的表后，才能删除本表。</p>
</blockquote>

        <h2 id="数据表索引对象的定义">
          <a href="#数据表索引对象的定义" class="heading-link"><i class="fas fa-link"></i></a>数据表索引对象的定义</h2>
      <p><strong>索引：</strong> 是一种针对表中指定列的值进行排序的数据结构，使用它可以加快表中数据的查询。</p>
<blockquote>
<p>补充知识:<br>给表加上了主键，就相当于是有了聚集索引<br>不管以任何方式查询表，最终都会利用主键通过聚集索引来定位到数据，聚集索引（主键）是通往真实数据所在的唯一路径。<br>非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。<br>索引的数据结构有很多，包括平衡树，哈希桶等<br><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">参考资料</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="创建索引对象">
          <a href="#创建索引对象" class="heading-link"><i class="fas fa-link"></i></a>创建索引对象</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;&lt;(列名[,..,])&gt;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;&lt;（列名[,...]）&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BirthDay_Idx <span class="keyword">ON</span> Student (BirthDay);</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="修改索引对象">
          <a href="#修改索引对象" class="heading-link"><i class="fas fa-link"></i></a>修改索引对象</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新索引名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> BirthDay_Idx <span class="keyword">RENAME</span> <span class="keyword">TO</span> BDay_Idx</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="删除索引对象">
          <a href="#删除索引对象" class="heading-link"><i class="fas fa-link"></i></a>删除索引对象</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> &lt;索引名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> BirthDay_Idx;</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="数据操纵-插入、更新、删除">
          <a href="#数据操纵-插入、更新、删除" class="heading-link"><i class="fas fa-link"></i></a>数据操纵(插入、更新、删除)</h2>
      
        <h3 id="数据插入">
          <a href="#数据插入" class="heading-link"><i class="fas fa-link"></i></a>数据插入</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;基本表&gt;[&lt;列名表&gt;] <span class="keyword">VALUES</span>(列值表);</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">'2017220101105'</span>,’柳因’,’女’,<span class="string">'1999-04-23'</span>,’软件工程’, <span class="string">'liuyin@163.com'</span>);</span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>在INSERT INTO插入数据语句中，使用的interger和numeric等类型数值不使用引号标注，但char、varchar、date 和datetime等类型必须使用单引号。 </p>
</blockquote>

        <h3 id="数据更新">
          <a href="#数据更新" class="heading-link"><i class="fas fa-link"></i></a>数据更新</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;基本表&gt; </span><br><span class="line"><span class="keyword">SET</span> &lt;列名<span class="number">1</span>&gt;=&lt;表达式<span class="number">1</span>&gt; [,&lt;列名<span class="number">2</span>&gt;=&lt;表达式<span class="number">2</span>&gt;...] </span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">UPDATE</span> Student </span><br><span class="line"><span class="keyword">SET</span> Email=<span class="string">'zhaodong@163.com'</span> </span><br><span class="line"><span class="keyword">WHERE</span> StudentName=’赵东’;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="数据删除">
          <a href="#数据删除" class="heading-link"><i class="fas fa-link"></i></a>数据删除</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; </span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> StudentName=’张亮’;</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="数据查询">
          <a href="#数据查询" class="heading-link"><i class="fas fa-link"></i></a>数据查询</h2>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列&gt;[,&lt;目标列&gt;…] </span><br><span class="line">[ <span class="keyword">INTO</span> &lt;新表&gt; ] </span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;[,&lt;表名&gt;…] </span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ] </span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt; ] </span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>（1）SELECT子句：作为SELECT语句的必要子句，用来指明从数据库表中需要查询的目标列。ALL关键词是查询 默认操作，即从表中获取满足条件的所有数据行；DISTINCT关键词用来去掉结果集中的重复数据行；&lt;目标列&gt;为被 查询表的指定列名，可以有多个。若查询表中所有列，一般使用*号表示。<br>（2）INTO子句：用来将被查询的结果集数据插入新表。<br>（3）FROM子句：用来指定被查询的数据来自哪个表或哪些表。若有多表，使用逗号分隔。<br>（4）WHERE子句：用来给出查询的检索条件。只有满足条件的数据行才允许被检索出来。<br>（5）GROUP BY子句：用来对查询结果进行分组，并进行分组统计等处理。在分组中，还可以使用HAVING关键 词定义分组条件。<br>（6）ORDER BY子句：用来对查询结果集进行排序。ASC关键词约定按指定列的数值升序排列查询结果集。DESC 关键词约定按指定列的数值降序排列查询结果集。若子句中没有给出排序关键词，默认按升序排列查询结果集</p>
</blockquote>

        <h3 id="内置函数">
          <a href="#内置函数" class="heading-link"><i class="fas fa-link"></i></a>内置函数</h3>
      <ol>
<li>聚合函数<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/10/t71ljg.png" alt="t71ljg.png">
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 学生人数 <span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(Major) <span class="keyword">AS</span> 学生专业数 <span class="keyword">FROM</span> Student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> Major) <span class="keyword">AS</span> 学生专业数 <span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(BirthDay) <span class="keyword">AS</span> 最大年龄出生日期， <span class="keyword">Max</span>(BirthDay) <span class="keyword">AS</span> 最小年龄出生日期 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></tbody></table></div></figure></li>
<li>算数函数<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/10/t78nl8.png" alt="t78nl8.png">
      </li>
<li>字符串函数</li>
<li>时间日期函数</li>
<li>数据类型转换函数</li>
</ol>

        <h3 id="子查询">
          <a href="#子查询" class="heading-link"><i class="fas fa-link"></i></a>子查询</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TeacherID, TeacherName, TeacherTitle </span><br><span class="line"><span class="keyword">FROM</span> Teacher </span><br><span class="line"><span class="keyword">WHERE</span> CollegeID <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> CollegeID </span><br><span class="line"><span class="keyword">FROM</span> College <span class="keyword">WHERE</span> </span><br><span class="line">CollegeName=’计算机学院’) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TeacherID；</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="数据控制">
          <a href="#数据控制" class="heading-link"><i class="fas fa-link"></i></a>数据控制</h2>
      
        <h3 id="GRANT赋予权限">
          <a href="#GRANT赋予权限" class="heading-link"><i class="fas fa-link"></i></a>GRANT赋予权限</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限列表&gt; <span class="keyword">ON</span> &lt;数据库对象&gt; <span class="keyword">TO</span> &lt;用户或角色&gt; [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> ];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">Register</span> <span class="keyword">TO</span> <span class="keyword">RoleS</span>;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="REVOKE收回权限">
          <a href="#REVOKE收回权限" class="heading-link"><i class="fas fa-link"></i></a>REVOKE收回权限</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限列表&gt; <span class="keyword">ON</span> &lt;数据库对象&gt; <span class="keyword">FROM</span> &lt;用户或角色&gt; ;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">Register</span> <span class="keyword">FROM</span> <span class="keyword">RoleS</span>;</span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="DENY拒绝授权">
          <a href="#DENY拒绝授权" class="heading-link"><i class="fas fa-link"></i></a>DENY拒绝授权</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">DENY &lt;权限列表&gt; ON &lt;数据库对象&gt; TO &lt;用户或角色&gt; ;</span><br><span class="line">&gt;</span><br><span class="line">DENY <span class="keyword">DELETE</span> <span class="keyword">ON</span> Teacher <span class="keyword">TO</span> RoleT;</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="视图">
          <a href="#视图" class="heading-link"><i class="fas fa-link"></i></a>视图</h2>
      
        <h3 id="视图创建">
          <a href="#视图创建" class="heading-link"><i class="fas fa-link"></i></a>视图创建</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> &lt;视图名&gt;[(列名<span class="number">1</span>),(列名<span class="number">2</span>),…] <span class="keyword">AS</span> &lt;<span class="keyword">SELECT</span>查询&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BasicCourseView <span class="keyword">AS</span> <span class="keyword">SELECT</span> CourseName, </span><br><span class="line">CourseCredit, CoursePeriod, TestMethod </span><br><span class="line"><span class="keyword">FROM</span> Course </span><br><span class="line"><span class="keyword">WHERE</span> CourseType=’基础课’;</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="视图删除">
          <a href="#视图删除" class="heading-link"><i class="fas fa-link"></i></a>视图删除</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> &lt;视图名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BasicCourseView;</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="视图使用">
          <a href="#视图使用" class="heading-link"><i class="fas fa-link"></i></a>视图使用</h3>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> DataBaseCourseView <span class="keyword">AS</span> <span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称， S.StudentID <span class="keyword">AS</span> 学号， S.StudentName <span class="keyword">AS</span> 姓名 </span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">AS</span> C, Plan <span class="keyword">AS</span> P, <span class="keyword">Register</span> <span class="keyword">AS</span> R, Student <span class="keyword">AS</span> S </span><br><span class="line"><span class="keyword">WHERE</span> C.CourseID=P.CourseID <span class="keyword">AND</span> C. CourseName=’数据库原理及应用’ <span class="keyword">AND</span> P.CoursePlanID=R.CoursePlanID <span class="keyword">AND</span> R.StudentID=S.StudentID; </span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DataBaseCourseView;</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="数据库应用编程">
          <a href="#数据库应用编程" class="heading-link"><i class="fas fa-link"></i></a>数据库应用编程</h1>
      
        <h2 id="存储过程编程">
          <a href="#存储过程编程" class="heading-link"><i class="fas fa-link"></i></a>存储过程编程</h2>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span> ] <span class="keyword">FUNCTION</span> </span><br><span class="line">    <span class="keyword">name</span> ( [ [ argmode ] [ argname ] argtype [ { <span class="keyword">DEFAULT</span> | = } default_expr ] [, ...] ] ) </span><br><span class="line">    [ <span class="keyword">RETURNS</span> retype | <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( column_name column_type [, ...] ) ] </span><br><span class="line"><span class="keyword">AS</span> $$ <span class="keyword">DECLARE</span> </span><br><span class="line">    <span class="comment">-- 声明段 </span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">--函数体语句 </span></span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">$$ LANGUAGE lang_name;</span><br></pre></td></tr></tbody></table></div></figure>
<blockquote>
<p>（1）OR REPLACE：如果没有该名称，则创建存储过程。当数据库中存在该存储过程时，如果创建存储过程的语 句没有关键字OR REPLACE，数据库将给出类似“该存储过程已经存在，不能创建该存储过程”的警示信息；如果创 建存储过程的语句有关键字OR REPLACE，则将旧的存储过程替换为新创建的存储过程。<br>（2）name：要创建的存储过程名。<br>（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，默认值是IN。IN声明参数为输入参数，向存储过 程内部传值；OUT声明参数为输出参数，存储过程对参数值的修改在存储过程之外是可见的，类似其他语言将函数的 形式参数声明为引用；INOUT声明该参数既是输入参数，同时又是输出参数。<br>（4）argname：形式参数的名称。<br>（5）argtype：该函数返回值的数据类型。可以是基本类型，也可以是复合类型、域类型或者与数据库字段相同的 类型。字段类型用 table_name.column_name%TYPE 表示，使用字段类型声明变量的数据类型，数据库表的类型变化不 会影响存储过程的执行。<br>（6）default_expr：指定参数默认值的表达式，该表达式的类型必须是可转化为参数的类型。只有IN和INOUT模式 的参数才能有默认值，具有默认值的输入参数必须出现在参数列表的最后。<br>（7）retype：指示 RETURNS 返回值的数据类型。可以声明为基本类型、复合类型、域类型或者表的字段类型。 如果存储没有返回值，可以指定void作为返回类型。如果存在OUT或INOUT参数，那么可以省略RETURNS子句。<br>（8）RETURNS TABLE：指示存储过程返回值的类型是由多列构成的二维表，表的列名由 column_name 指定，每 个列的数据类型由 column_type 指明；如果存储过程返回值由RETURNS TABLE指定，存储过程就不能有OUT和 INOUT模式的参数。 （9）AS $$：用于声明存储过程的实际代码的开始，当编译器扫描遇到下一个 的时候，则表明代码的结束。<br>（10）DECLARE:PL/pgSQL 指示声明存储过程的局部变量，后续内容将介绍如何定义存储过程的局部变量。<br>（11）BEGIN…END：用来定义存储过程的执行体语句。<br>（12）LANGUAGE：在关键字后面由lang_name指明存储过程所使用的编程语言，同时标志存储过程的结束。例 如：LANGUAGE plpgsql 告诉编译器该存储过程是使用PL/pgSQL实现的。</p>
</blockquote>
<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> countRecords () </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">integer</span> <span class="keyword">AS</span> $<span class="keyword">count</span>$ </span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    <span class="keyword">count</span> <span class="built_in">integer</span>; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">INTO</span> <span class="keyword">count</span> <span class="keyword">FROM</span> Student; </span><br><span class="line">    RETURN count; </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">$ count $ LANGUAGE plpgsql;</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="触发器编程">
          <a href="#触发器编程" class="heading-link"><i class="fas fa-link"></i></a>触发器编程</h2>
      <figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">CONSTRAINT</span>] <span class="keyword">TRIGGER</span> <span class="keyword">name</span> </span><br><span class="line">{ <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> | INSTEAD <span class="keyword">OF</span> } { <span class="keyword">event</span> [ <span class="keyword">OR</span> ...] } </span><br><span class="line"><span class="keyword">ON</span> table_name </span><br><span class="line">[ <span class="keyword">FROM</span> referenced_table_name ] </span><br><span class="line">[ <span class="keyword">FOR</span> [ <span class="keyword">EACH</span> ] { <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> } ] </span><br><span class="line">[ <span class="keyword">WHEN</span> (condition) ]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name ( arguments )</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="创建触发器">
          <a href="#创建触发器" class="heading-link"><i class="fas fa-link"></i></a>创建触发器</h3>
      <ol>
<li>存在所依赖的表或视图</li>
<li>编写触发器函数<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> score_audit() </span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $score_audit$ </span><br><span class="line">    <span class="keyword">BEGIN</span> </span><br><span class="line">        <span class="keyword">IF</span> (TG_OP = <span class="string">'DELETE'</span>) <span class="keyword">THEN</span> </span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Audit_score </span><br><span class="line">            <span class="keyword">SELECT</span> <span class="keyword">user</span>, old.sid, old.cid, <span class="keyword">now</span>(), OLD.score ; </span><br><span class="line">            RETURN OLD; </span><br><span class="line">        ELSIF (TG_OP = '<span class="keyword">UPDATE</span><span class="string">') THEN </span></span><br><span class="line"><span class="string">            INSERT INTO Audit_score </span></span><br><span class="line"><span class="string">            SELECT user, old.sid, old.cid, now(), OLD.score , new.score</span></span><br><span class="line"><span class="string">            where old.sid=new.sid and old.cid=new.cid; </span></span><br><span class="line"><span class="string">            RETURN NEW; </span></span><br><span class="line"><span class="string">        ELSIF (TG_OP = '</span><span class="keyword">INSERT</span><span class="string">') THEN </span></span><br><span class="line"><span class="string">            INSERT INTO Audit_score </span></span><br><span class="line"><span class="string">            SELECT user, new.sid, new.cid, now(),null, new.score; RETURN NEW; </span></span><br><span class="line"><span class="string">        END IF; </span></span><br><span class="line"><span class="string">        RETURN NULL; </span></span><br><span class="line"><span class="string">    END; </span></span><br><span class="line"><span class="string">$score_audit$ LANGUAGE plpgsql;</span></span><br></pre></td></tr></tbody></table></div></figure></li>
<li>指明触发的条件信息<figure class="highlight sql"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> score_audit_trigger </span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> Stu_score </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> score_audit();</span><br></pre></td></tr></tbody></table></div></figure></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System(1)</title>
    <url>/Operating-System-1/</url>
    <content><![CDATA[<h1 id="概述">
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      
        <h2 id="操作系统的目标和作用">
          <a href="#操作系统的目标和作用" class="heading-link"><i class="fas fa-link"></i></a>操作系统的目标和作用</h2>
      
        <h3 id="目标">
          <a href="#目标" class="heading-link"><i class="fas fa-link"></i></a>目标</h3>
      <p>方便性、有效性、可扩充性、开放性。</p>

        <h3 id="作用">
          <a href="#作用" class="heading-link"><i class="fas fa-link"></i></a>作用</h3>
      <ol>
<li>作为用户与计算机硬件之间的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象<a id="more"></a>

</li>
</ol>

        <h2 id="操作系统的发展过程">
          <a href="#操作系统的发展过程" class="heading-link"><i class="fas fa-link"></i></a>操作系统的发展过程</h2>
      
        <h3 id="批处理系统">
          <a href="#批处理系统" class="heading-link"><i class="fas fa-link"></i></a>批处理系统</h3>
      <p>主要动力是提高资源利用率和系统吞吐量。<br>批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。<br>批处理系统分为单道批处理系统和多道批处理系统。</p>
<ol>
<li>单道批处理系统<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/11/tqmjI0.png" alt="tqmjI0.png">
      <br>在内存中始终仅存一道作业运行。</li>
<li>多道批处理系统<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/11/tqnwLj.png" alt="tqnwLj.png">
      </li>
</ol>

        <h3 id="分时系统">
          <a href="#分时系统" class="heading-link"><i class="fas fa-link"></i></a>分时系统</h3>
      <p>主要动力是满足用户对人机交互的需求。<br>系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机的资源。<br>主要特征：多路性(多个用户)、独立性、及时性、交互性。</p>

        <h3 id="实时系统">
          <a href="#实时系统" class="heading-link"><i class="fas fa-link"></i></a>实时系统</h3>
      <p>系统能及时相应外部的请求，在规定时间内完成对该事件的处理。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>

        <h2 id="基本特征">
          <a href="#基本特征" class="heading-link"><i class="fas fa-link"></i></a>基本特征</h2>
      
        <h3 id="1-并发">
          <a href="#1-并发" class="heading-link"><i class="fas fa-link"></i></a>1.并发</h3>
      <p>并发性是指两个或多个事件在同一时间间隔内发生，并行性是指两个或多个事件在同一时刻发生。<br>并行是真正的同时，需要硬件支持；<br>并发是看起来的同时，可以通过时间片轮转调度进程来实现。</p>

        <h3 id="2-共享">
          <a href="#2-共享" class="heading-link"><i class="fas fa-link"></i></a>2.共享</h3>
      <p>共享是指系统中的资源可供内存中多个并发执行的进程共同使用。<br>有两种共享方式：互斥共享和实时共享。<br>互斥共享的资源称为临界资源，在一段时间内只允许一个进程访问的资源，如打印机等。</p>

        <h3 id="3-虚拟">
          <a href="#3-虚拟" class="heading-link"><i class="fas fa-link"></i></a>3.虚拟</h3>
      <p>虚拟是把一个物理实体变为若干个逻辑实体。<br>有两种虚拟技术：时分复用和空分复用。<br>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。<br>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>

        <h3 id="4-异步">
          <a href="#4-异步" class="heading-link"><i class="fas fa-link"></i></a>4.异步</h3>
      <p>异步是指进程不是一次性执行完毕，而是停停走走。</p>

        <h2 id="主要功能">
          <a href="#主要功能" class="heading-link"><i class="fas fa-link"></i></a>主要功能</h2>
      
        <h3 id="1-进程管理">
          <a href="#1-进程管理" class="heading-link"><i class="fas fa-link"></i></a>1.进程管理</h3>
      <p>进程控制、进程同步、进程通信、进程调度等。</p>

        <h3 id="2-内存管理">
          <a href="#2-内存管理" class="heading-link"><i class="fas fa-link"></i></a>2.内存管理</h3>
      <p>内存分配、内存保护、地址映射、内存扩充等。</p>

        <h3 id="3-设备管理">
          <a href="#3-设备管理" class="heading-link"><i class="fas fa-link"></i></a>3.设备管理</h3>
      <p>缓冲管理、设备分配、设备处理等。</p>

        <h3 id="4-文件管理">
          <a href="#4-文件管理" class="heading-link"><i class="fas fa-link"></i></a>4.文件管理</h3>
      <p>文件存储空间的管理、目录管理、文件读/写管理和保护等。</p>
<p><strong>参考资料：</strong></p>
<ol>
<li>汤小丹、梁红兵、哲风屏、汤子瀛 计算机操作系统(第四版)：西安电子科技大学出版社</li>
<li><span class="exturl"><a class="exturl__link" href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%951" target="_blank" rel="noopener">CS-Notes</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>How to write a summary</title>
    <url>/How-to-write-a-summary/</url>
    <content><![CDATA[<h1 id="Introduction">
          <a href="#Introduction" class="heading-link"><i class="fas fa-link"></i></a>Introduction</h1>
      <p>撰写读后摘要是2018级专用英语期末笔试写作部分的第一题，满分10分，占总分10%。 题目要求考生先阅读一篇长度为 300-350 词的短文，然后概括、浓缩其主旨大意及主要内容， 并撰写一篇长度 100-120 词的摘要。阅读短文主要涉及议论性、说明性和学术性内容</p>

        <h1 id="Find-out-theme-of-article">
          <a href="#Find-out-theme-of-article" class="heading-link"><i class="fas fa-link"></i></a>Find out theme of article</h1>
      <p>用一段话来高度概括文章的主要内容(两分)<br>This article addresses the issue of …</p>
<a id="more"></a>

        <h1 id="Structure">
          <a href="#Structure" class="heading-link"><i class="fas fa-link"></i></a>Structure</h1>
      <p>分析文章的结构，按逻辑顺序概括出每部分的大意和关键信息。<br>提取主要信息，删减次要信息，注意不要遗漏原文的主要观点和关键信息。</p>

        <h1 id="Not-Copy">
          <a href="#Not-Copy" class="heading-link"><i class="fas fa-link"></i></a>Not Copy</h1>
      <p>千万不要照抄原文。<br>重述原文的重要信息，用自己的话替换原文的语言结构和表达方式，不允许照抄、摘录或者引用连续5个词以上的原文。</p>

        <h1 id="Neutral-Opinion">
          <a href="#Neutral-Opinion" class="heading-link"><i class="fas fa-link"></i></a>Neutral Opinion</h1>
      <p>必须要客观，不要出现 I think之类的。<br>准确理解原文的意思和观点，写作时不要添加新的信息和与原文无关的信息，不要偷换概念， 也不要评论原文的观点。 </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>商务英语</category>
      </categories>
      <tags>
        <tag>商务英语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络系列(1)--计算机网络和因特网</title>
    <url>/Computer-Network-and-Internet/</url>
    <content><![CDATA[<h1 id="计算机网络和Internet发展史">
          <a href="#计算机网络和Internet发展史" class="heading-link"><i class="fas fa-link"></i></a>计算机网络和Internet发展史</h1>
      <blockquote>
<ol>
<li>分组交换原理的早期发展与演化：1961-1972</li>
<li>网际互连与新兴的专属网络：1972-1980</li>
<li>TCP/IP新协议与网络数量激增：1980-1990</li>
<li>商业化, Web, 新的网络应用：1990-2000</li>
<li>移动互联网：21世纪10年代中期——至今</li>
</ol>
</blockquote>

        <h1 id="什么是Internet？">
          <a href="#什么是Internet？" class="heading-link"><i class="fas fa-link"></i></a>什么是Internet？</h1>
      
        <h2 id="计算机网络">
          <a href="#计算机网络" class="heading-link"><i class="fas fa-link"></i></a>计算机网络</h2>
      <p><strong>计算机网络：</strong> 两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。<br><strong>两大功能：</strong> 连通性和共享</p>
<a id="more"></a>

        <h2 id="Internet">
          <a href="#Internet" class="heading-link"><i class="fas fa-link"></i></a>Internet</h2>
      <p><strong>由网络构成的网络</strong></p>
<p><strong>具体构成描述：</strong></p>
<ol>
<li>数以亿计的计算互联设备：主机、应用程序</li>
<li>通信链路：双绞线、光纤、卫星</li>
<li>分组交换：路由器和交换机</li>
</ol>
<p><strong>服务上描述：</strong></p>
<ol>
<li>提供网络应用基础架构</li>
<li>为分布式应用程序提供的通信服务接口<ul>
<li>无连接服务connectionless</li>
<li>面向连接服务connection-oriented</li>
<li>不提供数据传递时间保证（发送端到接收端）的服务</li>
</ul>
</li>
</ol>

        <h2 id="协议–划重点">
          <a href="#协议–划重点" class="heading-link"><i class="fas fa-link"></i></a>协议–划重点</h2>
      <p><strong>协议：</strong>定义了两个或多个通信实体间所交换报文的<strong>格式和次序</strong>，以及在报文发送/或接收或者其他事件方面所采取的<strong>行动（响应）</strong>。</p>

        <h2 id="RFC文档">
          <a href="#RFC文档" class="heading-link"><i class="fas fa-link"></i></a>RFC文档</h2>
      <ul>
<li>所有的因特网标准都以RFC（<strong>Request For Comments</strong>,请求评论）的形式在因特网上发表。</li>
<li>正式标准要经历四个阶段：<ol>
<li>因特网草案（Internet Draft）－不是RFC文档</li>
<li>建议标准（Proposed Standard） －开始成为RFC文档</li>
<li>草案标准（Draft Standard）</li>
<li>因特网标准（Internet Standard）<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/31/t3CKat.png" alt="t3CKat.png">
      <br><span class="exturl"><a class="exturl__link" href="http://www.rfceditor.org/RFCoverview.html" target="_blank" rel="noopener">详细介绍</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
</li>
</ul>
<p><strong>协议的基本要素：语法、语义和同步</strong></p>

        <h1 id="网络边缘部分">
          <a href="#网络边缘部分" class="heading-link"><i class="fas fa-link"></i></a>网络边缘部分</h1>
      
        <h1 id="网络核心部分">
          <a href="#网络核心部分" class="heading-link"><i class="fas fa-link"></i></a>网络核心部分</h1>
      
        <h1 id="Internet主干-ISPs的结构组成">
          <a href="#Internet主干-ISPs的结构组成" class="heading-link"><i class="fas fa-link"></i></a>Internet主干/ISPs的结构组成</h1>
      
        <h1 id="分组交换网络中延迟和丢失">
          <a href="#分组交换网络中延迟和丢失" class="heading-link"><i class="fas fa-link"></i></a>分组交换网络中延迟和丢失</h1>
      
        <h1 id="协议层及其服务模型">
          <a href="#协议层及其服务模型" class="heading-link"><i class="fas fa-link"></i></a>协议层及其服务模型</h1>
      
        <h1 id="攻击威胁下的网络">
          <a href="#攻击威胁下的网络" class="heading-link"><i class="fas fa-link"></i></a>攻击威胁下的网络</h1>
      <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（三）-- 垃圾收集基础(GC)</title>
    <url>/Garbage-Collection/</url>
    <content><![CDATA[<h1 id="概述">
          <a href="#概述" class="heading-link"><i class="fas fa-link"></i></a>概述</h1>
      
        <h2 id="起源">
          <a href="#起源" class="heading-link"><i class="fas fa-link"></i></a>起源</h2>
      <p><strong>误解:</strong> 垃圾收集(Garbage Collection,简称GC)是Java语言的伴生产物。<br>事实上，垃圾收集的历史远远比Java久远，在1960年诞生于麻省理工学院的Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾收集需要完成的三件事情：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？<a id="more"></a>

</li>
</ul>

        <h2 id="Why-need-it？">
          <a href="#Why-need-it？" class="heading-link"><i class="fas fa-link"></i></a>Why need it？</h2>
      <p>经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解垃圾收集和内存分配？</p>
<p><strong>答案很简单：</strong>当需要排查<strong>各种内存溢出、内存泄漏问题</strong>时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>

        <h2 id="对象">
          <a href="#对象" class="heading-link"><i class="fas fa-link"></i></a>对象</h2>
      <p>我们在系列2中学习了Java内存运行各个区域，分别为<strong>程序计数器、虚拟机栈、本地方法栈、Java堆、方法区</strong>。(<em>如果忘记了，快回头复习</em>)</p>
<p>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而<strong>Java堆和方法区</strong>有很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这个不分内存的分配和回收是动态的。<strong>这也就是GC所关注的对象！</strong><br>这里我们就回答了之前提出的第一个问题 – 哪些内存需要回收。</p>

        <h1 id="判断对象生死">
          <a href="#判断对象生死" class="heading-link"><i class="fas fa-link"></i></a>判断对象生死</h1>
      <p>在垃圾收集器对内存进行回收时，第一步就是要判断对象的状态。</p>

        <h2 id="引用计数算法">
          <a href="#引用计数算法" class="heading-link"><i class="fas fa-link"></i></a>引用计数算法</h2>
      <p><strong>引用计数算法：</strong><br>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；<br>当引用失效时，计数器值就减一；<br>任何时刻计算器为零的对象就是不可能再被使用的。</p>
<p><em>这种方法是我编程中最常用的了，这里被狠狠地打脸了。</em><br>这个算法面临的问题：<strong>无法解决对象之间相互循环引用的问题。</strong></p>
<blockquote>
<p>即 <code>objA.instance = objB; objB.instance = objA;</code>objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。<br>(可以好好思考一下)</p>
</blockquote>

        <h2 id="可达性分析算法">
          <a href="#可达性分析算法" class="heading-link"><i class="fas fa-link"></i></a>可达性分析算法</h2>
      <p><strong>基本思路：</strong> 当前对象到根对象(GC Roots)是否是可达的 <em>(图论知识)</em></p>
<ul>
<li>从 “GC Roots” 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；</li>
<li>从 “GC Roots” 开始，不可达的对象被判为不可用。</li>
</ul>
<blockquote>
<p>如下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p>
</blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/31/tl4Qv4.png" alt="tl4Qv4.png">
      </p>

        <h3 id="Java中可作为GC-Roots的对象">
          <a href="#Java中可作为GC-Roots的对象" class="heading-link"><i class="fas fa-link"></i></a>Java中可作为GC Roots的对象</h3>
      <ol>
<li>栈中(本地变量表中的Reference)<ul>
<li>虚拟机栈中，栈帧中的本地变量表所引用的对象；</li>
<li>本地方法栈中，JNI引用的对象(native方法)</li>
</ul>
</li>
<li>方法区中<ul>
<li>类的静态属性引用的对象；</li>
<li>常量引用的对象；<blockquote>
<p>这上面的对象没搞懂</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。</p>

        <h2 id="引用">
          <a href="#引用" class="heading-link"><i class="fas fa-link"></i></a>引用</h2>
      <p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。</p>
<p>在JDK 1.2版以前，Java里面的引用是很传统的<strong>定义：</strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。–<em>我自己的以往理解也是这样的</em></p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软引用（SoftReference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强度依次逐渐减弱。</p>

        <h3 id="4种引用">
          <a href="#4种引用" class="heading-link"><i class="fas fa-link"></i></a>4种引用</h3>
      <ol>
<li><strong>强引用：</strong> 像<code>Object obj = new Object()</code>这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用：</strong> 用来描述还有用但非必须的对象。对于软引用对象，在OOM（OutOfMemory)前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就OOM。实现类：<code>SoftReference</code>。</li>
<li><strong>弱引用：</strong> 跟软引用类似，比它更弱一点。被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。实现类：<code>WeakReference</code>。</li>
<li><strong>虚引用：</strong> 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。唯一作用就是为了能在这个对象被收集器回收时收到一个系统通知。实现类：<code>PhantomReference</code>。</li>
</ol>

        <h2 id="To-be-or-not-to-be">
          <a href="#To-be-or-not-to-be" class="heading-link"><i class="fas fa-link"></i></a>To be or not to be?</h2>
      <p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li><strong>第一次标记：</strong> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；</li>
<li><strong>第二次标记：</strong> 筛选此对象是否有必要执行<code>finalize()</code>方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li>
</ol>

        <h3 id="finalize方法">
          <a href="#finalize方法" class="heading-link"><i class="fas fa-link"></i></a>finalize方法</h3>
      <p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<blockquote>
<p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。<br>这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p>
</blockquote>
<p><strong>存活方式：</strong><br>如果对象要在finalize()中成功拯救自己–只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；</p>
<blockquote>
<p>finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。</p>
</blockquote>

        <h2 id="回收方法区">
          <a href="#回收方法区" class="heading-link"><i class="fas fa-link"></i></a>回收方法区</h2>
      <blockquote>
<p>方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
</blockquote>
<p>回收的内容：<strong>废弃的常量和不再使用的类型</strong></p>
<ul>
<li><strong>废弃常量：</strong> 例如一个字符串”abc”，当没有任何引用指向”abc”时，它就是废弃常量了。</li>
<li><strong>无用的类：</strong> 同时满足一下3个条件的类。<ol>
<li>该类的所有实例已被回收，Java堆中不存在该类的任何实例；</li>
<li>加载该类的Classloader已被回收；</li>
<li>该类的Class对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。</li>
</ol>
</li>
</ul>

        <h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>今天的垃圾收集基础部分算是写完，本来打算把算法部分也讲了，但是发现算法部分另起一篇的效果更好一点，同时打算补一篇Java基础，发现自己上学期学的Java遗忘的比较厉害了，而且上学期学的时候也没有学全，再拿来复习学习一下比较好。然后我发现自己对内存管理里面的数据区域了解的太少了，遇到了总是弄不清楚。  </p>
<p><strong>热爱未知，比如宇宙和清晨</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/31/t1Spex.png" alt="image">
      </p>
<p>参考资料：<br><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86(GC).md" target="_blank" rel="noopener">Github</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>《深入理解java虚拟机》</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法篇(一) -- 红黑树</title>
    <url>/Data-Structure-and-Algorithms-1/</url>
    <content><![CDATA[<h1 id="红黑树原理">
          <a href="#红黑树原理" class="heading-link"><i class="fas fa-link"></i></a>红黑树原理</h1>
      
        <h2 id="二叉查找树">
          <a href="#二叉查找树" class="heading-link"><i class="fas fa-link"></i></a>二叉查找树</h2>
      <p>二叉查找树具有以下的特性：</p>
<ol>
<li>某节点的左子树节点值仅包含小于该节点值</li>
<li>某节点的右子树节点值仅包含大于该节点值</li>
<li>左右子树每个也必须是二叉查找树</li>
</ol>
<p>简单的讲：<em>越小的放在越左边</em>。</p>
<a id="more"></a>
<p><strong>你以为的二叉查找树</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQrsc6.png" alt="image">
      <br><strong>变态的二叉查找树</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQrfNd.png" alt="image">
      <br>这种畸形的二叉查找树就会退化成<strong>链表</strong>，查找节点的时间复杂度就会从<strong>O($ log_2^n $)退化成O(n)</strong>。而根据我们在小学二年级就学过的[去除顶端优势]，我们引入了红黑树，达到树的平衡。</p>

        <h2 id="红黑树简介">
          <a href="#红黑树简介" class="heading-link"><i class="fas fa-link"></i></a>红黑树简介</h2>
      <p><strong>R-B Tree</strong>，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的<strong>二叉查找树</strong>。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>

        <h3 id="特性">
          <a href="#特性" class="heading-link"><i class="fas fa-link"></i></a>特性</h3>
      <ol>
<li>每个节点或者是黑色，或者是红色。(<em>没啥用</em>)</li>
<li>根节点是<strong>黑色</strong>。</li>
<li><em>每个叶子节点是黑色的</em>。</li>
<li><strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong></li>
<li><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong><blockquote>
<p>第5点确保没有一条路径会比其他路径长出两倍。</p>
</blockquote>
</li>
</ol>
<p>示意图如下：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQs3UH.png" alt="image">
      </p>

        <h3 id="应用">
          <a href="#应用" class="heading-link"><i class="fas fa-link"></i></a>应用</h3>
      <p>主要是用来储存有序的数据，时间复杂度为O($log_2^n$)，效率非常高。<br>例如：Java集合中的<strong>TreeSet、TreeMap</strong>，C++ STL中的<strong>set、map</strong>，以及Linux中<strong>虚拟内存</strong>的管理等。</p>

        <h1 id="Recolor-and-Rotation">
          <a href="#Recolor-and-Rotation" class="heading-link"><i class="fas fa-link"></i></a>Recolor and Rotation</h1>
      <p><strong>Recolor:</strong> 重新标记节点为黑色或红色<br><strong>Rotation:</strong> 旋转，达到树的平衡</p>

        <h2 id="插入">
          <a href="#插入" class="heading-link"><i class="fas fa-link"></i></a>插入</h2>
      <p>当我们插入一个新的节点X时，要遵循如下公式：</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果X是根节点，则标记为黑色</li>
<li>如果X的parent不是黑色，同时X也不是root:<ul>
<li>如果X的uncle是红色<ol>
<li>将parent和uncle标记为黑色</li>
<li>将grand parent 标记为红色</li>
<li>让X的颜色和grand parent的颜色相同，重复2.3步骤</li>
</ol>
</li>
<li>如果X的uncle是黑色<ol>
<li>左左</li>
<li>左右</li>
<li>右右</li>
<li>右左</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>第一个左指的是parent节点是在grand parent的左边还是右边<br>第二个左指的是此节点X是在parent的左边还是右边        </p>
</blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQsY8I.png" alt="image">
      </p>
<p>跟着上面的公式走:</p>
<ol>
<li>将新插入的 X 节点标记为红色</li>
<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>
<li>发现 X 的 uncle (U) 同样为红色</li>
<li>将 P 和 U 标记为黑色</li>
<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>
<li>发现 G 是根结点，标记为黑色</li>
<li>结束</li>
</ol>

        <h3 id="左左">
          <a href="#左左" class="heading-link"><i class="fas fa-link"></i></a>左左</h3>
      <p><strong>p在g的左边，x在p的左边</strong></p>
<ol>
<li>右旋g</li>
<li>交换g和p的颜色<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQsdr8.png" alt="image">
      </li>
</ol>

        <h3 id="左右">
          <a href="#左右" class="heading-link"><i class="fas fa-link"></i></a>左右</h3>
      <ol>
<li>左旋p</li>
<li>变成左左了<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQsDaQ.png" alt="image">
      </li>
</ol>

        <h3 id="右右">
          <a href="#右右" class="heading-link"><i class="fas fa-link"></i></a>右右</h3>
      <ol>
<li>左旋g</li>
<li>交换g和p的颜色<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQsc2q.png" alt="image">
      </li>
</ol>

        <h3 id="右左">
          <a href="#右左" class="heading-link"><i class="fas fa-link"></i></a>右左</h3>
      <ol>
<li>右旋p</li>
<li>变成右右了<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQsWrT.png" alt="image">
      </li>
</ol>

        <h2 id="案例演示">
          <a href="#案例演示" class="heading-link"><i class="fas fa-link"></i></a>案例演示</h2>
      <p>插入 10，20，30，15 到一个空树中</p>
<ol>
<li>向空树中第一次插入数字 10，肯定是 root 节点</li>
<li>root 节点标记成黑色<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://image-static.segmentfault.com/313/178/313178228-5d37b7346452f_articlex" alt="image">
      </li>
<li>向树中插入新节点 20，标记为红色</li>
<li>20 &gt; 10，并发现 10 没有叶子节点，将新节点 20 作为 10 的右孩子<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://image-static.segmentfault.com/310/491/310491414-5d37b7319f447_articlex" alt="image">
      </li>
<li>向树中插入新节点 30，标记为红色</li>
<li>30 &gt; 10，查找 10 的右子树，找到 20</li>
<li>30 &gt; 20，继续查找 20 的右子树，发现 20 没有叶子节点，将值插在此处</li>
<li>30 和 20 节点都为红色，30 为右孩子，20 也为右孩子，触发了<strong>右右情况</strong></li>
<li>通过一次旋转，提起 20 节点</li>
<li>20 节点是根结点，标记为黑色<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://image-static.segmentfault.com/386/112/3861123538-5d37b733ce90e_articlex" alt="image">
      </li>
<li>向树中插入新节点 15，标记为红色</li>
<li>通过比对大小和判断是否有叶子节点，最终插值为 10 节点的右孩子</li>
<li>15 和 10 节点都为红色，15 的 uncle 节点 30 也为红色</li>
<li>按照公式，将 15 的 parent 10 和 uncle 30 更改为黑色</li>
<li>让 15 节点 grand parent 20 的颜色与 15 节点的颜色一样，变为红色</li>
<li>20 为根结点，将其改为黑色<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://image-static.segmentfault.com/842/419/842419664-5d37b734b8439_articlex" alt="image">
      </li>
</ol>

        <h1 id="C语言实现">
          <a href="#C语言实现" class="heading-link"><i class="fas fa-link"></i></a>C语言实现</h1>
      
        <h2 id="基本定义">
          <a href="#基本定义" class="heading-link"><i class="fas fa-link"></i></a>基本定义</h2>
      <figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED        0    <span class="comment">// 红色节点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK    1    <span class="comment">// 黑色节点</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span>{</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> color;        <span class="comment">// 颜色(RED 或 BLACK)</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父结点</span></span><br><span class="line">}Node, *RBTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>{</span></span><br><span class="line">    Node *node;</span><br><span class="line">}RBRoot;</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="左旋">
          <a href="#左旋" class="heading-link"><i class="fas fa-link"></i></a>左旋</h2>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQWj1J.png" alt="image">
      </p>
<figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED        0    <span class="comment">// 红色节点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK    1    <span class="comment">// 黑色节点</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span>{</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> color;        <span class="comment">// 颜色(RED 或 BLACK)</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父结点</span></span><br><span class="line">}Node, *RBTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>{</span></span><br><span class="line">    Node *node;</span><br><span class="line">}RBRoot;</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="右旋">
          <a href="#右旋" class="heading-link"><i class="fas fa-link"></i></a>右旋</h2>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/30/tQWvc9.png" alt="image">
      </p>
<figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 对红黑树的节点(y)进行右旋转</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 右旋示意图(对节点y进行左旋)：</span></span><br><span class="line"><span class="comment"> *            py                               py</span></span><br><span class="line"><span class="comment"> *           /                                /</span></span><br><span class="line"><span class="comment"> *          y                                x                  </span></span><br><span class="line"><span class="comment"> *         /  \      --(右旋)--&gt;            /  \                     #</span></span><br><span class="line"><span class="comment"> *        x   ry                           lx   y  </span></span><br><span class="line"><span class="comment"> *       / \                                   / \                   #</span></span><br><span class="line"><span class="comment"> *      lx  rx                                rx  ry</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(RBRoot *root, Node *y)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 设置x是当前节点的左孩子。</span></span><br><span class="line">    Node *x = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”；</span></span><br><span class="line">    <span class="comment">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>) </span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//tree = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line">        root-&gt;node = x;            <span class="comment">// 如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (y == y-&gt;parent-&gt;right)</span><br><span class="line">            y-&gt;parent-&gt;right = x;    <span class="comment">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;parent-&gt;left = x;    <span class="comment">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y” 设为 “x的右孩子”</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y的父节点” 设为 “x”</span></span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="添加">
          <a href="#添加" class="heading-link"><i class="fas fa-link"></i></a>添加</h2>
      
        <h3 id="直接插入">
          <a href="#直接插入" class="heading-link"><i class="fas fa-link"></i></a>直接插入</h3>
      <figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    }</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="修正">
          <a href="#修正" class="heading-link"><i class="fas fa-link"></i></a>修正</h3>
      <figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    }</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h2 id="删除">
          <a href="#删除" class="heading-link"><i class="fas fa-link"></i></a>删除</h2>
      
        <h3 id="直接删除">
          <a href="#直接删除" class="heading-link"><i class="fas fa-link"></i></a>直接删除</h3>
      <figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    }</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h3 id="修正-1">
          <a href="#修正-1" class="heading-link"><i class="fas fa-link"></i></a>修正</h3>
      <figure class="highlight c"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    }</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="Free-Talk">
          <a href="#Free-Talk" class="heading-link"><i class="fas fa-link"></i></a>Free Talk</h1>
      <p>我打算在今后的板块中都增加一个Free Talk的环节，讲讲自己的感受。<br>其实之前一直有听说过红黑树的名字，就是没有深入了解，正好在家待着没事干，就打算写一个数据结构与算法的系列，就当做是复习和进一步学习吧。<br>这次的博客主要是参考了两篇文章，一篇是比较详细的讲解算法实现和原理，一篇特点是动图易懂。自己写完了这篇博客也只能算是懂了第二篇，算法的后半部分确实没啃动。感觉一开始就将红黑树有些硬核，面试应该不可能有手写代码吧。<br>接下打算就是把JVM的系列和数据结构与算法的系列穿插着写，然后算法的系列会加入LeetCode模块，JVM的系列还没有考虑好要怎么用代码实现学习。<br><strong>To be a better man!</strong></p>
<p>参考链接：<br><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">博客园</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://segmentfault.com/a/1190000020118044" target="_blank" rel="noopener">segment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（二）-- Java内存管理</title>
    <url>/JVM%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="运行时数据区域">
          <a href="#运行时数据区域" class="heading-link"><i class="fas fa-link"></i></a>运行时数据区域</h1>
      <p><a href="https://imgchr.com/i/tmAiTO" target="_blank" rel="noopener">
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/28/tmAiTO.md.png" alt="tmAiTO.md.png">
      </a></p>

        <h2 id="程序计数器">
          <a href="#程序计数器" class="heading-link"><i class="fas fa-link"></i></a>程序计数器</h2>
      <p>程序计数器就是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，和计组中学到的大致一样。</p>
<a id="more"></a>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理执行时间的方式来实现的，也就是操作系统中学到的并发性–两个或多个事件在<em>同一时间间隔</em>内发生，在任何时刻仅会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计算器记录的是正在执行的虚拟机字节码指令的地址；<br>如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。<br>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<!--more-->

        <h2 id="Java虚拟机栈">
          <a href="#Java虚拟机栈" class="heading-link"><i class="fas fa-link"></i></a>Java虚拟机栈</h2>
      <p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是<em>线程私有</em>的，它的生命周期与线程相同。虚拟机站描述的是<strong>Java方法执行的线程内存模型</strong>：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame:是方法运行期很重要的基础数据结构，后面会补充)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈。</p>

        <h3 id="局部变量表">
          <a href="#局部变量表" class="heading-link"><i class="fas fa-link"></i></a>局部变量表</h3>
      <p>局部变量表存放了编译期可知的各种Java虚拟机<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、<strong>对象引用</strong>(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和<code>returnAddress</code>类型(指向了一条字节码指令的地址)。</p>
<blockquote>
<p>这些数据类型在局部变量表中的存储空间以<strong>局部变量槽(Slot)</strong> 来表示，其中64位长度的long和double类型的数据会占用<em>两个变量槽</em>，其余的数据类型只占用一个。局部变量表所需的内存空间在<strong>编译期间完成分配</strong>，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是<em>完全确定的</em>，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>
</blockquote>
<blockquote>
<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowerError</code>异常;</li>
<li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>动态扩展：</strong>HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在Hotspot虚拟机上是不会由于虚拟机栈无法扩展而导致<code>OutOfMemoryError</code>异常–只要线程申请栈空间成功了就不会有OOM，但是如果申请时失败，仍然是会出现OOM异常的。</p>
</blockquote>

        <h2 id="本地方法栈">
          <a href="#本地方法栈" class="heading-link"><i class="fas fa-link"></i></a>本地方法栈</h2>
      <p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为<em>虚拟机执行Java方法(也就是字节码)服务</em>，而本地方法栈则是<strong>为虚拟机使用到的本地(Native)方法服务</strong>。</p>
<p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>

        <h3 id="Native-Method">
          <a href="#Native-Method" class="heading-link"><i class="fas fa-link"></i></a>Native Method</h3>
      <p>Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/wike163/article/details/6635321" target="_blank" rel="noopener">详细介绍</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h2 id="Java堆">
          <a href="#Java堆" class="heading-link"><i class="fas fa-link"></i></a>Java堆</h2>
      <p>对于Java应用程序来说，<strong>Java堆(Java Heap)</strong>是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，Java世界里“几乎”所有对象实例都在这里分配内存。</p>
<blockquote>
<p>在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p>
</blockquote>
<p>Java堆是垃圾收集管理器管理的内存区域，因此一些资料中它也被称为“<strong>GC堆</strong>”(Garbage Collected Heap)。从回收内存的角度看，由于现代垃圾收集器大部分都是基于<strong>分代收集理论</strong>设计的，所以Java堆中经常会出现 <strong>“新生代”、“老年代”、“永久代”</strong>等名字；再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor空间</strong>等(面试常问)</p>
<p>![image]<span class="exturl"><a class="exturl__link" href="https://s1.ax1x.com/2020/07/20/UhMDbt.png" target="_blank" rel="noopener">https://s1.ax1x.com/2020/07/20/UhMDbt.png</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>)<br>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于<strong>物理上不连续的内存空间中，只要逻辑上是连续的即可</strong>，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>

        <h2 id="方法区">
          <a href="#方法区" class="heading-link"><i class="fas fa-link"></i></a>方法区</h2>
      <p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于<strong>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p>
<p>方法的执行都是伴随着线程的。<strong>原始类型的本地变量以及引用</strong>都存放在<strong>线程栈</strong>中。而<strong>引用关联的对象</strong>比如String，都存在在<strong>堆中</strong>。</p>

        <h3 id="运行时常量池">
          <a href="#运行时常量池" class="heading-link"><i class="fas fa-link"></i></a>运行时常量池</h3>
      <p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant PoolTable），用于存放<strong>编译期生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>

        <h1 id="HotSpot虚拟机对象">
          <a href="#HotSpot虚拟机对象" class="heading-link"><i class="fas fa-link"></i></a>HotSpot虚拟机对象</h1>
      <p>HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>

        <h2 id="对象的创建">
          <a href="#对象的创建" class="heading-link"><i class="fas fa-link"></i></a>对象的创建</h2>
      <p>遇到一条new指令时的创建过程：</p>
<ol>
<li>检查这个指令的参数能否在常量池中定位到一个<strong>类的符号引用</strong>，并检查这个符号引用代表的类是否已被<em>加载、解析和初始化过</em>；</li>
<li>类加载检查通过后，虚拟机将为新对象<strong>分配内存</strong>，此时可以确定存储这个对象所需的<em>内存大小</em>；</li>
<li>在堆中为新对象分配可用内存；</li>
<li>将分配到的内存初始化；</li>
<li>设置对象头中的数据；</li>
<li>此时，从虚拟机的角度看，对象已经创建好了，但从Java程序的角度看，对象创建才刚刚开始，构造函数还没有执行。</li>
</ol>

        <h3 id="如何在堆中为新对象划分可用的内存？">
          <a href="#如何在堆中为新对象划分可用的内存？" class="heading-link"><i class="fas fa-link"></i></a>如何在堆中为新对象划分可用的内存？</h3>
      <p><strong>指针碰撞(内存分配规整)</strong></p>
<ul>
<li>用过的内存放一边，没用过的内存放一边，中间用一个指针分割；</li>
<li>分配内存的过程就是将指针向没有用过的内存那边移动所需的长度。</li>
</ul>
<p><strong>空闲列表(内存分配不规整)</strong></p>
<ul>
<li>维护一个列表，记录哪些内存块是可用的；</li>
<li>分配内存时，从列表上选取一块足够大的空间分配给对象，并更新列表上的记录。</li>
</ul>

        <h3 id="如何处理多线程创建对象时，划分内存的指针的同步问题？">
          <a href="#如何处理多线程创建对象时，划分内存的指针的同步问题？" class="heading-link"><i class="fas fa-link"></i></a>如何处理多线程创建对象时，划分内存的指针的同步问题？</h3>
      <ul>
<li>对分配内存空间的动作进行<strong>同步处理(CAS)</strong>;</li>
<li>把内存分配动作按照线程划分在<strong>不同的空间</strong>之中进行；<ol>
<li>每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>(Thread Local Allocation Buffer,TLAB);</li>
<li>哪个线程要分配内存就在哪个线程的TLAB上分配，TLAB用完需要分配新的TLAB时，才需要同步锁定；</li>
<li>通过 <code>-XX:+/-UseTLAB</code>参数设定是否使用 TLAB。</li>
</ol>
</li>
</ul>

        <h2 id="对象的内存布局">
          <a href="#对象的内存布局" class="heading-link"><i class="fas fa-link"></i></a>对象的内存布局</h2>
      <p>在Hotspot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong>。</p>

        <h3 id="对象头">
          <a href="#对象头" class="heading-link"><i class="fas fa-link"></i></a>对象头</h3>
      <p><strong>对象头部分</strong>包括两类信息：</p>
<ol>
<li><strong>运行数据：</strong>用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志等。(见官方 Mark Word)<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/28/te5Rcq.png" alt="te5Rcq.png">
      </li>
<li><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针确定该对象是哪个类的实例。</li>
</ol>

        <h3 id="实例数据">
          <a href="#实例数据" class="heading-link"><i class="fas fa-link"></i></a>实例数据</h3>
      <p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的<strong>各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<ul>
<li><strong>默认分配顺序：</strong>longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；</li>
<li>默认分配顺序下，父类字段会被分配在子类字段前面。</li>
</ul>

        <h3 id="对齐填充">
          <a href="#对齐填充" class="heading-link"><i class="fas fa-link"></i></a>对齐填充</h3>
      <p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着<strong>占位符</strong>的作用。<br>HotSpot VM要求对象的起始地址必须是<strong>8字节的整数倍</strong>，所以不够要补齐。</p>

        <h2 id="对象的访问定位">
          <a href="#对象的访问定位" class="heading-link"><i class="fas fa-link"></i></a>对象的访问定位</h2>
      <p>Java 程序需要通过虚拟机栈上的 <strong>reference 数据</strong>来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：<strong>句柄访问和直接指针访问</strong>。</p>

        <h3 id="句柄访问">
          <a href="#句柄访问" class="heading-link"><i class="fas fa-link"></i></a>句柄访问</h3>
      <p>句柄访问会在Java堆中划分一块内存作为句柄池，每一个句柄存放着对象类型数据的指针。</p>
<p><strong>优势：</strong>对象移动的时候(这在垃圾回收时十分常见)只需改变句柄池中<strong>对象实例数据的指针</strong>，不需要修改Reference本身。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/28/te7VDx.png" alt="te7VDx.png">
      </p>

        <h3 id="直接指针访问">
          <a href="#直接指针访问" class="heading-link"><i class="fas fa-link"></i></a>直接指针访问</h3>
      <p>直接指针访问方式在Java堆对象的实例数据中存放了一个指向对象实例数据和对象类型数据的指针，在HotSpot中，这个指针会被存放在对象头中。</p>
<p><strong>优势：</strong>减少了一次指针定位对象实例数据的开销，速度更快。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/05/28/teHwTK.png" alt="teHwTK.png">
      </p>
<p>参考目录：<br><span class="exturl"><a class="exturl__link" href="http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html" target="_blank" rel="noopener">纯洁的微笑</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/00-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">Github笔记总结</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>《深入理解java虚拟机》</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（一）-- Java类的加载机制</title>
    <url>/JVM-1/</url>
    <content><![CDATA[<h1 id="类的加载定义">
          <a href="#类的加载定义" class="heading-link"><i class="fas fa-link"></i></a>类的加载定义</h1>
      <p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="http://favorites.ren/assets/images/2017/jvm/jvm-1.png" alt="image">
      </p>
<p>类的最终加载产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并向Java程序提供访问接口。</p>
<p>与C语言的类比：C语言 –&gt; 二进制文件 –&gt; 计算机硬件；Java –&gt; 字节码文件 –&gt; JVM</p>
<blockquote>
<p><strong>注意事项：</strong>类加载器并不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，但是如果这个类在加载中遇到错误，只有在主动使用此类时才会报错(LinkageError)。</p>
</blockquote>
<a id="more"></a>


        <h1 id="类的生命周期">
          <a href="#类的生命周期" class="heading-link"><i class="fas fa-link"></i></a>类的生命周期</h1>
      <p>加载(Loading) –&gt;  <strong>验证(Verification) –&gt; 准备(Preparation) –&gt; 解析(Resolution)</strong> –&gt; 初始化(Intialization) –&gt; 使用(Using) –&gt; 卸载(Unloading) 共七个阶段；其中验证、准备和解析又统称为<strong>连接(Linking)阶段</strong>。</p>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80QUc2dGljNjhBR2JSNnc4bWQ5cW1vcmdldjV5cHN0aWF3ekRKNk5kNmFONUZJRzVzaWFyYmlhTUFSSmljeFQ0UmR2ZzZtaDRhUWdnSVlmQ0xZNTAwMHVIRGliUS82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" style="" alt="image">
      </p>
<blockquote>
<p>在前五个阶段中，加载、验证、准备、初始化的顺序是确定的，但是解析阶段不一定，它在某些情况下可以在初始化阶段之前开始，这是为了支持Java的动态绑定。</p>
</blockquote>

        <h2 id="加载">
          <a href="#加载" class="heading-link"><i class="fas fa-link"></i></a>加载</h2>
      <p><strong>三个任务：</strong></p>
<blockquote>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流</li>
<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的运行时<strong>数据结构</strong></li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中数据的访问入口</li>
</ul>
</blockquote>

        <h2 id="验证：确保被加载的类的正确性">
          <a href="#验证：确保被加载的类的正确性" class="heading-link"><i class="fas fa-link"></i></a>验证：确保被加载的类的正确性</h2>
      <p><strong>四个阶段：</strong></p>
<blockquote>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式规范；</li>
<li><strong>云数据验证</strong>：对字节码描述的信息进行语义分析，以保证满足java语言的规范</li>
<li><strong>字节码验证</strong>：通过数据流和控制流，确保程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能够正确执行</li>
</ul>
</blockquote>
<blockquote>
<p>ps: 验证阶段非常重要，但是不是必须的，如果引用的类已经经过反复验证了，就可以使用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>

        <h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值">
          <a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="heading-link"><i class="fas fa-link"></i></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2>
      <ol>
<li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在java堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如0，null,false),而不是被在java代码中显示赋予的值。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li>
</ol>
<p><strong>示例：</strong></p>
<blockquote>
<p>假设一个类变量的定义为：<code>public static int value = 3;</code><br>那么变量value在准备阶段过后的初始值为0，而不是3。因为此时尚未执行任何java方法，而赋值为3是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法中的，在初始化阶段执行。</p>
</blockquote>
<p> 这里还需要注意如下几点：</p>
<blockquote>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。<ul>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</li>
</ul>
</blockquote>

        <h2 id="解析">
          <a href="#解析" class="heading-link"><i class="fas fa-link"></i></a>解析</h2>
      <p>解析阶段是虚拟机将<strong>常量池内的符号引用替换为直接引用</strong>的过程。<br>符号引用就是一组符号来描述目标，可以是任何字面量。<br>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>

        <h2 id="初始化">
          <a href="#初始化" class="heading-link"><i class="fas fa-link"></i></a>初始化</h2>
      <p>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在java中对类变量进行初始值设定有两种方式：</p>
<blockquote>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
</blockquote>
<p><strong>JVM初始化步骤</strong></p>
<blockquote>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
</blockquote>
<p>类初始化时机：只有当对类的主动引用的时候才会导致类的初始化。<br><strong>类的主动引用</strong>包括以下六种：</p>
<blockquote>
<ol>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ol>
</blockquote>
<p>被动引用：</p>
<blockquote>
<ol>
<li>通过子类引用父类静态字段，不会导致子类初始化；</li>
<li>Array[] arr = new Array[10]; 不会触发 Array 类初始化；</li>
<li>static final VAR 在编译阶段会存入调用类的常量池，通过 ClassName.VAR 引用不会触发 ClassName 初始化。</li>
</ol>
</blockquote>

        <h2 id="介绍生命周期">
          <a href="#介绍生命周期" class="heading-link"><i class="fas fa-link"></i></a>介绍生命周期</h2>
      <p>以下四种情况：</p>
<blockquote>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</blockquote>

        <h1 id="类加载器">
          <a href="#类加载器" class="heading-link"><i class="fas fa-link"></i></a>类加载器</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="http://favorites.ren/assets/images/2017/jvm/calssloader.png" alt="image">
      </p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：<br><strong>启动类加载器：</strong><br>它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；<br><strong>所有其它的类加载器：</strong><br>这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器：</strong><code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。<br><strong>扩展类加载器：</strong><code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。<br><strong>应用程序类加载器：</strong><code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>

        <h2 id="JVM类加载机制">
          <a href="#JVM类加载机制" class="heading-link"><i class="fas fa-link"></i></a>JVM类加载机制</h2>
      <ul>
<li><strong>全盘负责：</strong>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入；</li>
<li><strong>父类委托：</strong>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类；</li>
<li><strong>缓存机制：</strong>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓冲区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。*这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li>
</ul>

        <h1 id="类的加载">
          <a href="#类的加载" class="heading-link"><i class="fas fa-link"></i></a>类的加载</h1>
      
        <h2 id="显式加载">
          <a href="#显式加载" class="heading-link"><i class="fas fa-link"></i></a>显式加载</h2>
      <p>调用<code>ClassLoader#loadClass(className)</code>或<code>Class.forName(className)</code>。<br>区别：</p>
<blockquote>
<ol>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ol>
</blockquote>

        <h2 id="隐式加载">
          <a href="#隐式加载" class="heading-link"><i class="fas fa-link"></i></a>隐式加载</h2>
      <ol>
<li>new类对象；</li>
<li>使用类的静态域；</li>
<li>创建子类对象；</li>
<li>使用子类的静态域；</li>
<li>其他的隐式加载，在JVM启动时：<blockquote>
<ul>
<li>BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；</li>
<li>ExtClassLoader 会加载指定目录下一些特殊的 Class；</li>
<li>AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li>
</ul>
</blockquote>
</li>
</ol>

        <h1 id="双亲委派模型">
          <a href="#双亲委派模型" class="heading-link"><i class="fas fa-link"></i></a>双亲委派模型</h1>
      <p><strong>工作流程：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><strong>双亲委派机制：</strong></p>
<ol>
<li><p>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p>
</li>
<li><p>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</p>
</li>
<li><p>如果 <code>BootStrapClassLoader</code>加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</p>
</li>
<li><p>若<code>ExtClassLoader</code>也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</p>
</li>
</ol>

        <h1 id="面试问题">
          <a href="#面试问题" class="heading-link"><i class="fas fa-link"></i></a>面试问题</h1>
      <ol>
<li><p>简单讲下JVM中的类加载过程</p>
</li>
<li><p>JVM中的类加载和卸载的时机？</p>
</li>
<li><p>如何理解JVM中不同类加载器的概念和作用？</p>
</li>
<li><p>简单讲下JVM中的双亲委派模型？</p>
</li>
<li><p>什么情况下会破坏双亲委派模型？为什么？可否举个例子？</p>
</li>
<li><p>Tomcat中的类加载机制有了解吗？为什么这么设计？</p>
</li>
<li><p>实际开发中有遇到哪些类加载器相关的问题？你又是如何解决的？</p>
</li>
<li><p>JVM之上的弱类型语言例如Groovy是如何实现？简单讲下动态类加载机制？<br>参考资料：<br><span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&amp;mid=2247483934&amp;idx=1&amp;sn=41c46eceb2add54b7cde9eeb01412a90&amp;chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">微信公众号</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">Github博主</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/duqi_2009/article/details/101877579" target="_blank" rel="noopener">Blog</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</li>
</ol>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java类</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言学习总结</title>
    <url>/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="CALL和RET指令">
          <a href="#CALL和RET指令" class="heading-link"><i class="fas fa-link"></i></a>CALL和RET指令</h1>
      
        <h2 id="ret和retf">
          <a href="#ret和retf" class="heading-link"><i class="fas fa-link"></i></a>ret和retf</h2>
      <p><strong>ret 指令</strong>用栈中的数据，<strong>修改IP的内容</strong>，从而实现近转移；<br><strong>retf 指令</strong>用栈中的数据，<strong>修改CS和IP的内容</strong>，从而实现远转移。</p>
<p>ret 指令相当于</p>
<blockquote>
<p>pop IP</p>
</blockquote>
<p>retf 指令相当于</p>
<blockquote>
<p>pop IP<br>  pop CS</p>
</blockquote>
<a id="more"></a>
<p>检测点10.1</p>
<figure class="highlight plain"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">assume cs: code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 16</span><br><span class="line">        mov ax, 1000h;cs地址</span><br><span class="line">        push ax</span><br><span class="line">        mov ax, 0 ;ip地址</span><br><span class="line">        push ax</span><br><span class="line">        retf</span><br><span class="line">        ;retf指令相当于是pop ip,pop cs</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="call指令">
          <a href="#call指令" class="heading-link"><i class="fas fa-link"></i></a>call指令</h2>
      <ol>
<li>call 标号<blockquote>
<p>push IP<br>jmp near ptr 标号</p>
</blockquote>
</li>
<li>call far ptr 标号<blockquote>
<p>push CS<br>push IP<br>jmp near ptr 标号</p>
</blockquote>
</li>
<li>call 16位 reg<blockquote>
<p>push IP<br>jmp 16位 reg</p>
</blockquote>
</li>
<li>call word ptr 内存单元地址<blockquote>
<p>push IP<br>jmp word ptr 内存单元地址</p>
</blockquote>
</li>
<li>call dword ptr 内存单元地址<blockquote>
<p>push CS<br>push IP<br>jmp dword ptr 内存单元地址</p>
</blockquote>
</li>
</ol>

        <h2 id="call和ret的配合使用">
          <a href="#call和ret的配合使用" class="heading-link"><i class="fas fa-link"></i></a>call和ret的配合使用</h2>
      <blockquote>
<p>call 标号<br>标号：<br>    指令<br>    ret</p>
</blockquote>

        <h2 id="mul指令">
          <a href="#mul指令" class="heading-link"><i class="fas fa-link"></i></a>mul指令</h2>
      <ol>
<li><strong>两个相乘的数：</strong><br>两个相乘的数，要么都是8位，要么都是16位。<br>如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；<br>如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。</li>
<li><strong>结果：</strong><br>如果是8位乘法，结果默认放在AX中；<br>如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。</li>
</ol>
<blockquote>
<p> mul reg<br>mul 内存单元<br> mul byte ptr ds:[0]</p>
</blockquote>

        <h2 id="实验十：">
          <a href="#实验十：" class="heading-link"><i class="fas fa-link"></i></a>实验十：</h2>
      <figure class="highlight x86asm"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">10</span> dup(<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">12345</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bx</span>, data</span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">call</span> dtoc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">call</span> show_str <span class="comment">;IP入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_str:</span></span><br><span class="line">    <span class="comment">;把需要用到的寄存器入栈保护</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">;计算起始偏移地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">160</span> <span class="comment">;行地址</span></span><br><span class="line">    <span class="keyword">dec</span> <span class="number">dh</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="number">dh</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">2</span>  <span class="comment">;列地址</span></span><br><span class="line">    <span class="keyword">dec</span> <span class="built_in">dl</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">dl</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">bx</span>, <span class="built_in">ax</span> <span class="comment">;偏移地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span> <span class="comment">;基址地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;循环执行mov指令</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="built_in">ds</span>:[<span class="built_in">si</span>] <span class="comment">;判断是否结束循环</span></span><br><span class="line">    <span class="keyword">jcxz</span> ok</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>], <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>+<span class="number">1</span>], <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">jmp</span> short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok:</span> </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="comment">;IP出栈</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">dtoc:</span> </span><br><span class="line">    <span class="comment">; 寄存器入栈保护</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="comment">; 计算十进制数字每位的值</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">10d</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="symbol">s1:</span> <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">dx</span>, <span class="number">30H</span> <span class="comment">; 转换ASCII码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">jcxz</span> over</span><br><span class="line">    <span class="keyword">jmp</span> short s1</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="symbol">over:</span>   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s2:</span>     <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>], <span class="built_in">dx</span> <span class="comment">; 修改到data字段</span></span><br><span class="line">        <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">loop</span> s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></tbody></table></div></figure>

        <h1 id="标志寄存器">
          <a href="#标志寄存器" class="heading-link"><i class="fas fa-link"></i></a>标志寄存器</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/01/t837KH.png" alt="t837KH.png">
      <br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义；<br>而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>

        <h2 id="ZF标志-第6位-–零标志位">
          <a href="#ZF标志-第6位-–零标志位" class="heading-link"><i class="fas fa-link"></i></a>ZF标志(第6位)–零标志位</h2>
      <p>记录相关指令执行后，其结果是否为0.</p>
<ol>
<li>结果为0：zf=1；</li>
<li>结果不为0：zf=0。<blockquote>
<p>注意是与结果相反的</p>
</blockquote>
</li>
</ol>

        <h2 id="PF标志-第2位-–奇偶标志位">
          <a href="#PF标志-第2位-–奇偶标志位" class="heading-link"><i class="fas fa-link"></i></a>PF标志(第2位)–奇偶标志位</h2>
      <p>它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p>
<ol>
<li>1的个数为偶数：pf=1，</li>
<li>奇数：pf=0。</li>
</ol>

        <h2 id="SF标志-第7位-–符号标志位">
          <a href="#SF标志-第7位-–符号标志位" class="heading-link"><i class="fas fa-link"></i></a>SF标志(第7位)–符号标志位</h2>
      <ol>
<li>结果为负，SF=1；</li>
<li>结果为正，SF=0。</li>
</ol>
<p>通常用补码来表示有符号数据。<br>因此，对于一个二进制数据，计算机在既把它当做有符号数运算也进行无符号数运算，同时提供两种结果给程序选择。</p>

        <h2 id="CF标志-第0位-–进位-借位标志位">
          <a href="#CF标志-第0位-–进位-借位标志位" class="heading-link"><i class="fas fa-link"></i></a>CF标志(第0位)–进位/借位标志位</h2>
      <p>记录最高有效位向更高有效位的进位/借位<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/01/t8Nvin.png" alt="t8Nvin.png">
      </p>
<ol>
<li>有进位/借位：CF=1，</li>
<li>无进位/借位：CF=0。</li>
</ol>

        <h2 id="OF标志-第11位-–溢出标志位">
          <a href="#OF标志-第11位-–溢出标志位" class="heading-link"><i class="fas fa-link"></i></a>OF标志(第11位)–溢出标志位</h2>
      <ol>
<li>有溢出：OF=1，</li>
<li>无溢出：OF=0。</li>
</ol>
<p><strong>CF和OF的区别：</strong><br>CF是对无符号数运算有意义的标志位；<br>OF是对有符号数运算有意义的标志位。</p>

        <h2 id="adc指令">
          <a href="#adc指令" class="heading-link"><i class="fas fa-link"></i></a>adc指令</h2>
      <p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<blockquote>
<p>adc obj1,obj2<br>obj1 = obj1+obj2+CF</p>
</blockquote>

        <h1 id="基础知识">
          <a href="#基础知识" class="heading-link"><i class="fas fa-link"></i></a>基础知识</h1>
      
        <h1 id="寄存器">
          <a href="#寄存器" class="heading-link"><i class="fas fa-link"></i></a>寄存器</h1>
      
        <h1 id="寄存器-内存访问">
          <a href="#寄存器-内存访问" class="heading-link"><i class="fas fa-link"></i></a>寄存器(内存访问)</h1>
      
        <h1 id="第一个程序">
          <a href="#第一个程序" class="heading-link"><i class="fas fa-link"></i></a>第一个程序</h1>
      
        <h1 id="BX-和loop指令">
          <a href="#BX-和loop指令" class="heading-link"><i class="fas fa-link"></i></a>[BX]和loop指令</h1>
      
        <h1 id="包含多个段的程序">
          <a href="#包含多个段的程序" class="heading-link"><i class="fas fa-link"></i></a>包含多个段的程序</h1>
      
        <h1 id="更灵活的定位内存地址的方法">
          <a href="#更灵活的定位内存地址的方法" class="heading-link"><i class="fas fa-link"></i></a>更灵活的定位内存地址的方法</h1>
      
        <h1 id="数据处理的两个基本问题">
          <a href="#数据处理的两个基本问题" class="heading-link"><i class="fas fa-link"></i></a>数据处理的两个基本问题</h1>
      
        <h1 id="转移指令的原理">
          <a href="#转移指令的原理" class="heading-link"><i class="fas fa-link"></i></a>转移指令的原理</h1>
      <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>课程总结</category>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA后端开发学习路线</title>
    <url>/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="JAVA学习路线">
          <a href="#JAVA学习路线" class="heading-link"><i class="fas fa-link"></i></a>JAVA学习路线</h1>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="http://assets.processon.com/chart_image/5ec28f620791290fe06e73f8.png" alt="思维导图">
      </p>
<a id="more"></a>
<p><span class="exturl"><a class="exturl__link" href="https://www.processon.com/embed/5ec28f620791290fe06e73f5" target="_blank" rel="noopener">思维导图在线链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>感谢来自CodeSheep大神的总结，<span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/BV1GQ4y1N7HD" target="_blank" rel="noopener">视频链接</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h1 id="学习资料总结">
          <a href="#学习资料总结" class="heading-link"><i class="fas fa-link"></i></a>学习资料总结</h1>
      <ol>
<li>Java 基础，那必须 <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/BV1GZ4y1s7MG" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GZ4y1s7MG</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>虚拟机，毋庸置疑，肯定是胡志明老师的《深入理解 Java 虚拟机》，累计销售 30W 本，你说中国才有多少 Java 开发呢？</li>
<li>多线程，我是一点点点看阿里P7清英的书学会的，看了三篇，还是非常经典《Java并发编程的艺术》</li>
<li>数据结构和算法， LeetCode 官方国内唯一合作课程，专注于面试场景，全程动态动画教学。我也是一边看这个视频一边刷 LeetCode的，只想说刷完 LeetCode 你会发现，面试的算法全是原题。【付费资料，非喜勿入】<span class="exturl"><a class="exturl__link" href="https://t.lagou.com/pR69ReRlRg43F" target="_blank" rel="noopener">https://t.lagou.com/pR69ReRlRg43F</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>计算机网络：《图解HTTP》非常经典，自行购买</li>
<li>SQL/数据库，阿里P9梳理的知识点，看了三遍，每次都是看完都能吊打面试官【付费资料，非喜勿入】<span class="exturl"><a class="exturl__link" href="https://urlify.cn/myAZfe" target="_blank" rel="noopener">https://urlify.cn/myAZfe</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>操作系统，那肯定是那本经典神书了《操作系统》，好不好豆瓣脑补。<span class="exturl"><a class="exturl__link" href="https://book.douban.com/subject/5064311/" target="_blank" rel="noopener">https://book.douban.com/subject/5064311/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>设计模式，设计模式看了N多内容包括书籍，但是还是强烈推荐 Google 王峥教程，我也是第一次才知道，学设计模式要和框架和 JDK 本身使用的设计模式结合起来看，<span class="exturl"><a class="exturl__link" href="https://urlify.cn/JBZvqy" target="_blank" rel="noopener">https://urlify.cn/JBZvqy</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>IDEA，只能说牛逼，不过太贵了，分享一个免费可用的注册码<span class="exturl"><a class="exturl__link" href="https://juejin.im/post/5eb69a23e51d454db678bdd3" target="_blank" rel="noopener">https://juejin.im/post/5eb69a23e51d454db678bdd3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>Linux，《鸟哥的Linux 私房菜》据说这本书是所有人入门的必看书籍</li>
<li>Maven 是每个前端开发必须的，是时候搞起来了，不过这种工具可以直接上手不用资料</li>
<li>Git，SVN已经废弃了，其实 Git 基本不用看视频，对着文档搞搞搞，30分钟就拿下了 <span class="exturl"><a class="exturl__link" href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/git/git-tutorial.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>Spring Boot，我必须第一个推荐微笑哥的博客，国内最早做 Spring Boot 教程的人，你看了就知道有多全 <span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/ityouknow/p/5662753.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5662753.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 对的还有一个非常不错的面试 Spring Boot 实战视频，算是 B站的第一原创 Spring Boot 视频吧 看得起劲 BV1Zb41137X2</li>
<li>Spring Cloud 那必须推荐方志朋老师的专栏，算是全网阅读最高，目前1000W阅读，你觉得阅读都是刷的吗？好不好自己去瞅瞅 <span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/forezp/column/info/15197" target="_blank" rel="noopener">https://blog.csdn.net/forezp/column/info/15197</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
<li>RabbitMQ，Kafka 算是面试必考了，我果断买了厮大两本书《RabbitMQ实战指南》《深入理解Kafka》</li>
<li>Dubbo 的其实更推荐直接看 Spring Cloud，为啥子呢？Spring Cloud 相当于开发商精装交付的房子，Dubbo 相当于毛坯房，为了省心还是推荐直接看 Spring Cloud</li>
<li>数据库连接池无论什么方便 HikariCP 都能玩爆其他</li>
<li>微服务太大了，服务发现，网关，调用，熔断和降级，配置中心，分布式事务，任务调度，这里真心难通过视频看懂，所以如果你现在接触不到，建议你自己搞一个项目或者换个工作吧，如果你没有真正的用起来准备也没用，因为你也回答不出来精髓。</li>
<li>容器技术，那肯定是 docker，我是看阮一峰老师的博客入门的，30 分钟稳稳的入门，你信么<span class="exturl"><a class="exturl__link" href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li>
</ol>
<p>目前上述学习总结转载自<span class="exturl"><a class="exturl__link" href="https://www.devcuss.com/a/708977837062750208" target="_blank" rel="noopener">https://www.devcuss.com/a/708977837062750208</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ，之后会在学习中不断地更新上述学习资料。</p>
<p>给自己定一个小目标，半年来学会思维导图里的100%的编程基础和研发工具，以及了解50%的应用框架，熟练使用10%的应用框架。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>Java后端</category>
        <category>路线</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Github入门教学</title>
    <url>/Github%E5%85%A5%E9%97%A8%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="GitHub入门教学（Git，界面介绍，搜索）">
          <a href="#GitHub入门教学（Git，界面介绍，搜索）" class="heading-link"><i class="fas fa-link"></i></a>GitHub入门教学（Git，界面介绍，搜索）</h1>
      
        <h2 id="前提：Git使用">
          <a href="#前提：Git使用" class="heading-link"><i class="fas fa-link"></i></a>前提：Git使用</h2>
      <p>GitHub是基于Git开发得到，学习Git是了解GitHub的前提，在这里我推荐一个特别喜欢的学习教程。</p>
<p><span class="exturl"><a class="exturl__link" href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰Git教学</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>简单示例</p>
<figure class="highlight avrasm"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">mkdir learngit <span class="meta">#创建一个空白目录</span></span><br><span class="line">cd learngit </span><br><span class="line"></span><br><span class="line">git init <span class="meta">#把这个目录变成Git可以管理的仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">add</span> readme.txt <span class="meta">#把文件添加到仓库</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"wrote a readme file"</span> <span class="meta">#把文件提交给仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">push</span> -u origin master <span class="meta">#把本地仓库中的所有内容上传到远程库</span></span><br></pre></td></tr></tbody></table></div></figure>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/06/01/t8gefS.png" alt="t8gefS.png">
      </p>
<a id="more"></a>

        <h2 id="GitHub介绍-敲黑板">
          <a href="#GitHub介绍-敲黑板" class="heading-link"><i class="fas fa-link"></i></a>GitHub介绍(敲黑板)</h2>
      <p>Keywords：</p>
<p>版本分支介绍，版本分支比较，Issue，Pull Request，Projects，Wiki，Github Pages</p>

        <h2 id="GitHub搜索开源项目">
          <a href="#GitHub搜索开源项目" class="heading-link"><i class="fas fa-link"></i></a>GitHub搜索开源项目</h2>
      <p>开源项目的搜索方法</p>
<figure class="highlight avrasm"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">pushed:</span>&gt;<span class="number">2020</span><span class="number">-05</span><span class="number">-15</span>   <span class="meta"># 在最近这一天修改过</span></span><br><span class="line"><span class="symbol">in:</span>name [关键字]  <span class="meta"># 名字里面包含关键字</span></span><br><span class="line"><span class="symbol">in:</span>readme [关键字] <span class="meta"># readme里面包含关键字</span></span><br><span class="line"><span class="symbol">in:</span>description 【关键字】<span class="meta"># 描述里面包含关键字</span></span><br><span class="line"><span class="symbol">forks:</span>&gt;<span class="number">4</span> <span class="meta"># stars数量大于4的项目</span></span><br><span class="line"><span class="symbol">stars:</span>&gt;<span class="number">1000</span>  <span class="meta"># stars数量大于1000的项目</span></span><br><span class="line"><span class="symbol">langusge:</span>java  <span class="meta"># 使用java作为开发语言</span></span><br></pre></td></tr></tbody></table></div></figure>

<p>简单示例</p>
<figure class="highlight vim"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">in:description 爬虫 <span class="keyword">star</span><span class="variable">s:</span>&gt;<span class="number">100</span>  <span class="keyword">language</span>:<span class="keyword">python</span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="B站视频链接">
          <a href="#B站视频链接" class="heading-link"><i class="fas fa-link"></i></a>B站视频链接</h2>
      <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模算法汇总</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/AiDVdhUEBgYKtQz.png" alt="image.png">
      </p>

        <h1 id="优化模型">
          <a href="#优化模型" class="heading-link"><i class="fas fa-link"></i></a>优化模型</h1>
      <a id="more"></a>

        <h2 id="优化模型-1">
          <a href="#优化模型-1" class="heading-link"><i class="fas fa-link"></i></a>优化模型(1)</h2>
      <p><em>三要素:</em> <strong>决策变量、目标函数、约束</strong><br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/luolang_103/article/details/80567443" target="_blank" rel="noopener">https://blog.csdn.net/luolang_103/article/details/80567443</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/zVPmxnUyRLS1Q57.png" alt="image.png">
      </p>

        <h3 id="单目标（Single-Objective-Optimization-Problem）">
          <a href="#单目标（Single-Objective-Optimization-Problem）" class="heading-link"><i class="fas fa-link"></i></a>单目标（Single-Objective Optimization Problem）</h3>
      <blockquote>
<p>所评测目标只有一个，只需要根据具体的满足函数条件，求得最值</p>
</blockquote>

        <h3 id="多目标（Multi-objective-Optimization-Problem）">
          <a href="#多目标（Multi-objective-Optimization-Problem）" class="heading-link"><i class="fas fa-link"></i></a>多目标（Multi-objective Optimization Problem）</h3>
      <blockquote>
<p>多目标优化问题中，同时存在多个最大化或是最小化的目标函数，并且，这些目标函数并不是相互独立的，也不是相互和谐融洽的，他们之间会存在或多或少的冲突，使得不能同时满足所有的目标函数。</p>
</blockquote>

        <h3 id="线性">
          <a href="#线性" class="heading-link"><i class="fas fa-link"></i></a>线性</h3>
      <blockquote>
<p>线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数<br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/fjssharpsword/article/details/53195556" target="_blank" rel="noopener">https://blog.csdn.net/fjssharpsword/article/details/53195556</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="非线性">
          <a href="#非线性" class="heading-link"><i class="fas fa-link"></i></a>非线性</h3>
      <blockquote>
<p>如果目标函数或者约束条件中至少有一个是非线性函数时，最优化问题叫做非线性规划问题<br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/qjzcy/article/details/51727741" target="_blank" rel="noopener">https://blog.csdn.net/qjzcy/article/details/51727741</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="整数规划优化">
          <a href="#整数规划优化" class="heading-link"><i class="fas fa-link"></i></a>整数规划优化</h3>
      <blockquote>
<p>全部变量限制为整数的规划问题，称为纯整数规划；部分变量限制为整数的规划问题，称为混合整数规划；变量只取0或1的规划问题，称为0-1整数规划。<br>整数规划问题，建议使用Lingo软件求解。常用的整数规划问题解法有：<br>（1）分枝定界法：可求纯或混合整数线性规划。<br>（2）割平面法：可求纯或混合整数线性规划。<br>（3）隐枚举法：用于求解0-1整数规划，有过滤法和分枝法。<br>（4）匈牙利法：解决指派问题（0-1规划特殊情形）。<br>（5）蒙特卡罗法：求解各种类型规划。<br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/27976866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27976866</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="单目标化">
          <a href="#单目标化" class="heading-link"><i class="fas fa-link"></i></a>单目标化</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/fwNLboBKaz4qVDI.png" alt="image.png">
      </p>
<blockquote>
<p>一般采用两个目标函数加权相加的形式。加权可以解决两个目标函数量纲不一致，或者变化剧烈程度不一致的问题，不过权重本身需要人为选取。<br>一般不使用乘法来组合目标函数，因为这样会使得导数的形式变得复杂。<br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/30383993" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30383993</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h2 id="优化模型-2">
          <a href="#优化模型-2" class="heading-link"><i class="fas fa-link"></i></a>优化模型(2)</h2>
      
        <h3 id="动态规划-Dynamic-Programming">
          <a href="#动态规划-Dynamic-Programming" class="heading-link"><i class="fas fa-link"></i></a>动态规划 Dynamic Programming</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/T9FYRqJgzxSw4am.png" alt="image.png">
      </p>
<figure class="highlight groovy"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">A * <span class="string">"1+1+1+1+1+1+1+1 =？"</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">A :</span> <span class="string">"上面等式的值是多少"</span></span><br><span class="line"><span class="string">B :</span> *计算* <span class="string">"8!"</span></span><br><span class="line"></span><br><span class="line">A *在上面等式的左边写上 <span class="string">"1+"</span> *</span><br><span class="line"><span class="string">A :</span> <span class="string">"此时等式的值为多少"</span></span><br><span class="line"><span class="string">B :</span> *quickly* <span class="string">"9!"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"你怎么这么快就知道答案了"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"只要在8的基础上加1就行了"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"</span></span><br></pre></td></tr></tbody></table></div></figure>
<p><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">https://blog.csdn.net/u013309870/article/details/75193592</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
<blockquote>
<p><strong>1. 将原问题分解为子问题</strong><br>    把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。<br>    子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。<br> <strong>2. 确定状态</strong><br>    在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。<br>    所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。<br>    整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。<br>   <strong>3.确定一些初始状态（边界状态）的值</strong><br>    以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。<br>    <strong>4. 确定状态转移方程</strong><br>     定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。<br>    数字三角形的状态转移方程:<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/peAd9XNOTvlDib6.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/baidu_28312631/article/details/47418773" target="_blank" rel="noopener">https://blog.csdn.net/baidu_28312631/article/details/47418773</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="目标规划">
          <a href="#目标规划" class="heading-link"><i class="fas fa-link"></i></a>目标规划</h3>
      <blockquote>
<p><strong>1、加权系数法</strong><br>       为每一个目标加一个权系数，把多目标模型转化成单一目标模型。但是困难时确定合理的权系数，以反映不同目标之间的重要程度。<br><strong>2、优先等级法</strong><br>       将各目标按其重要程度分为不同的优先等级，转化为单目标模型。<br><strong>3、有效解法</strong><br>       寻求能够照顾到各个目标，并使决策者感到满意的解。由决策者来确定选取哪一个解，即得到满意的解。但是有效解太多，无法挑选<br><strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4273802.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4273802.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="图论">
          <a href="#图论" class="heading-link"><i class="fas fa-link"></i></a>图论</h3>
      
        <h3 id="网络流模型">
          <a href="#网络流模型" class="heading-link"><i class="fas fa-link"></i></a>网络流模型</h3>
      <blockquote>
<p>对于一个网络流我们可以用一个有向图G = （V，E，C）表示；V表示顶点的集合，E表示有向边的集合，C表示有向边的最大流量。对于每一个网络，有一个源输入点，称之为source，一个输出点，称之为sink。在不是出发点source也不是输出点sink的其他点，流量不能超过有向边的最大流量，这是一个约束条件。<br>下图就是一个简单的网络流模型：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/SHIw21EnNCq4mZO.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/changyuanchn/article/details/17097807" target="_blank" rel="noopener">https://blog.csdn.net/changyuanchn/article/details/17097807</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="最短路">
          <a href="#最短路" class="heading-link"><i class="fas fa-link"></i></a>最短路</h3>
      <blockquote>
<p><strong>最短路径问题</strong><br>画图在线平台：<br><strong><span class="exturl"><a class="exturl__link" href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">https://csacademy.com/app/graph_editor/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br>注意邻接矩阵和关联矩阵的概念！<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/RvLaVzcdrN3umXO.png" alt="9_GJHOYM9__MAR_K0_F6CNT.png">
      <br>邻接矩阵：元素为权值，不连接时为无穷(无权时为0/1表示是否相连)<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/PJ9D8QyEMj1sFml.png" alt="84">
      <br>解决方法：Dijkstra算法 Floyd算法<br><strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/weixin_43791406/article/details/89314614" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43791406/article/details/89314614</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="最大流">
          <a href="#最大流" class="heading-link"><i class="fas fa-link"></i></a>最大流</h3>
      <blockquote>
<p>网络流图是一张只有一个源点和汇点的有向图，而最大流就是求源点到汇点间的最大水流量，下图的问题就是一个最基本，经典的最大流问题<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/gJQO9F2SepzR6xy.png" alt="image.png">
      <br><strong>流量,容量,可行流,增广路</strong><br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/stevensonson/article/details/79177530" target="_blank" rel="noopener">https://blog.csdn.net/stevensonson/article/details/79177530</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>
<blockquote>
<p>图就是一种管道，管道有最大通过流量的限制，图中边的权值就是所谓的“容量”。同时，注意有唯一的源点和汇点。<br>算法的关键在于<br><strong>1）何为增广路径，如何找出增广路径。</strong><br><strong>2）如何更新流量</strong><br>所谓增广路径，就是找到这样一条路径，其流量不满，未达到容量上限。<br>所有的可能的增广路径在一起便构成了残留网络<br>第一步，计算可增加流量<br>设某一增广路径上的节点为（a1,a2,a3,a4,….,an）<br>如果（u,v）是正向边，则增加流量d = min{ c(ai,aj) - f(ai,aj) | j = i +1, i =1,2,3…,n-1}<br>如果是逆向边，则增加流量d = min{ f(ai, aj) | j = i +1, i =1,2,3…,n-1}<br>第二步，更新流量<br>如果（u,v）是正向边，则 f(u,v) = f(u,v) + d<br>是逆向边，则f(u,v) = f(u,v) - d<br>注意，如果是逆向边，就是减法，当前管道从中减去部分流量，而且，伴随着这部分减去的流量，必有另一部分管道的流量会增加。。而且，最后的总流量增加了d<br><strong>来自 <span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/ShaneZhang/p/3755479.html" target="_blank" rel="noopener">https://www.cnblogs.com/ShaneZhang/p/3755479.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="最小生成树">
          <a href="#最小生成树" class="heading-link"><i class="fas fa-link"></i></a>最小生成树</h3>
      <blockquote>
<p>图G=（V(G),E(G)）树T=（V(T),E’(T)）<br>在一个连通无向图G=(V, E)中，对于其中的每条边(u,v)∈E，赋予其权重w(u, v)，则最小生成树问题就是要在G中找到一个连通图G中所有顶点的无环子集T⊆E，使得这个子集中所有边的权重之和最小。<br>即生成树为一条连接所有点的路径，最小生成树为权重和最小那个生成树（非环）<br>解决最小生成树问题有两个算法：Prim算法和Kruskal算法<br><strong>Prim算法</strong>基本思想是从选点开始，再选择和不连通点之间的边，进而循环，每一次循环中，一个关键在于判断点之间是否不连通（对连通点集团进行编号，即只需判断集团编号是否相等即可），另一个在于选择最小的边。<br><strong>Kruskal算法</strong>基本思想是从选最小边开始，连通成一个集团，进行编号，再选择不连通的集团的最小赋权边进行连接，依次循环。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/ZGHkLWOPjENM6Vg.png" alt="3">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">https://blog.csdn.net/luoshixian099/article/details/51908175</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h2 id="优化模型-3">
          <a href="#优化模型-3" class="heading-link"><i class="fas fa-link"></i></a>优化模型(3)</h2>
      
        <h3 id="背包">
          <a href="#背包" class="heading-link"><i class="fas fa-link"></i></a>背包</h3>
      <blockquote>
<p><strong><em>《背包问题九讲》</em></strong><br>背包问题不单单是一个简单的算法问题，它本质上代表了一大类问题，这类问题实际上是01线性规划问题，其约束条件和目标函数如下：
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/3iC2xhWNXGuq8v6.png" alt="image.png">
      <br><strong>eg:01背包问题，完全背包问题，多重背包问题，二维费用背包问题</strong><br><strong><span class="exturl"><a class="exturl__link" href="http://dongxicheng.org/structure/knapsack-problems/" target="_blank" rel="noopener">http://dongxicheng.org/structure/knapsack-problems/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="指派-分配问题">
          <a href="#指派-分配问题" class="heading-link"><i class="fas fa-link"></i></a>指派(分配问题)</h3>
      <blockquote>
<p>实际中，会遇到这样的问题，有n项不同的任务，需要n个人分别完成其中的1项，每个人完成任务的时间不一样。于是就有一个问题，如何分配任务使得花费时间最少。<br>通俗来讲，就是n*n矩阵中，选取n个元素，每行每列各有1个元素，使得和最小。<br>如下图：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/d58hrDcQ14k7JwV.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p><strong>指派问题的最优解有这样一个性质，若从矩阵的一行(列)各元素中分别减去该行(列)的最小元素，得到归约矩阵，其最优解和原矩阵的最优解相同</strong></p>
</blockquote>
<blockquote>
<p><strong>匈牙利法：</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/hWeQFEwxgnAORzX.png" alt="image.png">
      </p>
</blockquote>

        <h3 id="抽屉">
          <a href="#抽屉" class="heading-link"><i class="fas fa-link"></i></a>抽屉</h3>
      
        <h3 id="旅行社TSP">
          <a href="#旅行社TSP" class="heading-link"><i class="fas fa-link"></i></a>旅行社TSP</h3>
      <blockquote>
<p>Travelling Salesman Problem (TSP) 是最基本的路线问题。它寻求的是旅行者由起点出发，通过所有给定的需求点后，再次返回起点所花费的最小路径成本<br>整理模拟退火算法的程序！<br><strong><span class="exturl"><a class="exturl__link" href="http://blog.csdn.net/zhangzhengyi03539/article/details/46673545" target="_blank" rel="noopener">http://blog.csdn.net/zhangzhengyi03539/article/details/46673545</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/ranjiewen/p/6815333.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranjiewen/p/6815333.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="CPP">
          <a href="#CPP" class="heading-link"><i class="fas fa-link"></i></a>CPP</h3>
      <blockquote>
<p>中国邮路问题，就是派邮递员送信，最后返回邮局，要求必须经过负责投递的街道至少一次，并且途径距离最短，属于图论里的euler回路<br><strong>介绍：<span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/gxuan/article/details/7869119" target="_blank" rel="noopener">https://blog.csdn.net/gxuan/article/details/7869119</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>编程实现：<span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html" target="_blank" rel="noopener">https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="产销">
          <a href="#产销" class="heading-link"><i class="fas fa-link"></i></a>产销</h3>
      <blockquote>
<p>解决如何实现成本最小，利润最大的问题，问题的核心为如何求成本函数最小值的问题。<br><strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html" target="_blank" rel="noopener">https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="运输">
          <a href="#运输" class="heading-link"><i class="fas fa-link"></i></a>运输</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/MlcEqYBx6ny3kUK.png" alt="image.png">
      <br><em>四要素：</em> <strong>生产地，销售地，运输物资，运输价格</strong><br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/33299659" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33299659</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="排队论">
          <a href="#排队论" class="heading-link"><i class="fas fa-link"></i></a>排队论</h3>
      <blockquote>
<p>排队系统由三部分组成：<br><strong>(1)顾客输入过程</strong><br><strong>(2)排队结构与排队规则</strong><br><strong>(3)服务机构与服务规则</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/r6WleBKoTV4cSta.png" alt="7">
      <br>一般研究的问题为总体为无限的，到达方式逐个，到达间隔随机，顾客之间相互独立，输入过程平稳。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/4zCUAPQHEgwFdaV.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/UF7ujBXEA4ZR9yH.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/K2E7bxswA8mhCDc.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270875.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270875.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h1 id="预测模型">
          <a href="#预测模型" class="heading-link"><i class="fas fa-link"></i></a>预测模型</h1>
      
        <h2 id="预测模型-1-微分方程预测">
          <a href="#预测模型-1-微分方程预测" class="heading-link"><i class="fas fa-link"></i></a>预测模型(1)微分方程预测</h2>
      <blockquote>
<p><span class="exturl"><a class="exturl__link" href="https://wenku.baidu.com/view/2e0a184a16fc700abb68fc7c.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/2e0a184a16fc700abb68fc7c.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="单种群">
          <a href="#单种群" class="heading-link"><i class="fas fa-link"></i></a>单种群</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/KAxoXkQFC6sv7g5.png" alt="image.png">
      </p>
</blockquote>

        <h3 id="多种群增长">
          <a href="#多种群增长" class="heading-link"><i class="fas fa-link"></i></a>多种群增长</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/VzoeUjYAB5s6G41.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/4XY9DRtmj3Blgre.png" alt="image.png">
      </p>
</blockquote>

        <h3 id="Logistic阻滞增长">
          <a href="#Logistic阻滞增长" class="heading-link"><i class="fas fa-link"></i></a>Logistic阻滞增长</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/GWXCzd8Ue9nKurm.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/mrguanlingyu/article/details/7976607" target="_blank" rel="noopener">https://blog.csdn.net/mrguanlingyu/article/details/7976607</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>
<blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/fqDx69TcVwPe35U.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/B1OwxPuFb7HNYXc.png" alt="image.png">
      <br>指数模型人口预测程序：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/WzCBA6ThL7qoPMX.png" alt="image.png">
      <br>logistic阻滞型人口模型代码：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/EuC8jnDwX24JrPp.png" alt="image.png">
      <br><strong>主要为nlinfit函数的使用</strong></p>
</blockquote>

        <h3 id="时滞模型">
          <a href="#时滞模型" class="heading-link"><i class="fas fa-link"></i></a>时滞模型</h3>
      <blockquote>
<p>考虑到种群密度对种群增长的时滞作用而改进的一个种群连续增长模型。</p>
</blockquote>

        <h2 id="预测模型-2-微分方程预测">
          <a href="#预测模型-2-微分方程预测" class="heading-link"><i class="fas fa-link"></i></a>预测模型(2)微分方程预测</h2>
      
        <h3 id="房室模型">
          <a href="#房室模型" class="heading-link"><i class="fas fa-link"></i></a>房室模型</h3>
      <blockquote>
<p><span class="exturl"><a class="exturl__link" href="https://wenku.baidu.com/view/231eab44b307e87101f69645.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/231eab44b307e87101f69645.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h3 id="差分方差模型">
          <a href="#差分方差模型" class="heading-link"><i class="fas fa-link"></i></a>差分方差模型</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/tb9lHuMQKn7xAhy.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/TaigaCon/p/6878674.html" target="_blank" rel="noopener">https://www.cnblogs.com/TaigaCon/p/6878674.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="解析解">
          <a href="#解析解" class="heading-link"><i class="fas fa-link"></i></a>解析解</h3>
      <blockquote>
<p>解析解(analytical solution)就是一些严格的公式,给出任意的自变量就可以求出其因变量,也就是问题的解, 他人可以利用这些公式计算各自的问题.  </p>
</blockquote>

        <h3 id="数值解">
          <a href="#数值解" class="heading-link"><i class="fas fa-link"></i></a>数值解</h3>
      <blockquote>
<p>解析解(analytical solution)就是一些严格的公式,给出任意的自变量就可以求出其因变量,也就是问题的解, 他人可以利用这些公式计算各自的问题.  </p>
</blockquote>

        <h3 id="参数确定">
          <a href="#参数确定" class="heading-link"><i class="fas fa-link"></i></a>参数确定</h3>
      
        <h2 id="预测模型-3">
          <a href="#预测模型-3" class="heading-link"><i class="fas fa-link"></i></a>预测模型(3)</h2>
      
        <h3 id="线性-1">
          <a href="#线性-1" class="heading-link"><i class="fas fa-link"></i></a>线性</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/BtPiv147VgqfpZK.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://otexts.com/fppcn/regression-intro.html" target="_blank" rel="noopener">https://otexts.com/fppcn/regression-intro.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="非线性回归与拟合">
          <a href="#非线性回归与拟合" class="heading-link"><i class="fas fa-link"></i></a>非线性回归与拟合</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/5sDUoVdkzvMcNnw.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/32325298" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32325298</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>
<p><strong>逻辑回归</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/94McTKJ7N5gDpaF.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/kKFmwp79qXNgCtW.png" alt="image.png">
      </p>

        <h3 id="统计回归预测">
          <a href="#统计回归预测" class="heading-link"><i class="fas fa-link"></i></a>统计回归预测</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/QHGD2U6Wpjtb5mI.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://otexts.com/fppcn/forecasting-regression.html" target="_blank" rel="noopener">https://otexts.com/fppcn/forecasting-regression.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/Android_xue/article/details/97614045" target="_blank" rel="noopener">https://blog.csdn.net/Android_xue/article/details/97614045</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="参数确定-1">
          <a href="#参数确定-1" class="heading-link"><i class="fas fa-link"></i></a>参数确定</h3>
      
        <h2 id="预测模型-4">
          <a href="#预测模型-4" class="heading-link"><i class="fas fa-link"></i></a>预测模型(4)</h2>
      
        <h3 id="Markov链预测">
          <a href="#Markov链预测" class="heading-link"><i class="fas fa-link"></i></a>Markov链预测</h3>
      <blockquote>
<p><strong>1.状态</strong>  在马尔可夫预测中，“状态”是一个重要的术语。所谓状态，就是指某一事件在某个时刻（或时期)出现的某种结果。一般而言，随着所研究的事件及其预测的目标不同，状态可以有不同的划分方式。譬如，在商品销售预测中，有“畅销”、“一般”、“滞销”等状态；在农业收成预测中，有“丰收”、“平收”、“欠收”等状态；在人口构成预测中，有“婴儿”、“儿童”、“少年”、“青年”、“中年”、“老年”等状态；等等。<br><strong>2.状态转移过程</strong>  在事件的发展过程中，从一种状态转变为另一种状态，就称为状态转移。事件的发展，随着时间的变化而变化所作的状态转移，或者说状态转移与时间的关系，就称为状态转移过程，简称过程。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/cpMKNXrnLdsvh1I.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/p6rTQwKsfRkEPtO.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/qq_41686130/article/details/81906527" target="_blank" rel="noopener">https://blog.csdn.net/qq_41686130/article/details/81906527</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/bitcarmanlee/article/details/82819860" target="_blank" rel="noopener">https://blog.csdn.net/bitcarmanlee/article/details/82819860</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="神经网络预测">
          <a href="#神经网络预测" class="heading-link"><i class="fas fa-link"></i></a>神经网络预测</h3>
      <blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/HzjDa4dU3FyQESt.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/O5hTurW7HfLawyz.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/HnYr2uSxUCVblRN.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/jug7q39TyOEl5Uv.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://otexts.com/fppcn/nnetar.html" target="_blank" rel="noopener">https://otexts.com/fppcn/nnetar.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/asd20172016/article/details/81454009" target="_blank" rel="noopener">https://blog.csdn.net/asd20172016/article/details/81454009</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><span class="exturl"><a class="exturl__link" href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270391.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270391.html</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h2 id="预测模型-5">
          <a href="#预测模型-5" class="heading-link"><i class="fas fa-link"></i></a>预测模型(5)</h2>
      
        <h3 id="模糊预测">
          <a href="#模糊预测" class="heading-link"><i class="fas fa-link"></i></a>模糊预测</h3>
      
        <h3 id="灰色预测">
          <a href="#灰色预测" class="heading-link"><i class="fas fa-link"></i></a>灰色预测</h3>
      <blockquote>
<p>灰色系统介于白色和黑色之间，灰色系统内的一部分信息是已知的，另一部分信息是未知的，系统内各因素间有不确定的关系。<br>灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展趋势的状况。<br><strong>数据生成：累加生成、累减生成、加权累加生成<br>灰色模型GM(1,1)</strong><br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/qq547276542/article/details/77865341" target="_blank" rel="noopener">https://blog.csdn.net/qq547276542/article/details/77865341</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="参数确定-2">
          <a href="#参数确定-2" class="heading-link"><i class="fas fa-link"></i></a>参数确定</h3>
      
        <h1 id="分类模型">
          <a href="#分类模型" class="heading-link"><i class="fas fa-link"></i></a>分类模型</h1>
      
        <h2 id="分类模型-1">
          <a href="#分类模型-1" class="heading-link"><i class="fas fa-link"></i></a>分类模型(1)</h2>
      <p><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/sinat_26917383/article/details/51611519" target="_blank" rel="noopener">https://blog.csdn.net/sinat_26917383/article/details/51611519</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>

        <h3 id="聚类">
          <a href="#聚类" class="heading-link"><i class="fas fa-link"></i></a>聚类</h3>
      <blockquote>
<p><strong>三类比较常见的聚类模型，K-mean聚类、层次（系统）聚类、最大期望EM算法</strong><br><em>聚类分析的目的就是让类群内观测的距离最近，同时不同群体之间的距离最大。</em></p>
</blockquote>
<p><strong>K-mean聚类</strong></p>
<blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/KYwmGE1IiACNlty.png" alt="image.png">
      </p>
</blockquote>
<p><strong>层次（系统）聚类</strong></p>
<blockquote>
<p>层次聚类也称系统聚类法，是根据个体间距离将个体向上两两聚合，再将聚合的小群体两两聚合一直到聚为一个整体。计算所有个体之间的距离，最相近距离的个体合体，不断合体。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/V9K8yAF5ovqpfYu.png" alt="image.png">
      </p>
</blockquote>
<p><strong>最大期望EM算法</strong></p>
<blockquote>
<p>最大期望（EM）算法是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variable）。</p>
</blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/NSJts5pRYHabmuI.png" alt="image.png">
      </p>

        <h3 id="模糊聚类-FCM">
          <a href="#模糊聚类-FCM" class="heading-link"><i class="fas fa-link"></i></a>模糊聚类(FCM)</h3>
      <p><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/WWWQ2386466490/article/details/80349239" target="_blank" rel="noopener">https://blog.csdn.net/WWWQ2386466490/article/details/80349239</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong><br><strong>隶属度</strong></p>
<blockquote>
<p>隶属度函数是表示一个对象x 隶属于集合A 的程度的函数，通常记做μA(x)，其自变量范围是所有可能属于集合A 的对象（即集合A 所在空间中的所有点），取值范围是[0,1]，即0&lt;=μA(x)，μA(x)&lt;=1。μA(x)=1 表示x 完全隶属于集合A，相当于传统集合概念上的x∈A。</p>
</blockquote>
<p><strong>模糊集合</strong></p>
<blockquote>
<p>个定义在空间X={x}上的隶属度函数就定义了一个模糊集合A，或者叫定义在论域X={x}上的模糊子集A’。对于有限个对象x1，x2，……，xn 模糊集合A’可以表示为：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/FIMcE7QACyBJi8V.png" alt="image.png">
      </p>
</blockquote>
<p><strong>FCM聚类算法</strong></p>
<blockquote>
<p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/ULvH9CngXNY2SfQ.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/r2xmuBJeasM6NVH.png" alt="image.png">
      </p>
</blockquote>

        <h3 id="距离函数选取">
          <a href="#距离函数选取" class="heading-link"><i class="fas fa-link"></i></a>距离函数选取</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/t5v4yEAY6UeLSPj.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/h4aLlNPW1IiD6nT.png" alt="image.png">
      </p>

        <h3 id="线性非线性分类器选取">
          <a href="#线性非线性分类器选取" class="heading-link"><i class="fas fa-link"></i></a>线性非线性分类器选取</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/94XMJRnPa8bYE3e.png" alt="image.png">
      <br>左边：非线性分类器<br>右边：线性分类器（又名：一刀切）<br><strong>分类器</strong><br>可以把输入数据分类的“东西”<br><strong><span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/30633734/answer/463900106" target="_blank" rel="noopener">https://www.zhihu.com/question/30633734/answer/463900106</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>

        <h2 id="分类模型-2">
          <a href="#分类模型-2" class="heading-link"><i class="fas fa-link"></i></a>分类模型(2)</h2>
      
        <h3 id="神经网络分类">
          <a href="#神经网络分类" class="heading-link"><i class="fas fa-link"></i></a>神经网络分类</h3>
      <p>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/i9XoDwdpzhObqcH.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/03/xiKTcGe6zON7d8L.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/HerosOfEarth/article/details/52165133" target="_blank" rel="noopener">https://blog.csdn.net/HerosOfEarth/article/details/52165133</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>

        <h3 id="网络构造">
          <a href="#网络构造" class="heading-link"><i class="fas fa-link"></i></a>网络构造</h3>
      <blockquote>
<p>A、输入量的选择：<br>a、输入量必须选择那些对输出影响大且能够检测或提取的变量；<br>b、各输入量之间互不相关或相关性很小。从输入、输出量性质分类来看，可以分为两类：数值变量和语言变量。数值变量又分为连续变量或离散变量。如常见的温度，压力，电压，电流等就是连续变量；语言变量是用自然语言表示的概念。如红，绿，蓝；男，女；大，中，小，开，关，亮，暗等。一般来说，语言变量在网络处理时，需要转化为离散变量。<br>c、输入量的表示与提取：多数情况下，直接送给神经网络的输入量无法直接得到，常常需要用信号处理与特征提取技术从原始数据中提取能反映其特征的若干参数作为网络输入。<br>B、输出量选择与表示：<br>a、输出量一般代表系统要实现的功能目标，如分类问题的类别归属等；<br>b、输出量表示可以是数值也可是语言变量；<br><strong><span class="exturl"><a class="exturl__link" href="https://blog.csdn.net/m0_37102093/article/details/78030711" target="_blank" rel="noopener">https://blog.csdn.net/m0_37102093/article/details/78030711</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="初始权值选取">
          <a href="#初始权值选取" class="heading-link"><i class="fas fa-link"></i></a>初始权值选取</h3>
      <blockquote>
<p>网络权值的初始化决定了网络的训练从误差曲面的哪一点开始，因此初始化方法对缩短网络的训练时间至关重要。<br>神经元的作用函数是关于坐标点对称的，若每个节点的净输入均在零点附近，则输出均出在作用函数的中点，这个位置不仅远离作用函数的饱和区，而且是其变化最灵敏的区域，必使网络学习加快。从神经网络净输入表达式来看，为了使各节点的初始净输入在零点附近，如下两种方法被常常使用：<br>A、取足够小的初始权值；<br>B、使初始值为+1和-1的权值数相等。</p>
</blockquote>

        <h1 id="评价模型">
          <a href="#评价模型" class="heading-link"><i class="fas fa-link"></i></a>评价模型</h1>
      
        <h2 id="评价模型-1">
          <a href="#评价模型-1" class="heading-link"><i class="fas fa-link"></i></a>评价模型(1)</h2>
      
        <h3 id="模糊分析">
          <a href="#模糊分析" class="heading-link"><i class="fas fa-link"></i></a>模糊分析</h3>
      <blockquote>
<p><strong>1.建立综合评价的因素集</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/iWFAPeQa3kc96Kt.png" alt="image.png">
      <br><strong>2.建立综合评价的评价集</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/Ar3expYbJXVCj7L.png" alt="image.png">
      <br><strong>3.进行单元素模糊评价，获得评价矩阵</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/pH26unJlESLYKZ9.png" alt="image.png">
      <br><strong>4.确定因素权向量</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/WN4a9Knukd5oh1H.png" alt="image.png">
      <br><strong>5.建立综合评价模型</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/OIoYlxQjsV1greF.png" alt="image.png">
      <br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/njQg5yq93vuCXYN.png" alt="image.png">
      <br><strong>6.确定系统总得分</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/dLfOj9tx2JHqBP5.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/32666445" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32666445</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="隶属度函数选取与构造">
          <a href="#隶属度函数选取与构造" class="heading-link"><i class="fas fa-link"></i></a>隶属度函数选取与构造</h3>
      <blockquote>
<p>常用的方法：<strong>直觉方法，二元对比排序法，模糊统计试验法，最小模糊度法</strong>（根据先验知识和采集的数据，确定出描述模糊概念的候选隶属函数，利用最小化模糊度的原则计算相关的参数，进而获得合适的隶属函数）。<br>下面介绍三种最常用的隶属度函数：<strong>三角形隶属度函数、梯形隶属度函数、高斯型隶属度函数：</strong><br><strong>三角形隶属度函数</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/GUTEVZDzRcYHXv3.png" alt="image.png">
      <br><strong>梯形隶属度函数</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/TmEJY6WvuNxO23t.png" alt="image.png">
      <br><strong>高斯型隶属度函数</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/uqkzCd7jrvbMpmw.png" alt="image.png">
      <br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/37616833" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37616833</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h2 id="评价模型-2">
          <a href="#评价模型-2" class="heading-link"><i class="fas fa-link"></i></a>评价模型(2)</h2>
      
        <h3 id="层次分析法评价-AHP">
          <a href="#层次分析法评价-AHP" class="heading-link"><i class="fas fa-link"></i></a>层次分析法评价(AHP)</h3>
      <blockquote>
<p><strong>对难以完全定量得复杂系统做出决策，主要用来求权重</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/wJ1NAbS9aigzop8.png" alt="image.png">
      <br><strong>第一步，建立从目标层到准则层(指标层)再到决策层(方案层)</strong><br>1）最高层（目标层）——只有一个元素：决策目标；<br>2）中间层（准则层）——考虑的因素，决策的准则、子准则；<br>3）最底层（方案层）——决策时的备选方案、措施。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/pJHBimPk5DGd1rF.png" alt="image.png">
      <br><strong>第二步，(最重要的一步)构造成对比较矩阵</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/syupZ7jMd6L2e91.png" alt="image.png">
      <br>A矩阵代表准则层各个指标之间的相互关系，B矩阵代表各个待选方案分别在5个指标中的相互比较关系。<br>(即若n个指标，m个决策方案，则B为(n,n)矩阵，有m个)<br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/35051786" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35051786</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="打分与权重确定">
          <a href="#打分与权重确定" class="heading-link"><i class="fas fa-link"></i></a>打分与权重确定</h3>
      
        <h2 id="评价模型-3">
          <a href="#评价模型-3" class="heading-link"><i class="fas fa-link"></i></a>评价模型(3)</h2>
      
        <h3 id="主成分分析-Principal-components-analysis-PCA">
          <a href="#主成分分析-Principal-components-analysis-PCA" class="heading-link"><i class="fas fa-link"></i></a>主成分分析(Principal components analysis,PCA)</h3>
      <p>找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。</p>
<ol>
<li>最近重构性：样本点到这个超平面的距离足够近</li>
<li>最大可分性：样本点在这个超平面上的投影能尽可能的分开<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/tR4zIEkOQeBnDKC.png" alt="image.png">
      <br>PCA算法的主要优点有：<br>仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　<br>各主成分之间正交，可消除原始数据成分间的相互影响的因素。<br>计算方法简单，主要运算是特征值分解，易于实现。<br>PCA算法的主要缺点有：<br>主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。<br>方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</li>
</ol>
<p><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/32412043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32412043</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>

        <h3 id="主成分回归评价-principle-component-regression；PCR">
          <a href="#主成分回归评价-principle-component-regression；PCR" class="heading-link"><i class="fas fa-link"></i></a>主成分回归评价(principle component regression；PCR)</h3>
      <blockquote>
<p>主成份回归可以解决变量间共线性的问题。它使用从数据抽提出的主成份进行回归，一般来说是选择前面的几个主成份。下面给出一个例子，训练集中的自变量数据X和因变量y，以及测试集中的数据Xnew和因变量Ynew，结果给出训练集中的回归模型得到的预测值和实际值的相关系数，以及测试集中相应的相关系数。<br><strong><span class="exturl"><a class="exturl__link" href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=54276&amp;do=blog&amp;id=375339" target="_blank" rel="noopener">http://blog.sciencenet.cn/home.php?mod=space&amp;uid=54276&amp;do=blog&amp;id=375339</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="主成分解释">
          <a href="#主成分解释" class="heading-link"><i class="fas fa-link"></i></a>主成分解释</h3>
      <blockquote>
<p>主成分分析（PCA）是一种降维方法，通常用于通过将数量很多的变量转换为仍包含集合中大部分信息的较少变量来降低数据集的维数。<br>减少数据集的变量数量自然是以牺牲精度为代价的，但降维是为了简单而略微准确。因为较小的数据集更易于探索和可视化，并且使机器学习算法更容易和更快地分析数据，而无需处理无关的变量。<br>总而言之，PCA的概念很简单：减少数据集的维数，同时保留尽可能多的信息。<br><strong><span class="exturl"><a class="exturl__link" href="https://zhuanlan.zhihu.com/p/58663947" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58663947</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></strong></p>
</blockquote>

        <h3 id="数据包络分析-Data-Envelopment-Analysis-DEA">
          <a href="#数据包络分析-Data-Envelopment-Analysis-DEA" class="heading-link"><i class="fas fa-link"></i></a>数据包络分析(Data Envelopment Analysis,DEA)</h3>
      <blockquote>
<p>它是根据多项投入指标和多项产出指标，利用线性规划的方法，对具有可比性的同类型单位进行相对有效性评价的一种数量分析方法。</p>
</blockquote>
<p>1) 定义变量<br>设Ek（k=1，2，……， K）为第k个单位的效率比率，这里K代表评估单位的总数。<br>设uj（j=1，2，……， M）为第j种产出的系数，这里M代表所考虑的产出种类的总数。变量uj用来衡量产出价值降低一个单位所带来的相对的效率下降。<br>设vI（I=1，2，……，N）为第I种投入的系数，这里N代表所考虑的投入种类的综合素。变量vI用来衡量投入价值降低一个单位带来的相对的效率下降。<br>设Ojk为一定时期内由第k个服务单位所创造的第j种产出的观察到的单位的数量。<br>设Iik为一定时期内由第k个服务单位所使用的第i种投入的实际的单位的数量。<br>2) 目标函数<br>　　目标是找出一组伴随每种产出的系数u和一组伴随每种投入的系数ν，从而给被评估的服务单位最高的可能效率。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/tlK5C3Sfb1BPpHF.png" alt="image.png">
      <br>式中，e是被评估单位的代码。 这个函数满足这样一个约束条件，当同一组投入和产出的系数（uj和vi）用于所有其他对比服务单位时，没有一个服务单位将超过100%的效率或超过1.0的比率。<br>3) 约束条件<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/GncTOyBzp1a9IXS.png" alt="image.png">
      <br>k=1,2,……,K<br>式中所有系数值都是正的且非零。<br>为了用标准线性规划软件求解这个有分数的线性规划，需要进行变形。要注意，目标函数和所有约束条件都是比率而不是线性函数。通过把所评估单位的投入人为地调整为总和1.0，这样等式的目标函数可以重新表述为：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/Qu71vcEz8mYPlgB.png" alt="image.png">
      <br>　　满足以下约束条件：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/28EWzgrPiL7TuIj.png" alt="image.png">
      <br>　　对于个服务单位，等式（**）的约束条件可类似转化为：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/JVjoiPvfyt5XaO3.png" alt="image.png">
      <br>　　k=1,2,…,K<br>　　式中 uj≥0 j=1，2，…，M vi≥0 i=1，2，…，N<br>　　关于服务单位的样本数量问题是由在分析种比较所挑选的投入和产出变量的数量所决定的。下列关系式把分析中所使用的服务单位数量K和所考虑的投入种类数N与产出种类数M联系出来，它是基于实证发现和DEA实践的经验：<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/02/04/87J914AgkoSaNQT.png" alt="image.png">
      <br><span class="exturl"><a class="exturl__link" href="https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数学建模</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>建模算法</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛写作套路</title>
    <url>/%E7%BE%8E%E8%B5%9B%E5%86%99%E4%BD%9C%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="美赛写作套路">
          <a href="#美赛写作套路" class="heading-link"><i class="fas fa-link"></i></a>美赛写作套路</h1>
      
        <h2 id="Word还是LaTex">
          <a href="#Word还是LaTex" class="heading-link"><i class="fas fa-link"></i></a>Word还是LaTex</h2>
      <blockquote>
<p>倾向于使用Word进行写作，有利于论文的最后的协同合作<br>LaTex最新模板地址:<span class="exturl"><a class="exturl__link" href="https://github.com/latexstudio-org/mcmthesis/releases/tag/6.3" target="_blank" rel="noopener">https://github.com/latexstudio-org/mcmthesis/releases/tag/6.3</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="美赛论文怎么翻译">
          <a href="#美赛论文怎么翻译" class="heading-link"><i class="fas fa-link"></i></a>美赛论文怎么翻译</h2>
      <blockquote>
<p>谷歌翻译:<span class="exturl"><a class="exturl__link" href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br><strong>有以下几点要注意：</strong><br>（1） 翻译完成后再排版，记住，排版永远放在最后一步；<br>（2）第一次翻译完成后一定要再次核对语法、通顺程度、专有名词等，初次翻译出来的结果是不能看的，后面我再教给大家怎么修改；<br>（3）中文版用word写，后续翻译完成并修改后再用latex模板套用，因为latex导出来的就直接是pdf版本了，谷歌翻译对word的识别要远好于pdf。</p>
</blockquote>
<a id="more"></a>

        <h2 id="语法和拼写错误检测">
          <a href="#语法和拼写错误检测" class="heading-link"><i class="fas fa-link"></i></a>语法和拼写错误检测</h2>
      
        <h2 id="专有名词翻译">
          <a href="#专有名词翻译" class="heading-link"><i class="fas fa-link"></i></a>专有名词翻译</h2>
      <blockquote>
<p><strong>CNKI翻译助手：</strong><span class="exturl"><a class="exturl__link" href="http://dict.cnki.net/" target="_blank" rel="noopener">http://dict.cnki.net/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>

        <h2 id="模型介绍的翻译">
          <a href="#模型介绍的翻译" class="heading-link"><i class="fas fa-link"></i></a>模型介绍的翻译</h2>
      
        <h3 id="20个常用模型的美赛论文解读">
          <a href="#20个常用模型的美赛论文解读" class="heading-link"><i class="fas fa-link"></i></a>20个常用模型的美赛论文解读</h3>
      
        <h3 id="应对查重的小技巧">
          <a href="#应对查重的小技巧" class="heading-link"><i class="fas fa-link"></i></a>应对查重的小技巧</h3>
      
        <h4 id="代码查重问题">
          <a href="#代码查重问题" class="heading-link"><i class="fas fa-link"></i></a>代码查重问题</h4>
      <p>1.添加注释<br>2.改变变量名</p>

        <h4 id="文章查重问题">
          <a href="#文章查重问题" class="heading-link"><i class="fas fa-link"></i></a>文章查重问题</h4>
      <p>1.模型介绍、优缺点等尽量自己写<br>2.可以使用流程图来介绍算法</p>

        <h2 id="Word公式编辑和LaTeX公式语法">
          <a href="#Word公式编辑和LaTeX公式语法" class="heading-link"><i class="fas fa-link"></i></a>Word公式编辑和LaTeX公式语法</h2>
      <blockquote>
<p><strong>Axmath</strong>进行公式排版，同时也支持转换为LaTeX代码</p>
</blockquote>

        <h2 id="美赛数据下载网站">
          <a href="#美赛数据下载网站" class="heading-link"><i class="fas fa-link"></i></a>美赛数据下载网站</h2>
      <p>1.data.gov( <span class="exturl"><a class="exturl__link" href="https://www.data.gov/" target="_blank" rel="noopener">https://www.data.gov/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> )<br>2.Googledatasets<br>( <span class="exturl"><a class="exturl__link" href="https://cloud.google.com/bigquery/public‐data/" target="_blank" rel="noopener">https://cloud.google.com/bigquery/public‐data/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> )<br>3.WorldBank( <span class="exturl"><a class="exturl__link" href="http://data.worldbank.org/" target="_blank" rel="noopener">http://data.worldbank.org/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ) </p>

        <h2 id="统计图表的绘制">
          <a href="#统计图表的绘制" class="heading-link"><i class="fas fa-link"></i></a>统计图表的绘制</h2>
      
        <h3 id="使用Excel绘制统计图的视频">
          <a href="#使用Excel绘制统计图的视频" class="heading-link"><i class="fas fa-link"></i></a>使用Excel绘制统计图的视频</h3>
      <blockquote>
<p>数学建模：用EXCEL绘制统计图第1部分——饼图  <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78475931" target="_blank" rel="noopener">https://www.bilibili.com/video/av78475931</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>数学建模：用EXCEL绘制统计图第2部分——柱状图和条形图  <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78476106" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476106</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>数学建模：用EXCEL绘制统计图第3部分——直方图  <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78476359" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476359</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>数学建模：用EXCEL绘制统计图第4部分——折线图  <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78476554" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476554</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>数学建模：用EXCEL绘制统计图第5部分——散点图  <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78442212" target="_blank" rel="noopener">https://www.bilibili.com/video/av78442212</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>数学建模：用EXCEL绘制统计图第6部分——箱线图 <span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/video/av78476715" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476715</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数学建模</category>
        <category>写作</category>
      </categories>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛论文句式</title>
    <url>/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E5%8F%A5%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="开头句型写法">
          <a href="#开头句型写法" class="heading-link"><i class="fas fa-link"></i></a>开头句型写法</h2>
      <blockquote>
<p>Mention polygamy in Canada and waht might come to mind is Bountiful ,a suitably named town in British Columbia .</p>
</blockquote>
<p><strong>Mention…and what comes to mind is …</strong><br>提及……时我们第一个想到的是……<br>当我们要介绍某个地方、人物或者作品时，就可以用上该句型<br>Mention A and what comes to mind is B<br>A 一般是与事物有关的品质或者特点 B是事物本身<br>eg:<br>Mention  innovative thinking and what comes to mind is Steve Jobs ,a man who was ahead of his time and who reshaped the IT industry .</p>
<a id="more"></a>

        <h2 id="积累转折句型">
          <a href="#积累转折句型" class="heading-link"><i class="fas fa-link"></i></a>积累转折句型</h2>
      <blockquote>
<p>For all the talk of a global market for talent ,chief executives in Britain still earn considerably less than their counterparts in the United States .</p>
</blockquote>
<p><strong>For all the talk of … still …</strong><br>尽管关于……有很多的讨论，……仍然……<br>eg:<br>For all the talk of equal rights For women ,gender discrimination is still rife in the workplace .</p>

        <h2 id="表达背道而驰">
          <a href="#表达背道而驰" class="heading-link"><i class="fas fa-link"></i></a>表达背道而驰</h2>
      <blockquote>
<p>Mr Trump certainly has the poewr to wreak trade havoc .A big blanket tariff would slice through supply chains ,hurt American consumers and fly in the face of the global system of trade rules overseen by the World Trade Organization (WTO).</p>
</blockquote>
<p><strong>fly in the face of something</strong><br>与(人们认为合理或正常的事情)背道而驰，这种事情可以指法律法规，也可以指传统、常识、逻辑等。<br>eg:<br>Staying up late flies in the face of healthy living .</p>

        <h2 id="表达带来严重后果">
          <a href="#表达带来严重后果" class="heading-link"><i class="fas fa-link"></i></a>表达带来严重后果</h2>
      <blockquote>
<p>Commentators recently said that Clean Reader,the app that bowdlerises ebooks ,puts us on a slippery slope towards total literary censorship .</p>
</blockquote>
<p><strong>a slippery slope</strong><br>(过程或者习惯等)带来严重后果，使人走向极坏的境地<br>eg:<br>Once he had tried that first cigarette ,he was on the slippery slope to being a smoker .</p>

        <h2 id="写对比句">
          <a href="#写对比句" class="heading-link"><i class="fas fa-link"></i></a>写对比句</h2>
      <blockquote>
<p>Despite the mystery, Dr Charcot’s colleagues never thought to question the scientific value of the experiment. The same cannot be said of Mario Beauregard, a brain-imager from the University of Montreal, who has also experimented with mescaline.</p>
</blockquote>
<p><strong>the same cannot be said of…</strong><br>同样的说法/情况并不能用在……身上<br>eg:<br>In big cities it is always easy to find a movie theater, karaoke hall or fitness studio. However, the same cannot be said of remote villages.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数学建模</category>
        <category>写作</category>
      </categories>
      <tags>
        <tag>英文写作句型</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习常用句式（一）</title>
    <url>/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%8F%A5%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="常用句式">
          <a href="#常用句式" class="heading-link"><i class="fas fa-link"></i></a>常用句式</h2>
      <p>Su go ku o I si i<br>すごく　おいしい　<br>超级好吃</p>
<p>Su go ku ta no si i<br>すごく　たのしい<br>超级开心</p>
<p>I ta da ki ma su<br>いただきます<br>我要开动啦</p>
<a id="more"></a>
<p>O I si i<br>おいしい<br>好吃（女生）</p>
<p>U ma i　<br>うまい<br>好吃（男生）</p>
<p>I ma do ko<br>いま、どこ？<br>你现在在哪儿？</p>
<p>E ki da<br>えきだ<br>在车站呢</p>
<p>Ge nn ki<br>げんき<br>元気<br>ん拨音<br>身体健康</p>
<p>O ge nn ki de su ka<br>おげんきですか<br>你的身体还健康吗？<br>お：尊敬语<br>A na ka do<br>あなかど<br>你的<br>です：是<br>か：吗</p>
<p>Se nn se i<br>せんせい<br>先生</p>
<p>Yo ro shi ku<br>よろしく<br>请多关照</p>
<p>Sa yo na ra<br>さよなら<br>再见</p>

        <h2 id="五十音">
          <a href="#五十音" class="heading-link"><i class="fas fa-link"></i></a>五十音</h2>
      <p>A I u e o<br>あえうえお</p>
<p>Ka ki ku ke ko<br>かきくけこ</p>
<p>Sa shi su se so<br>さしすせそ</p>
<p>Ta chi tsu te to<br>たちつてと</p>
<p>Na ni nu ne no<br>なにぬねの</p>
<p>Ha hi fu he ho<br>はひふへほ</p>
<p>Ma mi mu me mo<br>まみむめも</p>
<p>Ya yu yo<br>やゆよ</p>
<p>Ra ri ru re ro<br>らりるれろ</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>日语常用句式</tag>
        <tag>五十音</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX基本操作</title>
    <url>/LaTeX%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="1-LaTeX环境的安装与配置">
          <a href="#1-LaTeX环境的安装与配置" class="heading-link"><i class="fas fa-link"></i></a>1.LaTeX环境的安装与配置</h2>
      <blockquote>
<p>官网自行安装下载</p>
</blockquote>

        <h2 id="2-LaTeX源文件的基本结构">
          <a href="#2-LaTeX源文件的基本结构" class="heading-link"><i class="fas fa-link"></i></a>2.LaTeX源文件的基本结构</h2>
       <figure class="highlight mel"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">%导言区 注释</span><br><span class="line">\documentclass{article}%book, report, letter </span><br><span class="line">\title{My First Document}</span><br><span class="line">\author{Lin Jun}	</span><br><span class="line">\<span class="keyword">date</span>{\today}</span><br><span class="line">%正文区（文稿区）</span><br><span class="line">\begin{document}</span><br><span class="line">\maketitle </span><br><span class="line"></span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">%在源文件增加空行实现分行</span><br><span class="line">Let $f(x)$ be defined by the formula</span><br><span class="line">$f(x)=<span class="number">3</span>x^<span class="number">2</span>+x<span class="number">-1</span>$.</span><br><span class="line">%使用$符号编辑行内数学公式</span><br><span class="line">$$f(x)=<span class="number">3</span>x^<span class="number">2</span>+x<span class="number">-1</span>$$ which is a polynomial of degree <span class="number">2.</span></span><br><span class="line">%使用$$符号编辑行间数学公式</span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></div></figure>
<a id="more"></a>

        <h2 id="3-LaTeX中的中文处理方法">
          <a href="#3-LaTeX中的中文处理方法" class="heading-link"><i class="fas fa-link"></i></a>3.LaTeX中的中文处理方法</h2>
      
        <h3 id="1-设置构建的默认编译器为XeLaTeX">
          <a href="#1-设置构建的默认编译器为XeLaTeX" class="heading-link"><i class="fas fa-link"></i></a>1.设置构建的默认编译器为XeLaTeX</h3>
      
        <h3 id="2-设置编辑器的编码格式为UTF-8">
          <a href="#2-设置编辑器的编码格式为UTF-8" class="heading-link"><i class="fas fa-link"></i></a>2.设置编辑器的编码格式为UTF-8</h3>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">%导言区 注释</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span><span class="comment">%book, report, letter </span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{ctex}</span></span> <span class="comment">%引入中文宏包</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span></span><span class="tag">\<span class="name">degree</span><span class="string">{^\circ}</span></span> <span class="comment">%在导言区进行命令的定义</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">{\heiti 杂谈勾股定理}</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">{\kaisu 不二}</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">{\today}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">   <span class="tag">\<span class="name">maketitle</span></span> </span><br><span class="line"></span><br><span class="line">	勾股定理可以用现代语言表述如下:</span><br><span class="line"></span><br><span class="line">	直角三角形斜边的平方等于两腰的平方和。</span><br><span class="line"></span><br><span class="line">	可以用符号语言表述为: 设直角三角形 <span class="formula">$ABC$</span>, 其中 <span class="formula">$<span class="tag">\<span class="name">angle</span></span> C=90<span class="tag">\<span class="name">degree</span></span>$</span>, 则有:</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{equation}</span></span></span><br><span class="line">	AB^2 = BC^2 + AC^2.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{equation}</span></span></span><br><span class="line">	<span class="comment">%引入equation环境 相当于$$符号</span></span><br><span class="line">	<span class="comment">%注意angle C 之间需要有空格</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="4-LaTeX的字体设置">
          <a href="#4-LaTeX的字体设置" class="heading-link"><i class="fas fa-link"></i></a>4.LaTeX的字体设置</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">在LaTeX中，一个字体有5中属性:</span><br><span class="line"> 1.字体编码</span><br><span class="line">   正文字体编码: OT1、T1、EU1等</span><br><span class="line">   数字字体编码: OML、OMS、OMX等</span><br><span class="line"> 2.字体族</span><br><span class="line">   罗马字体: 笔画起始处有装饰</span><br><span class="line">   <span class="tag">\<span class="name">textrm</span><span class="string">{Roman Family}</span></span></span><br><span class="line">   <span class="tag">\<span class="name">rmfamily</span></span> Roman Family </span><br><span class="line">   无衬线字体: 笔画起始处无装饰</span><br><span class="line">   <span class="tag">\<span class="name">textsf</span><span class="string">{Sans Serif Family}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">sffamily</span></span> Sans Serif Family}</span><br><span class="line">   打字机字体: 每个字符宽度 </span><br><span class="line">   <span class="tag">\<span class="name">texttt</span><span class="string">{Typewriter Family}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">ttfamily</span></span> Typewriter Family}</span><br><span class="line"> 3.字体系列</span><br><span class="line"> 	粗细</span><br><span class="line"> 	<span class="tag">\<span class="name">textmd</span><span class="string">{Medium Series}</span></span></span><br><span class="line"> 	{<span class="tag">\<span class="name">mdseries</span></span> Medium Series}</span><br><span class="line"> 	宽度</span><br><span class="line"> 	<span class="tag">\<span class="name">textbf</span><span class="string">{Boldface Series}</span></span></span><br><span class="line"> 	{<span class="tag">\<span class="name">bfseries</span></span> Boldface Series}</span><br><span class="line"> 4.字体形状</span><br><span class="line">   直立</span><br><span class="line">   <span class="tag">\<span class="name">textup</span><span class="string">{Upright Shape}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">upshape</span></span> Upright Shape}</span><br><span class="line">   斜体</span><br><span class="line">   <span class="tag">\<span class="name">textit</span><span class="string">{Italic Shape}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">itshape</span></span> Italic Shape}</span><br><span class="line">   伪斜体</span><br><span class="line">   <span class="tag">\<span class="name">textsl</span><span class="string">{Slanted Shape}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">slshape</span></span> Slanted Shape}</span><br><span class="line">   小型大写</span><br><span class="line">   <span class="tag">\<span class="name">textsc</span><span class="string">{Small Caps Shape}</span></span></span><br><span class="line">   {<span class="tag">\<span class="name">scshape</span></span> Small Caps Shape}</span><br><span class="line"> 5.字体大小</span><br><span class="line"> 参看文档</span><br><span class="line"> 6.中文字体</span><br><span class="line"> <span class="comment">%需要使用ctex宏包</span></span><br><span class="line"> {<span class="tag">\<span class="name">songti</span></span> 宋体}</span><br><span class="line"> {<span class="tag">\<span class="name">heiti</span></span> 黑体}</span><br><span class="line"> {<span class="tag">\<span class="name">fangsong</span></span> 仿宋} </span><br><span class="line"> {<span class="tag">\<span class="name">kaisu</span></span> 楷书} 	</span><br><span class="line"> <span class="comment">%\quad表示空格</span></span><br><span class="line"> <span class="comment">%\\表示换行</span></span><br><span class="line"> <span class="comment">%通常定义命令来实现字体操作</span></span><br><span class="line"> <span class="tag">\<span class="name">newcommand</span><span class="string">{\myfont}</span><span class="string">{\textit{\textbf{\textsf{Fancy Text}</span></span>}}}</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="5-LaTeX的篇章结构">
          <a href="#5-LaTeX的篇章结构" class="heading-link"><i class="fas fa-link"></i></a>5.LaTeX的篇章结构</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">   <span class="comment">%导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">{ctexbook}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%\usepackage{ctex} </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%在导言区可以使用ctexset进行格式设置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%正文区</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">chapter</span><span class="string">{实验与结果分析}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">{引言}</span></span> <span class="comment">%小结 </span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">{实验方法}</span></span>  </span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">{实验结果}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">{数据}</span></span> <span class="comment">%子小结</span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">{图表}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsubsection</span><span class="string">{实验条件}</span></span> <span class="comment">%子子小结</span></span><br><span class="line">  	<span class="tag">\<span class="name">subsubsection</span><span class="string">{实验过程}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">{结果分析}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">{结论}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">{致谢}</span></span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">%题干构建 </span></span><br><span class="line">  	<span class="comment">%\par 实现另起段落</span></span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="6-LaTeX中的特殊字符">
          <a href="#6-LaTeX中的特殊字符" class="heading-link"><i class="fas fa-link"></i></a>6.LaTeX中的特殊字符</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">  <span class="comment">%导言区</span></span><br><span class="line"> <span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span></span><br><span class="line"> <span class="tag">\<span class="name">usepackage</span><span class="string">{ctex}</span></span> <span class="comment">% 中文处理宏包</span></span><br><span class="line"> <span class="tag">\<span class="name">usepackage</span><span class="string">{xltxtra}</span></span> <span class="comment">%提供了针对XeTeX的改进并且加入XeTeX的LOGO</span></span><br><span class="line"> <span class="comment">% 正文区（文稿区）</span></span><br><span class="line"> <span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{空白符号}</span></span></span><br><span class="line"> 	<span class="comment">% 空行分段，多个空行等同1个</span></span><br><span class="line"> 	<span class="comment">% 自动缩进，绝对不能使用空格代替</span></span><br><span class="line"> 	<span class="comment">% 英文中多个空格处理为1个空格，中文中空格将被忽略</span></span><br><span class="line"><span class="comment">% 汉字与其它字符的间距会自动由XeLaTeX处理</span></span><br><span class="line"><span class="comment">% 禁止使用中文全角空格</span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{\LaTeX 控制符}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">#</span></span> <span class="tag">\<span class="name">$</span></span> <span class="tag">\<span class="name">%</span></span> <span class="tag">\<span class="name">{</span></span> <span class="tag">\<span class="name">}</span></span> <span class="tag">\<span class="name">~</span><span class="string">{}</span></span> <span class="tag">\<span class="name">_</span><span class="string">{}</span></span> <span class="tag">\<span class="name">^</span><span class="string">{}</span></span> <span class="tag">\<span class="name">textbackslash</span></span> <span class="tag">\<span class="name">&amp;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{排版符号}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">S</span></span> <span class="tag">\<span class="name">P</span></span> <span class="tag">\<span class="name">dag</span></span> <span class="tag">\<span class="name">ddag</span></span> <span class="tag">\<span class="name">copyright</span></span> <span class="tag">\<span class="name">pounds</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{\TeX 标志符号}</span></span></span><br><span class="line"> 	<span class="comment">%基本符号</span></span><br><span class="line"> 	<span class="tag">\<span class="name">TeX</span><span class="string">{}</span></span> <span class="tag">\<span class="name">LaTeX</span><span class="string">{}</span></span> <span class="tag">\<span class="name">LaTeXe</span><span class="string">{}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">XeLaTeX</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{引号}</span></span></span><br><span class="line"> 	‘ ’ “ ”</span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{连字符}</span></span></span><br><span class="line"> 	- -- ---</span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{非英文字符}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">oe</span></span> <span class="tag">\<span class="name">OE</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">{重音符号(以o为例)}</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">`</span></span>o</span><br><span class="line"> <span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="7-LaTeX中的插图">
          <a href="#7-LaTeX中的插图" class="heading-link"><i class="fas fa-link"></i></a>7.LaTeX中的插图</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"><span class="comment">%\usepackage{ctex}</span></span><br><span class="line"><span class="comment">% 导言区: \usepackage{graphicx}</span></span><br><span class="line"><span class="comment">% 语  法: \includegraphics[&lt;选项&gt;]{&lt;文件名&gt;}</span></span><br><span class="line"><span class="comment">% 格  式: EPS,PDF,PNG,JPEG,BMP</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{graphicx}</span></span>	</span><br><span class="line"><span class="tag">\<span class="name">graphicspath</span><span class="string">{{figures/}</span></span>}<span class="comment">% 此处需要双括号</span></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line"><span class="tag">\<span class="name">LaTeX</span><span class="string">{}</span></span>中的插图:</span><br><span class="line"><span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=0.25]</span><span class="string">{wallpaper}</span></span><span class="comment">% 输入图片名,指定缩放因子</span></span><br><span class="line"><span class="comment">%\includegraphics[height=5cm]{wallpaper}</span></span><br><span class="line"><span class="comment">%\includegraphics[width=10cm]{wallpaper}</span></span><br><span class="line"><span class="comment">%使用texdoc graphicx 查看文档</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="8-LaTeX中的表格">
          <a href="#8-LaTeX中的表格" class="heading-link"><i class="fas fa-link"></i></a>8.LaTeX中的表格</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">	  <span class="comment">% 导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  <span class="comment">%\usepackage{ctex}</span></span><br><span class="line">  <span class="comment">% 正文区（文稿区）</span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">{tabular}</span><span class="string">{|l|c|c|c|p{1.5cm}</span></span>|}</span><br><span class="line">  		<span class="comment">% l 左对齐 c 居中对齐 r 右对齐 | 产生表格竖线 </span></span><br><span class="line">  		<span class="comment">%空格不起作用 p{&lt;宽&gt;}指定宽度 </span></span><br><span class="line">  		<span class="comment">%当内容超出时自动换行 &amp; 表示不同列</span></span><br><span class="line">  		<span class="comment">%texdoc booktab</span></span><br><span class="line">  		<span class="comment">%texdoc longtab</span></span><br><span class="line">  		<span class="comment">%texdoc tabu</span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		王二 &amp; 80 &amp; 82 &amp; 78 &amp; <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		  	</span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">{tabular}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="9-LaTeX中的浮动体">
          <a href="#9-LaTeX中的浮动体" class="heading-link"><i class="fas fa-link"></i></a>9.LaTeX中的浮动体</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">% 导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  <span class="tag">\<span class="name">usepackage</span><span class="string">{graphicx}</span></span>	</span><br><span class="line">  <span class="tag">\<span class="name">graphicspath</span><span class="string">{figures/}</span></span></span><br><span class="line">  <span class="comment">%\usepackage{ctex}</span></span><br><span class="line">  <span class="comment">% 正文区（文稿区）</span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">  	电脑壁纸见图<span class="tag">\<span class="name">ref</span><span class="string">{fig-wallpaper}</span></span><span class="comment">% 实现交叉引用</span></span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">{figure}</span><span class="string">[htbp]</span></span><span class="comment">%图形位置 h 当前位置 t 顶部 b 底部 p 浮动页</span></span><br><span class="line">  		<span class="tag">\<span class="name">centering</span></span> <span class="comment">% 居中排列</span></span><br><span class="line">  		<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=0.25]</span><span class="string">{wallpaper}</span></span><span class="comment">% 输入图片名,指定缩放因子</span></span><br><span class="line">  		<span class="tag">\<span class="name">caption</span><span class="string">{WallPaper}</span></span><span class="tag">\<span class="name">label</span><span class="string">{fig-wallpaper}</span></span> <span class="comment">%设置图片名字 设置浮动体标签</span></span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">{figure}</span></span></span><br><span class="line">  	</span><br><span class="line">  	当然，在<span class="tag">\<span class="name">LaTeX</span><span class="string">{}</span></span>中也如以下使用表<span class="tag">\<span class="name">ref</span><span class="string">{tab-score}</span></span>所示的表格</span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">{table}</span><span class="string">[h]</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">caption</span><span class="string">{考试成绩单}</span></span><span class="tag">\<span class="name">label</span><span class="string">{tab-score}</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">begin</span><span class="string">{tabular}</span><span class="string">{|l|c|c|c|r|}</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			王二 &amp; 80 &amp; 82 &amp; 78 &amp; <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线	</span></span><br><span class="line">  		<span class="tag">\<span class="name">end</span><span class="string">{tabular}</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">{table}</span></span></span><br><span class="line">  	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="10-LaTeX数学公式初步">
          <a href="#10-LaTeX数学公式初步" class="heading-link"><i class="fas fa-link"></i></a>10.LaTeX数学公式初步</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{article}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{ctex}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{amsmath}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{简介}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">LaTeX</span><span class="string">{}</span></span>将排版内容分为文本模式和数学模式。文本模式用于普通文本排版，数学模式用于数学公式排版。</span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{行内公式}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{美元符号}</span></span></span><br><span class="line">	交换律是 <span class="formula">$a+b=b+a$</span>,如 <span class="formula">$1+2=2+1=3$</span>。</span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{小括号}</span></span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">(</span></span>a+b=b+a<span class="tag">\<span class="name">)</span></span>,如 <span class="tag">\<span class="name">(</span></span>1+2=2+1=3<span class="tag">\<span class="name">)</span></span>。</span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{math环境}</span></span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">begin</span><span class="string">{math}</span></span>a+b=b+a<span class="tag">\<span class="name">end</span><span class="string">{math}</span></span>,如<span class="tag">\<span class="name">begin</span><span class="string">{math}</span></span></span><br><span class="line">	1+2=2+1=3<span class="tag">\<span class="name">end</span><span class="string">{math}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{上下标}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{上标}</span></span></span><br><span class="line">	<span class="formula">$3x^{20} - x + 2 = 0$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$3x^{3x^{20} - x + 2} - x + 2 = 0$</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{下标}</span></span></span><br><span class="line">	<span class="formula">$a_0,a_1,a_2$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$a_0,a_1,a_2,...,a_{3x^{20} - x + 2}$</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{希腊字母}</span></span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">alpha</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">beta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">gamma</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">epsilon</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">pi</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">omega</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Gamma</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Delta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Theta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Pi</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Omega</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">alpha</span></span>^3 + <span class="tag">\<span class="name">beta</span></span>^2 + <span class="tag">\<span class="name">gamma</span> = <span class="number">0</span></span>$</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{数字函数}</span></span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">log</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sin</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">cos</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">arcsin</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">arccos</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">ln</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sin</span></span>^2 x + <span class="tag">\<span class="name">cos</span></span>^2 x = 1$</span></span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">arcsin</span></span> x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">sin</span></span>^{-1} x$</span> </span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">log</span></span>_2 x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">ln</span></span> x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">{2}</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">{x^2 + y^2}</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">{2 + \sqrt{2}</span></span>}$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">[4]</span><span class="string">{x}</span></span>$</span> <span class="comment">%通过[]指定开方的次数</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{分式}</span></span></span><br><span class="line">	大约是原体积的<span class="formula">$3/4$</span>。</span><br><span class="line">	大约是原体积的<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">{3}</span><span class="string">{4}</span></span>$</span>。</span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">{x}</span><span class="string">{x^2 + x +1}</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">{\sqrt{x-1}</span></span>}{<span class="tag">\<span class="name">sqrt</span><span class="string">{x+1}</span></span>}$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">{1}</span><span class="string">{1+ \frac{1}</span><span class="string">{x}</span></span>}$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">{\frac{x}</span><span class="string">{x^2 + x + 1}</span></span>}$</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">{行间公式}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{美元符号}</span></span></span><br><span class="line">	交换律是 <span class="formula">$$a+b=b+a$$</span></span><br><span class="line">	如 <span class="formula">$$1+2=2+1=3$$</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{中括号}</span></span></span><br><span class="line">	 <span class="tag">\<span class="name">[</span></span>a+b=b+a<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	 如</span><br><span class="line">	 <span class="tag">\<span class="name">[</span></span>1+2=2+1=3<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{displaymath环境}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{displaymath}</span></span></span><br><span class="line">		a+b=b+a,</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{displaymath}</span></span>,</span><br><span class="line">	如</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{displaymath}</span></span></span><br><span class="line">		1+2=2+1=3.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{displaymath}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{自动编号公式equation环境}</span></span></span><br><span class="line">	交换律见式<span class="tag">\<span class="name">ref</span><span class="string">{eq:commutative}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{equation}</span></span></span><br><span class="line">		a+b=b+a <span class="tag">\<span class="name">label</span><span class="string">{eq:commutative}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{equation}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">{不编号公式equation*环境}</span></span></span><br><span class="line">	交换律见式<span class="tag">\<span class="name">ref</span><span class="string">{eq:commutative2}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{equation*}</span></span></span><br><span class="line">	a+b=b+a <span class="tag">\<span class="name">label</span><span class="string">{eq:commutative2}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{equation*}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="11-LaTeX数学公式的矩阵">
          <a href="#11-LaTeX数学公式的矩阵" class="heading-link"><i class="fas fa-link"></i></a>11.LaTeX数学公式的矩阵</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"><span class="comment">%\usepackage{ctex}</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{amsmath}</span></span></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">	<span class="comment">%矩阵环境，用&amp;分隔列，用\\分隔行</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{matrix}</span></span></span><br><span class="line">	0 &amp; 1<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	1 &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{matrix}</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% pmatrix环境 加小括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{pmatrix}</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{pmatrix}</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% bmatrix环境 加中括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{bmatrix}</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{bmatrix}</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% Bmatrix环境 加大括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{Bmatrix}</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{Bmatrix}</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% vmatrix环境 加单竖线</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{vmatrix}</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{vmatrix}</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% Vmatrix环境 加双竖线</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{Vmatrix}</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{Vmatrix}</span></span> </span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% 可以使用上下标</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	A = <span class="tag">\<span class="name">begin</span><span class="string">{pmatrix}</span></span></span><br><span class="line">	a_{11}^2 &amp; a_{12}^2 &amp; a_{13}^2 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; a_{22} &amp; a_{23} <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; 0 &amp; a_{33}</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{pmatrix}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">%常用省略号：\dots,\vdots,\ddots</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	A = <span class="tag">\<span class="name">begin</span><span class="string">{pmatrix}</span></span></span><br><span class="line">	a_{11} &amp; <span class="tag">\<span class="name">dots</span></span> &amp; a_{1n} <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; &amp; a_{mn}</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{pmatrix}</span></span>_{n <span class="tag">\<span class="name">times</span></span> n}<span class="comment">% times命令排版乘号</span></span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="12-LaTeX中的多行数学公式">
          <a href="#12-LaTeX中的多行数学公式" class="heading-link"><i class="fas fa-link"></i></a>12.LaTeX中的多行数学公式</h2>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%\usepackage{ctex}</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{amsmath}</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">{amssymb}</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">	<span class="comment">% gather 和 gather* 环境 (可以使用\\换行)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{gather}</span></span></span><br><span class="line">		a + b = b + a <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		ab ba</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{gather}</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 不带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{gather*}</span></span></span><br><span class="line">	3+5 = 5+3 = 8 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	3 <span class="tag">\<span class="name">times</span></span> 5 = 5 <span class="tag">\<span class="name">times</span></span> 3</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{gather*}</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 在\\前使用\notag 阻止编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{gather}</span></span></span><br><span class="line">		3^2 + 4^2 = 5^2 <span class="tag">\<span class="name">notag</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		5^2 + 12^2 = 13^2 <span class="tag">\<span class="name">notag</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		a^2 + b^2 = c^2 </span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{gather}</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% align 和 align* 环境 (用 &amp; 进行对齐)</span></span><br><span class="line">	<span class="comment">% 带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{align}</span></span></span><br><span class="line">	x &amp;= t + <span class="tag">\<span class="name">cos</span></span> t + 1 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	y &amp;= 2<span class="tag">\<span class="name">sin</span></span> t</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{align}</span></span></span><br><span class="line">	<span class="comment">% 不带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{align*}</span></span></span><br><span class="line">		x &amp;= t &amp; x &amp;= <span class="tag">\<span class="name">cos</span></span> t &amp; x &amp;= t <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		y &amp;= 2t &amp; y &amp;= <span class="tag">\<span class="name">sin</span></span>(t+1) &amp; y &amp;= <span class="tag">\<span class="name">sin</span></span> t </span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{align*}</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% split 环境(对齐采用 align 环境的方式，编号在中间)</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{equation}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{split}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">cos</span></span> 2x &amp;= <span class="tag">\<span class="name">cos</span></span>^2 x - <span class="tag">\<span class="name">sin</span></span>^2 x <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&amp;= 2<span class="tag">\<span class="name">cos</span></span>^2 x - 1</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{split}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{equation}</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% cases 环境</span></span><br><span class="line">	<span class="comment">% 每行公式中使用 &amp;　分隔为两部分，</span></span><br><span class="line">	<span class="comment">%　通常表示值和后面的条件</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{equation}</span></span></span><br><span class="line">		D(x) = <span class="tag">\<span class="name">begin</span><span class="string">{cases}</span></span></span><br><span class="line">		1, &amp; <span class="tag">\<span class="name">text</span><span class="string">{如果 }</span></span> x <span class="tag">\<span class="name">in</span></span> <span class="tag">\<span class="name">mathbb</span><span class="string">{Q}</span></span>; <span class="tag">\<span class="name">\</span></span> <span class="comment">%\in 用于输出属于符号 mathbb用于输出花体字符 \text{} 用于在数学模式中输入中文</span></span><br><span class="line">		0, &amp; <span class="tag">\<span class="name">text</span><span class="string">{如果 }</span></span> x <span class="tag">\<span class="name">in</span></span> <span class="tag">\<span class="name">mathbb</span><span class="string">{R}</span></span><span class="tag">\<span class="name">setminus</span></span><span class="tag">\<span class="name">mathbb</span><span class="string">{Q}</span></span>.</span><br><span class="line">		<span class="tag">\<span class="name">end</span><span class="string">{cases}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{equation}</span></span> </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="13-LaTeX中的参考文献——BibTex">
          <a href="#13-LaTeX中的参考文献——BibTex" class="heading-link"><i class="fas fa-link"></i></a>13.LaTeX中的参考文献——BibTex</h2>
      <ol>
<li>在构件中设置默认文献工具为BibTex</li>
<li>在谷歌学术中点击引用链接获取BibTex格式的数据</li>
<li>新建.bib后缀的文件，复制获取参考文献数据</li>
</ol>

        <h3 id="tex文件如下">
          <a href="#tex文件如下" class="heading-link"><i class="fas fa-link"></i></a>.tex文件如下</h3>
      <figure class="highlight tex"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">{ctexart}</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%\usepackage{ctex}</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">bibliographystyle</span><span class="string">{plain}</span></span><span class="comment">%指定排版样式 如plain unsrt alpha abbrv</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">{document}</span></span></span><br><span class="line">	<span class="comment">%一次管理，一次使用</span></span><br><span class="line">	<span class="comment">%参考文献格式：</span></span><br><span class="line">	<span class="comment">%\begin{thebibliography}{编号样本}</span></span><br><span class="line">	<span class="comment">%	\bibitem[label]{citekey}文献条目1</span></span><br><span class="line">	<span class="comment">%   \bibitem[label]{citekey}文献条目2</span></span><br><span class="line">	<span class="comment">%	……</span></span><br><span class="line">	<span class="comment">%\end{thebibliography}</span></span><br><span class="line">	<span class="comment">%其中文献条目包括：作者，题目，出版社，年代，版本，页码等。</span></span><br><span class="line">	<span class="comment">%引用时候要可以采用：\cite{引用标志1，引用标志2，……}</span></span><br><span class="line">	引用一本Guide<span class="tag">\<span class="name">cite</span><span class="string">{latexGuide}</span></span>等等</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">{thebibliography}</span><span class="string">{99}</span></span></span><br><span class="line">		<span class="tag">\<span class="name">bibitem</span><span class="string">{latexGuide}</span></span> Kopka Helmut, W. Daly Patrick,</span><br><span class="line">		<span class="tag">\<span class="name">emph</span><span class="string">{Guide to \LaTeX}</span></span>, <span class="formula">$4^{th}$</span> Edition.</span><br><span class="line">		Available at <span class="tag">\<span class="name">texttt</span><span class="string">{http://www.amazon.com}</span></span>.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">{thebibliography}</span></span></span><br><span class="line">	这是一个参考文献的引用：<span class="tag">\<span class="name">cite</span><span class="string">{scott1988social}</span></span></span><br><span class="line">	<span class="tag">\<span class="name">bibliography</span><span class="string">{test}</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">{document}</span></span></span><br></pre></td></tr></tbody></table></div></figure>


        <h3 id="bib文件如下">
          <a href="#bib文件如下" class="heading-link"><i class="fas fa-link"></i></a>.bib文件如下</h3>
      <figure class="highlight routeros"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line">  @article{scott1988social,</span><br><span class="line">  title={Social<span class="built_in"> network </span>analysis},</span><br><span class="line">  author={Scott, John},</span><br><span class="line">  journal={Sociology},</span><br><span class="line">  volume={22},</span><br><span class="line">  number={1},</span><br><span class="line">  pages={109--127},</span><br><span class="line">  year={1988},</span><br><span class="line">  publisher={British Sociological Association Publications Limited}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></div></figure>


        <h2 id="15-LaTeX中定义新命令和环境">
          <a href="#15-LaTeX中定义新命令和环境" class="heading-link"><i class="fas fa-link"></i></a>15.LaTeX中定义新命令和环境</h2>
      <figure class="highlight markdown"><div class="table-container"><table><tbody><tr><td class="code"><pre><span class="line"><span class="code">	% 导言区</span></span><br><span class="line">\documentclass{ctexart}%ctexbook, ctexrep</span><br><span class="line"></span><br><span class="line">% \newcommand{cmd}{def}定义命令</span><br><span class="line">% 命令只能由字母组成，不能以\end 开头</span><br><span class="line">% \newcommand{命令}[<span class="string">参数个数</span>][<span class="symbol">首字母默认值</span>]{具体定义}</span><br><span class="line"></span><br><span class="line">% \newcommand可以是简单字符串替代，例如：</span><br><span class="line">% 使用\PRC 相当于 People's Republic of \emph{China} 这一串内容</span><br><span class="line">\newcommand\PRC{People's Republic of \emph{China}}%\emph{text}表示强调</span><br><span class="line"></span><br><span class="line">% \newcommand也可以使用参数</span><br><span class="line">% 参数个数可以从1到9，使用时用 #1，#2，……，#9 表示</span><br><span class="line">\newcommand\loves[2]{#1 喜欢 #2}</span><br><span class="line">\newcommand\hatedby[2]{#2 不受 #1 喜欢}</span><br><span class="line"></span><br><span class="line">% \newcommand的参数也可以有默认值</span><br><span class="line">% 指定参数个数的同时指定了首个参数的默认值，那么这个命令的</span><br><span class="line">% 第一个参数就成为可选的参数(要使用中括号指定)</span><br><span class="line">\newcommand\love[<span class="string">3</span>][<span class="symbol">喜欢</span>]{#2#1#3}</span><br><span class="line"></span><br><span class="line">% \renewcommand-重定义命令</span><br><span class="line">% 与\newcommand 命令作用和用法相同，但只能用于已有命令</span><br><span class="line">% \renewcommand{cmd}[<span class="string">args</span>][<span class="symbol">default</span>]{def}</span><br><span class="line">\renewcommand\abstractname{内容简介}</span><br><span class="line"></span><br><span class="line">% 定义和重定义环境</span><br><span class="line">% \newenvironment{name}[<span class="string">args</span>][<span class="symbol">default</span>]{begdef}{enddef}</span><br><span class="line">% \renewenvironment{name}[<span class="string">args</span>][<span class="symbol">default</span>]{begdef}{enddef}</span><br><span class="line"></span><br><span class="line">% 为 book 类中定义摘要(abstract) 环境</span><br><span class="line">\newenvironment{myabstract}[<span class="string">1</span>][<span class="symbol">摘要</span>]%</span><br><span class="line">{\small</span><br><span class="line"><span class="code">	\begin{center}\bfseries #1\end{center}%</span></span><br><span class="line"><span class="code">	\begin{quotation}}%</span></span><br><span class="line">{	</span><br><span class="line"><span class="code">	\end{quotation}</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">% 正文区（文稿区）</span><br><span class="line">\begin{document}</span><br><span class="line"><span class="code">	\PRC</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\loves{猫儿}{鱼}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\hatedby{猫儿}{萝卜}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\love{猫儿}{鱼}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\love[最爱]{猫儿}{鱼}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\begin{abstract}</span></span><br><span class="line"><span class="code">		这是一段摘要...</span></span><br><span class="line"><span class="code">	\end{abstract}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\begin{myabstract}[我的摘要]</span></span><br><span class="line"><span class="code">		这是一段自定义格式的摘要...</span></span><br><span class="line"><span class="code">	\end{myabstract}</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line">\end{document}</span><br></pre></td></tr></tbody></table></div></figure>


        <h1 id="完整的演示代码见Github仓库https-github-com-Gemini-Lin-MCM-ICM">
          <a href="#完整的演示代码见Github仓库https-github-com-Gemini-Lin-MCM-ICM" class="heading-link"><i class="fas fa-link"></i></a>完整的演示代码见Github仓库https://github.com/Gemini-Lin/MCM-ICM</h1>
      <script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>数学建模</category>
        <category>Latex</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌访问助手</title>
    <url>/%E8%B0%B7%E6%AD%8C%E6%9C%8D%E5%8A%A1%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<h1 id="谷歌访问助手插件安装">
          <a href="#谷歌访问助手插件安装" class="heading-link"><i class="fas fa-link"></i></a>谷歌访问助手插件安装</h1>
      <p>1.<span class="exturl"><a class="exturl__link" href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">点击文字安装谷歌浏览器</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<p>2.<span class="exturl"><a class="exturl__link" href="https://github.com/Gemini-Lin/Tookits" target="_blank" rel="noopener">点击文字下载谷歌访问助手</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<a id="more"></a>
<p>3.安装谷歌访问助手插件<br> 
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GVceEt.png" alt="GVceEt.png">
      </p>
<blockquote>
<p>Step1: 进入谷歌浏览器的扩展程序</p>
</blockquote>
<blockquote>
<p>Step2: 勾选开发者选项</p>
</blockquote>
<blockquote>
<p>Step3: 点击加载已解压的扩展程序</p>
</blockquote>
<blockquote>
<p>Step4: 选择下载后解压的文件</p>
</blockquote>
<blockquote>
<p>Step5: 安装成功<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GVcM8S.png" alt="GVcM8S.png">
      <br> 
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GVcQgg.png" alt="GVcQgg.png">
      </p>
</blockquote>

        <h2 id="VPN推荐">
          <a href="#VPN推荐" class="heading-link"><i class="fas fa-link"></i></a>VPN推荐</h2>
      <p>20元一个月，特别稳定，网速快。</p>
<p><span class="exturl"><a class="exturl__link" href="https://efanccyun.net/" target="_blank" rel="noopener">饿饭CC云</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期支教</title>
    <url>/%E6%94%AF%E6%95%99/</url>
    <content><![CDATA[<p> <strong><em>让我再看看你们</em></strong>  </p>
<blockquote>
<p><strong>“让我再看看你们”</strong>这是我在黑板上留下的最后一句话。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/03/29/eGFf2H6Y1Lvw5VT.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p>这支教半个月来，我们从陌生到相识相知再到现在转身离别。<strong>这既是与学生，亦是与队员</strong>。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>我很抱歉，在这半个月里并没有认识班上所有的小孩，有些只局限于名字。<strong>每个人心中都有一团火，路过的人都只看到烟。</strong>这是我给班上的38个孩子写完明信片后的感慨。我若看到他们心中的火，就会说一些出于真心的废话，絮絮叨叨；我若只看到他们心中的烟，便只有一些泛泛而谈的寄语，满腹诗论。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/03/29/MBjHLwJ7NhioCOy.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p>支教的这半个月，自己最大的体会是孩子并不是天使，他们也有着人类阴暗与丑陋的一面。比如班上的一个女孩陈柯欣，她的脑袋有点问题，全班的小朋友都远离她，没人愿意和她一起玩。而我呢？会站在上帝视角上看待这一切，忘记自己小时候也是这副模样，甚至现在也未必改变。</p>
</blockquote>
<blockquote>
<p>对于孩子而言，最可怕的是他们腐朽的思想。尽管我也是生活在农村，但是这里的学习氛围与家里天壤之别。这里还保留着读完初中就外出打工的腐朽思想。父母对于孩子的学习，关注实在太少太少。我意识到自己仅仅给孩子们传授知识是远远不够的，我必须给他们强调学习的重要性。因此在支教的后半段，我每天都给孩子们普及大学的知识。先给他们看看北大的宣传片《星空日记》和《北大体验》，看到《星空日记》时，我也想起我自己高二的时候，看到北大的宣传片满腔热血，奔向未来，现在的我却离梦想渐行渐远了。看到《北大体验》，我的脑海里不停回荡这那句“在北大生活是一种什么样的体验，北大等着你来体验”，在我的内心深处还残存着对北大的愿景。<strong>你自由，而在一片向上生长的林中，你不会歪斜，但我失去了你，只敢在梦里拥抱着你。</strong>然后我给他们看了一下成电的招生宣传片，和一系列成电的照片，用自己在大学生活的感受去感染他们。我希望自己用着些举动，能够在他们的心中种下名为“大学”的种子。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/04/18/mIkGb1exLlwTyMJ.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p><strong>“即使有一天我失去了所有，但在祖国的大西部，我还有一群可爱的孩子”</strong>写于在教室前目送孩子们离去，我对他们大喊：“今天我就不送你们了，今后的路你们要自己走了。”</p>
</blockquote>
<blockquote>
<p><strong>“支教真的有意义吗？”</strong>这是我在支教路上在知乎关注的一个问题，今天在支教生涯结束时，我要用自己的方式给出回答。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://i.loli.net/2020/03/29/zFaUuGHbLNn7RSe.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p>谈支教是否有意义，最为关键的问题是你是如何看待支教的，你到底为支教付出了多少。回顾我们至微这四个月为支教的筹备，一进队最为强调的一点是<strong>“支教对于你的收获是远远大于你给孩子的收获”</strong>，这一路来，我们经历了两周的义捐义卖，两天的高考文具募捐，两周的课程试讲，再到两周的正式支教。再谈我是如何看待支教的，在我的心里这是小时候的愿景，是社会的公益给我的驱使。我想要通过支教让山里的孩子们明白，他们所看到的仅仅是世界的很小一部分，他们应该去更高更远的地方，去好好看看这世界。因此，我可以确切地回答，支教是绝对有意义的。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GV61Tx.png" alt="image.png">
      </p>
</blockquote>
<blockquote>
<p>其实支教对我影响最大的不是<strong>支教本身，而是我身旁一起陪伴的十五名队员。</strong>当你身处在一个大环境中时，你会自然而然地被环境所影响。先谈谈舒队，作为队长，他需要把握团队的大局走向，最为关键的是控制一个“度”，比如伙食的质量，放松的时间，上课的课程，活动的安排。我印象最深的是，当我在过渡放纵的时候，会有一个改变以往逗比的形象的人，严肃地和你强调支教是为了什么。从支教的过程中，同时也是从队友的身上，发现自己的不足，便是我此行最大的收获。比如对于支教日志的撰写上，有的队友每天坚持记录至少1500字的日志，尽管里面的很多内容是记流水账，但是对于这件事上她是付出了大量的时间，与我每次几百字的支教日志形成了极大的反差。再比如活动组的成员，在每次活动前都会周密的安排，加班到凌晨一两点，相反的是我十一点多就回到了寝室。从他们的身上，我发现了优秀的原因，同时也解决我一直以来的困惑。简而言之，就是对于事情的专注，对于一件事情，做的时候必须竭尽全力、心无旁骛，这样结束时才可以尽情放松。对于学习亦是如此，我总是把学习挂在嘴边，但是每天真正学习的时长却总是很短，看似每天都在学习，其实两天的学习效率抵不过别人的一天，自然放松的时候也不能尽兴。<br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GV6rAP.jpg" alt="GV6rAP.jpg">
      </p>
</blockquote>
<blockquote>
<p>最后再回到支教本身来，谈谈这群我可能再也不会相见的38个孩子们。其实离别的时候，没有孩子流泪，我还是比较难过的，即使我确实不希望哭丧着离别，但可能是因为我对班上的孩子们付出还是太少了。作为四年级的班主任，我明显感受到自己与班上孩子的感情与任课老师差别很大的，每天一大半的时间，我都会陪在这群孩子身边。今天的最后一堂课，我和副班主任们，都和孩子们讲了一些煽情的话，关于回顾，关于离别，关于未来。我让孩子们把自己的名字都写在黑板上，让我记住他们，同时我也在黑板上写下<strong>“你这一生，我只送一程；不忍离别，但车已到站”。</strong>借用龙应台的一句话，<strong>我慢慢地、慢慢地了解到，所谓师生一场，只不过意味着，你和他们的缘分就是今生今世目送着他们的背影渐行渐远。你站在小路的这一段，看着他逐渐消失在小路转弯的地方，而且，他们用背影默默告诉你：不必追。</strong><br>
        <img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://s1.ax1x.com/2020/03/29/GV6g1g.jpg" alt="GV6g1g.jpg">
      </p>
</blockquote>
<p><strong>未来</strong></p>
<p><strong>我让你成为你</strong></p>
<p><strong>你梦着我的梦</strong></p>
<p><strong>我写着你的诗</strong></p>
<p><strong>你点亮我的天空</strong></p>
<p><strong>我闪耀你的眼睛</strong></p>
<p><strong>从此，</strong></p>
<p><strong>山谷里多了一片</strong></p>
<p><strong>彩色森林</strong></p>
<blockquote>
<p>（这首诗送给支教的孩子们，亦是支教感悟的终点）<br><span class="exturl"><a class="exturl__link" href="https://weibo.com/u/2694121201?is_all=1" target="_blank" rel="noopener">至微公益团队微博</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</blockquote>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>大学生活</category>
        <category>支教</category>
      </categories>
      <tags>
        <tag>体验</tag>
        <tag>支教</tag>
      </tags>
  </entry>
</search>
