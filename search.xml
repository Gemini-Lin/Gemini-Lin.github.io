<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Operating System(2)</title>
    <url>/Operating-System-2/</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程是系统进行资源分配和调度的一个独立单位。<br>进程控制块(Process Control Block,PCB)描述进程的基本信息和活动过程，进而控制进程和管理进程。<br>特征：动态性、并发性、独立性、异步性。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程作为调度和分派的基本单位。<br>线程是进程的进一步划分，一个进程可以有多个线程，他们共享进程资源。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><ol>
<li>进程是资源分配的基本单位，但是线程不拥有系统资源，仅有少量能保证独立运行的资源。(一些必备的寄存器，如程序计数器等)同时线程共享进程的资源。</li>
<li>进程的切换开销大，线程是独立调动的基本单位，切换线程的开销更小。<a id="more"></a>
<h2 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h2><img src="https://s1.ax1x.com/2020/06/12/tLBcTI.png" alt="五种状态转换"></li>
</ol>
<ul>
<li>就绪状态：资源已经准备好了，就差CPU调度</li>
<li>阻塞状态：被某些事件给中断了，缺少必要的资源(除CPU时间)</li>
</ul>
<h3 id="挂起与激活"><a href="#挂起与激活" class="headerlink" title="挂起与激活"></a>挂起与激活</h3><p><img src="https://s1.ax1x.com/2020/06/12/tLDjUI.png" alt="挂起与激活"></p>
<ul>
<li>若进程处于就绪状态，挂起操作执行后，则由活动就绪转为禁止就绪</li>
<li>若进程处于阻塞状态，挂起操作执行后，则由活动阻塞转为禁止阻塞</li>
</ul>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><h3 id="1-临界区"><a href="#1-临界区" class="headerlink" title="1. 临界区"></a>1. 临界区</h3><p>对临界资源进行访问的那段代码称为临界区。<br>为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。</p>
<h3 id="2-信号量"><a href="#2-信号量" class="headerlink" title="2. 信号量"></a>2. 信号量</h3><h3 id="3-管程"><a href="#3-管程" class="headerlink" title="3. 管程"></a>3. 管程</h3>]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Computer Network</title>
    <url>/Computer-Network/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="https://s1.ax1x.com/2020/06/08/tRorRg.png" alt="tRorRg.png"></p>
<blockquote>
<p>第8点会考一些基本安全知识</p>
</blockquote>
<a id="more"></a>
<h2 id="计算机网络的概念"><a href="#计算机网络的概念" class="headerlink" title="计算机网络的概念"></a>计算机网络的概念</h2><h2 id="什么是协议？"><a href="#什么是协议？" class="headerlink" title="什么是协议？"></a>什么是协议？</h2><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><h3 id="和现实协议的对比"><a href="#和现实协议的对比" class="headerlink" title="和现实协议的对比"></a>和现实协议的对比</h3><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><h3 id="服务划分"><a href="#服务划分" class="headerlink" title="服务划分"></a>服务划分</h3><p>面向连接的不一定可靠，无连接的一定不可靠</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>频分<br>时分<br>码分</p>
<h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>特点：</p>
<h3 id="比较优缺点"><a href="#比较优缺点" class="headerlink" title="比较优缺点"></a>比较优缺点</h3><h2 id="分组交换网络中延迟、丢失和吞吐量"><a href="#分组交换网络中延迟、丢失和吞吐量" class="headerlink" title="分组交换网络中延迟、丢失和吞吐量"></a>分组交换网络中延迟、丢失和吞吐量</h2><h3 id="分组交换的4种时延"><a href="#分组交换的4种时延" class="headerlink" title="分组交换的4种时延"></a>分组交换的4种时延</h3><ol>
<li>节点处理时延</li>
<li>排队时延(变换剧烈)</li>
<li><strong>传输时延</strong></li>
<li><strong>传播时延</strong></li>
</ol>
<h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>瓶颈链路是制约吞吐量的链路</p>
<h2 id="协议层及服务模型"><a href="#协议层及服务模型" class="headerlink" title="协议层及服务模型"></a>协议层及服务模型</h2><h3 id="TCP-IP协议的五层模型"><a href="#TCP-IP协议的五层模型" class="headerlink" title="TCP/IP协议的五层模型"></a>TCP/IP协议的五层模型</h3><p><img src="https://s1.ax1x.com/2020/06/08/tRTNpF.png" alt="tRTNpF.png"></p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p><img src="https://s1.ax1x.com/2020/06/08/tRTdX9.png" alt="tRTdX9.png"></p>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号用16位(0-65535)<br>常用端口：<br>HTTP：80<br>邮件服务：25<br>TelNet：23<br>SSH：22</p>
<p>上层需要的服务，是本层无法确保的：<br>传输层不能向上一层提供时延保证</p>
<h2 id="Web应用和HTTP协议"><a href="#Web应用和HTTP协议" class="headerlink" title="Web应用和HTTP协议"></a>Web应用和HTTP协议</h2><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>持久和非持久连接的区别：</p>
<h3 id="RTT"><a href="#RTT" class="headerlink" title="RTT"></a>RTT</h3><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>作用、原理、流程<br>4个重要方面</p>
<h3 id="web缓存"><a href="#web缓存" class="headerlink" title="web缓存"></a>web缓存</h3><p>作用、流程<br>条件GET</p>
<h2 id="电子邮件SMTP、POP3、IMAP"><a href="#电子邮件SMTP、POP3、IMAP" class="headerlink" title="电子邮件SMTP、POP3、IMAP"></a>电子邮件SMTP、POP3、IMAP</h2><p>用户本地到服务器的连接方式</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS服务器提供的功能：</p>
<h3 id="DNS的查询方法"><a href="#DNS的查询方法" class="headerlink" title="DNS的查询方法"></a>DNS的查询方法</h3><p>递归：<br>迭代：</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>作用：<br>方案：</p>
<h1 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><h3 id="伪首部的作用"><a href="#伪首部的作用" class="headerlink" title="伪首部的作用"></a>伪首部的作用</h3><h2 id="可靠数据传输原理"><a href="#可靠数据传输原理" class="headerlink" title="可靠数据传输原理"></a>可靠数据传输原理</h2><p>Rdt1.0-3.0<br>流水线GBN<br>选择性重传SR</p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="报文段结构"><a href="#报文段结构" class="headerlink" title="报文段结构"></a>报文段结构</h3><p>20字节的固定首部</p>
<h3 id="TCP序号和确认"><a href="#TCP序号和确认" class="headerlink" title="TCP序号和确认"></a>TCP序号和确认</h3><p>填ACK，Seq<br>序号Seq：<br>数据段中第一个字节在数据流中的位置编号<br>ACK：</p>
<p>TCP估计RTT时：不计算重发的包的–忽略重传</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>3次握手、4次挥手 释放连接</p>
<h3 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h3><p>场景原因</p>
<p>简述TCP拥塞控制</p>
<p>经典图<br>窗口变化，阈值变化</p>
<h1 id="套接字编程"><a href="#套接字编程" class="headerlink" title="套接字编程"></a>套接字编程</h1><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>网络是大端字节序</p>
<h2 id="基本套接字函数的使用"><a href="#基本套接字函数的使用" class="headerlink" title="基本套接字函数的使用"></a>基本套接字函数的使用</h2><p>send和rec缺省是阻塞的</p>
<h2 id="5种I-O模式"><a href="#5种I-O模式" class="headerlink" title="5种I/O模式"></a>5种I/O模式</h2><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="虚电路和数据报网络"><a href="#虚电路和数据报网络" class="headerlink" title="虚电路和数据报网络"></a>虚电路和数据报网络</h2><p>区别</p>
<h2 id="路由器结构"><a href="#路由器结构" class="headerlink" title="路由器结构"></a>路由器结构</h2><p>3种交换结构</p>
<h2 id="网际协议"><a href="#网际协议" class="headerlink" title="网际协议"></a>网际协议</h2><h3 id="IP数据包分片和重组"><a href="#IP数据包分片和重组" class="headerlink" title="IP数据包分片和重组"></a>IP数据包分片和重组</h3><p>traceroute原理:TTL</p>
<h3 id="IP地址划分"><a href="#IP地址划分" class="headerlink" title="IP地址划分"></a>IP地址划分</h3><p>CIDR</p>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>链路状态<br>距离向量</p>
<h1 id="链路层"><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>进程<br>服务器<br>接口</p>
<h2 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h2><h2 id="CRC循环冗余码计算"><a href="#CRC循环冗余码计算" class="headerlink" title="CRC循环冗余码计算"></a>CRC循环冗余码计算</h2><h2 id="多路访问"><a href="#多路访问" class="headerlink" title="多路访问"></a>多路访问</h2><p>ALOHA(纯、时隙)<br>效率推导了解一下：求极限</p>
<p>CSMA/CD的运行机制<br>二进制指数回退算法</p>
<h2 id="MAC、ARP"><a href="#MAC、ARP" class="headerlink" title="MAC、ARP"></a>MAC、ARP</h2><p>IP地址不变，MAC不停变化</p>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>只学习<br>VLAN 作用</p>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Database Programming</title>
    <url>/Database-Programming/</url>
    <content><![CDATA[<h1 id="数据定义SQL语句"><a href="#数据定义SQL语句" class="headerlink" title="数据定义SQL语句"></a>数据定义SQL语句</h1><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><ol>
<li>字符串型varchar(n)、char(n)<blockquote>
<p>varchar长度可变、char固定长度</p>
</blockquote>
</li>
<li>整数型int、smallint</li>
<li>定点数型numerica(p,d)<blockquote>
<p>numeric(p,d)为定点数，p 为定点数的总位数，d 为定点数的小数位数。该数据类型可以表示带小数的数值。</p>
</blockquote>
</li>
<li>浮点数型real、double(n,d)</li>
<li>货币型money</li>
<li>逻辑性bit</li>
<li>日期型date</li>
</ol>
<h2 id="数据库定义"><a href="#数据库定义" class="headerlink" title="数据库定义"></a>数据库定义</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;;</span><br><span class="line">&gt; CERATE DATABASE HR;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="修改数据库"><a href="#修改数据库" class="headerlink" title="修改数据库"></a>修改数据库</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;[[<span class="keyword">WITH</span>] <span class="keyword">option</span>[...]];</span><br><span class="line">&gt; ALTER DATABASE demoDB RENAME TO &lt;MyDemoDB&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> &lt;<span class="keyword">NAME</span>&gt;;</span><br><span class="line">&gt; DROP DATABASE demoDB;</span><br></pre></td></tr></table></figure>
<h2 id="数据库表对象的定义"><a href="#数据库表对象的定义" class="headerlink" title="数据库表对象的定义"></a>数据库表对象的定义</h2><h3 id="数据库表创建"><a href="#数据库表创建" class="headerlink" title="数据库表创建"></a>数据库表创建</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Student（ </span><br><span class="line">StudentID　　　　<span class="built_in">char</span>(<span class="number">13</span>)　　PRIMARY　<span class="keyword">KEY</span>, </span><br><span class="line">StudentName　　　<span class="built_in">varchar</span>(<span class="number">10</span>)　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">StudentGender　　<span class="built_in">char</span>(<span class="number">2</span>)　　　<span class="literal">NULL</span>, </span><br><span class="line">BirthDay　　　　　<span class="built_in">date</span>　　　　 <span class="literal">NULL</span>, </span><br><span class="line">Major　　　　　　 <span class="built_in">varchar</span>(<span class="number">30</span>)　<span class="literal">NULL</span>, </span><br><span class="line">StudentPhone　　 <span class="built_in">char</span>(<span class="number">11</span>)　　<span class="literal">NULL</span> </span><br><span class="line">）;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>列约束关键词</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY、NOT NULL、NULL 、UNIQUE、<span class="keyword">CHECK</span>、<span class="keyword">DEFAULT</span> </span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Course( </span><br><span class="line">CourseID　　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　PRIMARY　<span class="keyword">Key</span>, </span><br><span class="line">CourseName　　 <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span>　<span class="literal">NULL</span>　<span class="keyword">UNIQUE</span>, </span><br><span class="line">CourseType　　 <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="literal">NULL</span>　<span class="keyword">CHECK</span>(CourseType <span class="keyword">IN</span>(’基础课’,’专业’,’选修’)), </span><br><span class="line">CourseCredit　<span class="built_in">smallint</span>　　<span class="literal">NULL</span>, </span><br><span class="line">CoursePeriod　<span class="built_in">smallint</span>　　<span class="literal">NULL</span>, </span><br><span class="line">TestMethod　　 <span class="built_in">char</span>(<span class="number">10</span>)　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>　<span class="keyword">DEFAULT</span>　’闭卷考试’ </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表约束关键词</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONSTRAINT 复合主键名_PK PRIMARY Key(列名)</span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Plan(</span><br><span class="line">CourseID　　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">TeacherID　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseRoom　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">CourseTime　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">Note　　　　　<span class="built_in">varchar</span>(<span class="number">50</span>), </span><br><span class="line"><span class="keyword">CONSTRAINT</span>　　CoursePlan_PK　　PRIMARY <span class="keyword">Key</span>(CourseID,TeacherID) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表约束定义代理键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">serial 代理键</span><br><span class="line">&gt; </span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　Plan(</span><br><span class="line">CoursePlanID　<span class="built_in">serial</span>　　　 <span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseID　　　<span class="built_in">char</span>(<span class="number">4</span>)　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">TeacherID　　 <span class="built_in">char</span>(<span class="number">4</span>)　　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">CourseRoom　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">CourseTime　　<span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">Note　　　　　<span class="built_in">varchar</span>(<span class="number">50</span>), </span><br><span class="line"><span class="keyword">CONSTRAINT</span>　　CoursePlan_PK　　PRIMARY <span class="keyword">Key</span>(CoursePlanID) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表约束定义外键</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CONSTRAINT 外键名_FK FOREIGN KEY(列名)</span><br><span class="line">REFERENCES 关联的表名(列名)</span><br><span class="line">    ON <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span></span><br><span class="line">    <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span>　<span class="keyword">TABLE</span>　<span class="keyword">Register</span>( </span><br><span class="line">    CourseRegID　　　<span class="built_in">serial</span>　　<span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">    CoursePlanID　　 <span class="built_in">int</span>　　　 <span class="keyword">NOT</span>　<span class="literal">NULL</span>, </span><br><span class="line">    StudentID　　　　<span class="built_in">char</span>(<span class="number">13</span>), </span><br><span class="line">    Note　　　　　　 <span class="built_in">varchar</span>(<span class="number">30</span>), </span><br><span class="line">    <span class="keyword">CONSTRAINT</span>　　　 CourseRegID_PK　　PRIMARY <span class="keyword">Key</span>(CourseRegID), <span class="keyword">CONSTRAINT</span>　　　 CoursePlanID_FK　 <span class="keyword">FOREIGN</span> <span class="keyword">Key</span>(CoursePlanID) <span class="keyword">REFERENCES</span>　Plan(CoursePlanID) </span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span>, </span><br><span class="line">    <span class="keyword">CONSTRAINT</span>　　　 StudentID_FK　<span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(StudentID) <span class="keyword">REFERENCES</span>　Student(StudentID) </span><br><span class="line">        <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">CASCADE</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="数据库表修改"><a href="#数据库表修改" class="headerlink" title="数据库表修改"></a>数据库表修改</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; &lt;修改方式&gt;;</span><br></pre></td></tr></table></figure>

<ol>
<li>ADD<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用于增加新列或列完整性约束</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ADD</span> &lt;新列名称&gt;&lt;数据类型&gt;[完整性约束];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">ADD</span> Email <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></li>
<li>DROP<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用于删除指定列或列的完整性约束条件</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> &lt;列名&gt;;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>&lt;表名&gt; <span class="keyword">DROP</span> <span class="keyword">CONSTRAINT</span>&lt;完整性约束名&gt;; </span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Student <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> StudentPhone;</span><br></pre></td></tr></table></figure></li>
<li>RENAME<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用于修改表名称、列名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新表名&gt;; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">RENAME</span> &lt;原列名&gt; <span class="keyword">TO</span> &lt;新列名&gt;;</span><br></pre></td></tr></table></figure></li>
<li>ALTER<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用于修改列的数据类型，</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;表名&gt; <span class="keyword">ALTER</span> <span class="keyword">COLUMN</span> &lt;列名&gt; <span class="keyword">TYPE</span>&lt;新的数据类型&gt;;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="数据库删除"><a href="#数据库删除" class="headerlink" title="数据库删除"></a>数据库删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> &lt;表名&gt;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需注意：DROP TABLE 不能直接删除由 FOREIGN KEY 约束引用的表。只有先删除FOREIGN KEY约束或引用的表后，才能删除本表。</p>
</blockquote>
<h2 id="数据表索引对象的定义"><a href="#数据表索引对象的定义" class="headerlink" title="数据表索引对象的定义"></a>数据表索引对象的定义</h2><p><strong>索引：</strong> 是一种针对表中指定列的值进行排序的数据结构，使用它可以加快表中数据的查询。</p>
<blockquote>
<p>补充知识:<br>给表加上了主键，就相当于是有了聚集索引<br>不管以任何方式查询表，最终都会利用主键通过聚集索引来定位到数据，聚集索引（主键）是通往真实数据所在的唯一路径。<br>非聚集索引和聚集索引的区别在于，通过聚集索引可以查到需要查找的数据，而通过非聚集索引可以查到记录对应的主键值，再使用主键的值通过聚集索引查找到需要的数据。<br>索引的数据结构有很多，包括平衡树，哈希桶等<br><a href="https://zhuanlan.zhihu.com/p/23624390" target="_blank" rel="noopener">参考资料</a></p>
</blockquote>
<h3 id="创建索引对象"><a href="#创建索引对象" class="headerlink" title="创建索引对象"></a>创建索引对象</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;&lt;(列名[,..,])&gt;;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">ON</span> &lt;表名&gt;&lt;（列名[,...]）&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> BirthDay_Idx <span class="keyword">ON</span> Student (BirthDay);</span><br></pre></td></tr></table></figure>

<h3 id="修改索引对象"><a href="#修改索引对象" class="headerlink" title="修改索引对象"></a>修改索引对象</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> &lt;索引名&gt; <span class="keyword">RENAME</span> <span class="keyword">TO</span> &lt;新索引名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">INDEX</span> BirthDay_Idx <span class="keyword">RENAME</span> <span class="keyword">TO</span> BDay_Idx</span><br></pre></td></tr></table></figure>

<h3 id="删除索引对象"><a href="#删除索引对象" class="headerlink" title="删除索引对象"></a>删除索引对象</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> &lt;索引名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> BirthDay_Idx;</span><br></pre></td></tr></table></figure>

<h2 id="数据操纵-插入、更新、删除"><a href="#数据操纵-插入、更新、删除" class="headerlink" title="数据操纵(插入、更新、删除)"></a>数据操纵(插入、更新、删除)</h2><h3 id="数据插入"><a href="#数据插入" class="headerlink" title="数据插入"></a>数据插入</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;基本表&gt;[&lt;列名表&gt;] <span class="keyword">VALUES</span>(列值表);</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Student <span class="keyword">VALUES</span>(<span class="string">'2017220101105'</span>,’柳因’,’女’,<span class="string">'1999-04-23'</span>,’软件工程’, <span class="string">'liuyin@163.com'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在INSERT INTO插入数据语句中，使用的interger和numeric等类型数值不使用引号标注，但char、varchar、date 和datetime等类型必须使用单引号。 </p>
</blockquote>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;基本表&gt; </span><br><span class="line"><span class="keyword">SET</span> &lt;列名<span class="number">1</span>&gt;=&lt;表达式<span class="number">1</span>&gt; [,&lt;列名<span class="number">2</span>&gt;=&lt;表达式<span class="number">2</span>&gt;...] </span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">UPDATE</span> Student </span><br><span class="line"><span class="keyword">SET</span> Email=<span class="string">'zhaodong@163.com'</span> </span><br><span class="line"><span class="keyword">WHERE</span> StudentName=’赵东’;</span><br></pre></td></tr></table></figure>

<h3 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; </span><br><span class="line">[<span class="keyword">WHERE</span> &lt;条件表达式&gt;];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Student </span><br><span class="line"><span class="keyword">WHERE</span> StudentName=’张亮’;</span><br></pre></td></tr></table></figure>

<h2 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>|<span class="keyword">DISTINCT</span>] &lt;目标列&gt;[,&lt;目标列&gt;…] </span><br><span class="line">[ <span class="keyword">INTO</span> &lt;新表&gt; ] </span><br><span class="line"><span class="keyword">FROM</span> &lt;表名&gt;[,&lt;表名&gt;…] </span><br><span class="line">[ <span class="keyword">WHERE</span> &lt;条件表达式&gt; ] </span><br><span class="line">[ <span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;列名&gt; [<span class="keyword">HAVING</span> &lt;条件表达式&gt; ] </span><br><span class="line">[ <span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;列名&gt; [ <span class="keyword">ASC</span> | <span class="keyword">DESC</span> ] ];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（1）SELECT子句：作为SELECT语句的必要子句，用来指明从数据库表中需要查询的目标列。ALL关键词是查询 默认操作，即从表中获取满足条件的所有数据行；DISTINCT关键词用来去掉结果集中的重复数据行；&lt;目标列&gt;为被 查询表的指定列名，可以有多个。若查询表中所有列，一般使用*号表示。<br>（2）INTO子句：用来将被查询的结果集数据插入新表。<br>（3）FROM子句：用来指定被查询的数据来自哪个表或哪些表。若有多表，使用逗号分隔。<br>（4）WHERE子句：用来给出查询的检索条件。只有满足条件的数据行才允许被检索出来。<br>（5）GROUP BY子句：用来对查询结果进行分组，并进行分组统计等处理。在分组中，还可以使用HAVING关键 词定义分组条件。<br>（6）ORDER BY子句：用来对查询结果集进行排序。ASC关键词约定按指定列的数值升序排列查询结果集。DESC 关键词约定按指定列的数值降序排列查询结果集。若子句中没有给出排序关键词，默认按升序排列查询结果集</p>
</blockquote>
<h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><ol>
<li>聚合函数<br><img src="https://s1.ax1x.com/2020/06/10/t71ljg.png" alt="t71ljg.png"><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> 学生人数 <span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(Major) <span class="keyword">AS</span> 学生专业数 <span class="keyword">FROM</span> Student;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> Major) <span class="keyword">AS</span> 学生专业数 <span class="keyword">FROM</span> Student;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(BirthDay) <span class="keyword">AS</span> 最大年龄出生日期， <span class="keyword">Max</span>(BirthDay) <span class="keyword">AS</span> 最小年龄出生日期 <span class="keyword">FROM</span> Student;</span><br></pre></td></tr></table></figure></li>
<li>算数函数<br><img src="https://s1.ax1x.com/2020/06/10/t78nl8.png" alt="t78nl8.png"></li>
<li>字符串函数</li>
<li>时间日期函数</li>
<li>数据类型转换函数</li>
</ol>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> TeacherID, TeacherName, TeacherTitle </span><br><span class="line"><span class="keyword">FROM</span> Teacher </span><br><span class="line"><span class="keyword">WHERE</span> CollegeID <span class="keyword">IN</span> </span><br><span class="line">(<span class="keyword">SELECT</span> CollegeID </span><br><span class="line"><span class="keyword">FROM</span> College <span class="keyword">WHERE</span> </span><br><span class="line">CollegeName=’计算机学院’) </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> TeacherID；</span><br></pre></td></tr></table></figure>

<h2 id="数据控制"><a href="#数据控制" class="headerlink" title="数据控制"></a>数据控制</h2><h3 id="GRANT赋予权限"><a href="#GRANT赋予权限" class="headerlink" title="GRANT赋予权限"></a>GRANT赋予权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> &lt;权限列表&gt; <span class="keyword">ON</span> &lt;数据库对象&gt; <span class="keyword">TO</span> &lt;用户或角色&gt; [ <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span> ];</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span>, <span class="keyword">UPDATE</span>, <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">Register</span> <span class="keyword">TO</span> <span class="keyword">RoleS</span>;</span><br></pre></td></tr></table></figure>

<h3 id="REVOKE收回权限"><a href="#REVOKE收回权限" class="headerlink" title="REVOKE收回权限"></a>REVOKE收回权限</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> &lt;权限列表&gt; <span class="keyword">ON</span> &lt;数据库对象&gt; <span class="keyword">FROM</span> &lt;用户或角色&gt; ;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> <span class="keyword">Register</span> <span class="keyword">FROM</span> <span class="keyword">RoleS</span>;</span><br></pre></td></tr></table></figure>

<h3 id="DENY拒绝授权"><a href="#DENY拒绝授权" class="headerlink" title="DENY拒绝授权"></a>DENY拒绝授权</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DENY &lt;权限列表&gt; ON &lt;数据库对象&gt; TO &lt;用户或角色&gt; ;</span><br><span class="line">&gt;</span><br><span class="line">DENY <span class="keyword">DELETE</span> <span class="keyword">ON</span> Teacher <span class="keyword">TO</span> RoleT;</span><br></pre></td></tr></table></figure>

<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图创建"><a href="#视图创建" class="headerlink" title="视图创建"></a>视图创建</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> &lt;视图名&gt;[(列名<span class="number">1</span>),(列名<span class="number">2</span>),…] <span class="keyword">AS</span> &lt;<span class="keyword">SELECT</span>查询&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> BasicCourseView <span class="keyword">AS</span> <span class="keyword">SELECT</span> CourseName, </span><br><span class="line">CourseCredit, CoursePeriod, TestMethod </span><br><span class="line"><span class="keyword">FROM</span> Course </span><br><span class="line"><span class="keyword">WHERE</span> CourseType=’基础课’;</span><br></pre></td></tr></table></figure>
<h3 id="视图删除"><a href="#视图删除" class="headerlink" title="视图删除"></a>视图删除</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> &lt;视图名&gt;;</span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> BasicCourseView;</span><br></pre></td></tr></table></figure>
<h3 id="视图使用"><a href="#视图使用" class="headerlink" title="视图使用"></a>视图使用</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> DataBaseCourseView <span class="keyword">AS</span> <span class="keyword">SELECT</span> C.CourseName <span class="keyword">AS</span> 课程名称， S.StudentID <span class="keyword">AS</span> 学号， S.StudentName <span class="keyword">AS</span> 姓名 </span><br><span class="line"><span class="keyword">FROM</span> Course <span class="keyword">AS</span> C, Plan <span class="keyword">AS</span> P, <span class="keyword">Register</span> <span class="keyword">AS</span> R, Student <span class="keyword">AS</span> S </span><br><span class="line"><span class="keyword">WHERE</span> C.CourseID=P.CourseID <span class="keyword">AND</span> C. CourseName=’数据库原理及应用’ <span class="keyword">AND</span> P.CoursePlanID=R.CoursePlanID <span class="keyword">AND</span> R.StudentID=S.StudentID; </span><br><span class="line">&gt;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> DataBaseCourseView;</span><br></pre></td></tr></table></figure>

<h1 id="数据库应用编程"><a href="#数据库应用编程" class="headerlink" title="数据库应用编程"></a>数据库应用编程</h1><h2 id="存储过程编程"><a href="#存储过程编程" class="headerlink" title="存储过程编程"></a>存储过程编程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [ <span class="keyword">OR</span> <span class="keyword">REPLACE</span> ] <span class="keyword">FUNCTION</span> </span><br><span class="line">    <span class="keyword">name</span> ( [ [ argmode ] [ argname ] argtype [ &#123; <span class="keyword">DEFAULT</span> | = &#125; default_expr ] [, ...] ] ) </span><br><span class="line">    [ <span class="keyword">RETURNS</span> retype | <span class="keyword">RETURNS</span> <span class="keyword">TABLE</span> ( column_name column_type [, ...] ) ] </span><br><span class="line"><span class="keyword">AS</span> $$ <span class="keyword">DECLARE</span> </span><br><span class="line">    <span class="comment">-- 声明段 </span></span><br><span class="line"><span class="keyword">BEGIN</span> <span class="comment">--函数体语句 </span></span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">$$ LANGUAGE lang_name;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>（1）OR REPLACE：如果没有该名称，则创建存储过程。当数据库中存在该存储过程时，如果创建存储过程的语 句没有关键字OR REPLACE，数据库将给出类似“该存储过程已经存在，不能创建该存储过程”的警示信息；如果创 建存储过程的语句有关键字OR REPLACE，则将旧的存储过程替换为新创建的存储过程。<br>（2）name：要创建的存储过程名。<br>（3）argmode：存储过程参数的模式可以为IN、OUT或INOUT，默认值是IN。IN声明参数为输入参数，向存储过 程内部传值；OUT声明参数为输出参数，存储过程对参数值的修改在存储过程之外是可见的，类似其他语言将函数的 形式参数声明为引用；INOUT声明该参数既是输入参数，同时又是输出参数。<br>（4）argname：形式参数的名称。<br>（5）argtype：该函数返回值的数据类型。可以是基本类型，也可以是复合类型、域类型或者与数据库字段相同的 类型。字段类型用 table_name.column_name%TYPE 表示，使用字段类型声明变量的数据类型，数据库表的类型变化不 会影响存储过程的执行。<br>（6）default_expr：指定参数默认值的表达式，该表达式的类型必须是可转化为参数的类型。只有IN和INOUT模式 的参数才能有默认值，具有默认值的输入参数必须出现在参数列表的最后。<br>（7）retype：指示 RETURNS 返回值的数据类型。可以声明为基本类型、复合类型、域类型或者表的字段类型。 如果存储没有返回值，可以指定void作为返回类型。如果存在OUT或INOUT参数，那么可以省略RETURNS子句。<br>（8）RETURNS TABLE：指示存储过程返回值的类型是由多列构成的二维表，表的列名由 column_name 指定，每 个列的数据类型由 column_type 指明；如果存储过程返回值由RETURNS TABLE指定，存储过程就不能有OUT和 INOUT模式的参数。 （9）AS $$：用于声明存储过程的实际代码的开始，当编译器扫描遇到下一个 的时候，则表明代码的结束。<br>（10）DECLARE:PL/pgSQL 指示声明存储过程的局部变量，后续内容将介绍如何定义存储过程的局部变量。<br>（11）BEGIN…END：用来定义存储过程的执行体语句。<br>（12）LANGUAGE：在关键字后面由lang_name指明存储过程所使用的编程语言，同时标志存储过程的结束。例 如：LANGUAGE plpgsql 告诉编译器该存储过程是使用PL/pgSQL实现的。</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> countRecords () </span><br><span class="line"><span class="keyword">RETURNS</span> <span class="built_in">integer</span> <span class="keyword">AS</span> $<span class="keyword">count</span>$ </span><br><span class="line"><span class="keyword">DECLARE</span> </span><br><span class="line">    <span class="keyword">count</span> <span class="built_in">integer</span>; </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">INTO</span> <span class="keyword">count</span> <span class="keyword">FROM</span> Student; </span><br><span class="line">    RETURN count; </span><br><span class="line"><span class="keyword">END</span>; </span><br><span class="line">$ count $ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<h2 id="触发器编程"><a href="#触发器编程" class="headerlink" title="触发器编程"></a>触发器编程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">CONSTRAINT</span>] <span class="keyword">TRIGGER</span> <span class="keyword">name</span> </span><br><span class="line">&#123; <span class="keyword">BEFORE</span> | <span class="keyword">AFTER</span> | INSTEAD <span class="keyword">OF</span> &#125; &#123; <span class="keyword">event</span> [ <span class="keyword">OR</span> ...] &#125; </span><br><span class="line"><span class="keyword">ON</span> table_name </span><br><span class="line">[ <span class="keyword">FROM</span> referenced_table_name ] </span><br><span class="line">[ <span class="keyword">FOR</span> [ <span class="keyword">EACH</span> ] &#123; <span class="keyword">ROW</span> | <span class="keyword">STATEMENT</span> &#125; ] </span><br><span class="line">[ <span class="keyword">WHEN</span> (condition) ]</span><br><span class="line"><span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> function_name ( arguments )</span><br></pre></td></tr></table></figure>
<h3 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h3><ol>
<li>存在所依赖的表或视图</li>
<li>编写触发器函数<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> score_audit() </span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="keyword">TRIGGER</span> <span class="keyword">AS</span> $score_audit$ </span><br><span class="line">    <span class="keyword">BEGIN</span> </span><br><span class="line">        <span class="keyword">IF</span> (TG_OP = <span class="string">'DELETE'</span>) <span class="keyword">THEN</span> </span><br><span class="line">            <span class="keyword">INSERT</span> <span class="keyword">INTO</span> Audit_score </span><br><span class="line">            <span class="keyword">SELECT</span> <span class="keyword">user</span>, old.sid, old.cid, <span class="keyword">now</span>(), OLD.score ; </span><br><span class="line">            RETURN OLD; </span><br><span class="line">        ELSIF (TG_OP = '<span class="keyword">UPDATE</span><span class="string">') THEN </span></span><br><span class="line"><span class="string">            INSERT INTO Audit_score </span></span><br><span class="line"><span class="string">            SELECT user, old.sid, old.cid, now(), OLD.score , new.score</span></span><br><span class="line"><span class="string">            where old.sid=new.sid and old.cid=new.cid; </span></span><br><span class="line"><span class="string">            RETURN NEW; </span></span><br><span class="line"><span class="string">        ELSIF (TG_OP = '</span><span class="keyword">INSERT</span><span class="string">') THEN </span></span><br><span class="line"><span class="string">            INSERT INTO Audit_score </span></span><br><span class="line"><span class="string">            SELECT user, new.sid, new.cid, now(),null, new.score; RETURN NEW; </span></span><br><span class="line"><span class="string">        END IF; </span></span><br><span class="line"><span class="string">        RETURN NULL; </span></span><br><span class="line"><span class="string">    END; </span></span><br><span class="line"><span class="string">$score_audit$ LANGUAGE plpgsql;</span></span><br></pre></td></tr></table></figure></li>
<li>指明触发的条件信息<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> score_audit_trigger </span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">OR</span> <span class="keyword">UPDATE</span> <span class="keyword">OR</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> Stu_score </span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span> <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> score_audit();</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Operating System(1)</title>
    <url>/Operating-System-1/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="操作系统的目标和作用"><a href="#操作系统的目标和作用" class="headerlink" title="操作系统的目标和作用"></a>操作系统的目标和作用</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>方便性、有效性、可扩充性、开放性。</p>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol>
<li>作为用户与计算机硬件之间的接口</li>
<li>作为计算机系统资源的管理者</li>
<li>实现了对计算机资源的抽象<a id="more"></a>

</li>
</ol>
<h2 id="操作系统的发展过程"><a href="#操作系统的发展过程" class="headerlink" title="操作系统的发展过程"></a>操作系统的发展过程</h2><h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>主要动力是提高资源利用率和系统吞吐量。<br>批处理是指用户将一批作业提交给操作系统后就不再干预，由操作系统控制它们自动运行。<br>批处理系统分为单道批处理系统和多道批处理系统。</p>
<ol>
<li>单道批处理系统<br><img src="https://s1.ax1x.com/2020/06/11/tqmjI0.png" alt="tqmjI0.png"><br>在内存中始终仅存一道作业运行。</li>
<li>多道批处理系统<br><img src="https://s1.ax1x.com/2020/06/11/tqnwLj.png" alt="tqnwLj.png"></li>
</ol>
<h3 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h3><p>主要动力是满足用户对人机交互的需求。<br>系统允许多个用户同时通过自己的终端，以交互的方式使用计算机，共享主机的资源。<br>主要特征：多路性(多个用户)、独立性、及时性、交互性。</p>
<h3 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h3><p>系统能及时相应外部的请求，在规定时间内完成对该事件的处理。<br>分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。</p>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><h3 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h3><p>并发性是指两个或多个事件在同一时间间隔内发生，并行性是指两个或多个事件在同一时刻发生。<br>并行是真正的同时，需要硬件支持；<br>并发是看起来的同时，可以通过时间片轮转调度进程来实现。</p>
<h3 id="2-共享"><a href="#2-共享" class="headerlink" title="2.共享"></a>2.共享</h3><p>共享是指系统中的资源可供内存中多个并发执行的进程共同使用。<br>有两种共享方式：互斥共享和实时共享。<br>互斥共享的资源称为临界资源，在一段时间内只允许一个进程访问的资源，如打印机等。</p>
<h3 id="3-虚拟"><a href="#3-虚拟" class="headerlink" title="3.虚拟"></a>3.虚拟</h3><p>虚拟是把一个物理实体变为若干个逻辑实体。<br>有两种虚拟技术：时分复用和空分复用。<br>多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占用处理器，每次只执行一小个时间片并快速切换。<br>虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间的页被映射到物理内存，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。</p>
<h3 id="4-异步"><a href="#4-异步" class="headerlink" title="4.异步"></a>4.异步</h3><p>异步是指进程不是一次性执行完毕，而是停停走走。</p>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><h3 id="1-进程管理"><a href="#1-进程管理" class="headerlink" title="1.进程管理"></a>1.进程管理</h3><p>进程控制、进程同步、进程通信、进程调度等。</p>
<h3 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2.内存管理"></a>2.内存管理</h3><p>内存分配、内存保护、地址映射、内存扩充等。</p>
<h3 id="3-设备管理"><a href="#3-设备管理" class="headerlink" title="3.设备管理"></a>3.设备管理</h3><p>缓冲管理、设备分配、设备处理等。</p>
<h3 id="4-文件管理"><a href="#4-文件管理" class="headerlink" title="4.文件管理"></a>4.文件管理</h3><p>文件存储空间的管理、目录管理、文件读/写管理和保护等。</p>
<p><strong>参考资料：</strong></p>
<ol>
<li>汤小丹、梁红兵、哲风屏、汤子瀛 计算机操作系统(第四版)：西安电子科技大学出版社</li>
<li><a href="https://cyc2018.github.io/CS-Notes/#/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E7%9B%AE%E5%BD%951" target="_blank" rel="noopener">CS-Notes</a></li>
</ol>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>How to write a summary</title>
    <url>/How-to-write-a-summary/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>撰写读后摘要是2018级专用英语期末笔试写作部分的第一题，满分10分，占总分10%。 题目要求考生先阅读一篇长度为 300-350 词的短文，然后概括、浓缩其主旨大意及主要内容， 并撰写一篇长度 100-120 词的摘要。阅读短文主要涉及议论性、说明性和学术性内容</p>
<h1 id="Find-out-theme-of-article"><a href="#Find-out-theme-of-article" class="headerlink" title="Find out theme of article"></a>Find out theme of article</h1><p>用一段话来高度概括文章的主要内容(两分)<br>This article addresses the issue of …</p>
<a id="more"></a>
<h1 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h1><p>分析文章的结构，按逻辑顺序概括出每部分的大意和关键信息。<br>提取主要信息，删减次要信息，注意不要遗漏原文的主要观点和关键信息。</p>
<h1 id="Not-Copy"><a href="#Not-Copy" class="headerlink" title="Not Copy"></a>Not Copy</h1><p>千万不要照抄原文。<br>重述原文的重要信息，用自己的话替换原文的语言结构和表达方式，不允许照抄、摘录或者引用连续5个词以上的原文。</p>
<h1 id="Neutral-Opinion"><a href="#Neutral-Opinion" class="headerlink" title="Neutral Opinion"></a>Neutral Opinion</h1><p>必须要客观，不要出现 I think之类的。<br>准确理解原文的意思和观点，写作时不要添加新的信息和与原文无关的信息，不要偷换概念， 也不要评论原文的观点。 </p>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>商务英语</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络系列(1)--计算机网络和因特网</title>
    <url>/Computer-Network-and-Internet/</url>
    <content><![CDATA[<h1 id="计算机网络和Internet发展史"><a href="#计算机网络和Internet发展史" class="headerlink" title="计算机网络和Internet发展史"></a>计算机网络和Internet发展史</h1><blockquote>
<ol>
<li>分组交换原理的早期发展与演化：1961-1972</li>
<li>网际互连与新兴的专属网络：1972-1980</li>
<li>TCP/IP新协议与网络数量激增：1980-1990</li>
<li>商业化, Web, 新的网络应用：1990-2000</li>
<li>移动互联网：21世纪10年代中期——至今</li>
</ol>
</blockquote>
<h1 id="什么是Internet？"><a href="#什么是Internet？" class="headerlink" title="什么是Internet？"></a>什么是Internet？</h1><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><strong>计算机网络：</strong> 两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。<br><strong>两大功能：</strong> 连通性和共享</p>
<a id="more"></a>
<h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p><strong>由网络构成的网络</strong></p>
<p><strong>具体构成描述：</strong></p>
<ol>
<li>数以亿计的计算互联设备：主机、应用程序</li>
<li>通信链路：双绞线、光纤、卫星</li>
<li>分组交换：路由器和交换机</li>
</ol>
<p><strong>服务上描述：</strong></p>
<ol>
<li>提供网络应用基础架构</li>
<li>为分布式应用程序提供的通信服务接口<ul>
<li>无连接服务connectionless</li>
<li>面向连接服务connection-oriented</li>
<li>不提供数据传递时间保证（发送端到接收端）的服务</li>
</ul>
</li>
</ol>
<h2 id="协议–划重点"><a href="#协议–划重点" class="headerlink" title="协议–划重点"></a>协议–划重点</h2><p><strong>协议：</strong>定义了两个或多个通信实体间所交换报文的<strong>格式和次序</strong>，以及在报文发送/或接收或者其他事件方面所采取的<strong>行动（响应）</strong>。</p>
<h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><ul>
<li>所有的因特网标准都以RFC（<strong>Request For Comments</strong>,请求评论）的形式在因特网上发表。</li>
<li>正式标准要经历四个阶段：<ol>
<li>因特网草案（Internet Draft）－不是RFC文档</li>
<li>建议标准（Proposed Standard） －开始成为RFC文档</li>
<li>草案标准（Draft Standard）</li>
<li>因特网标准（Internet Standard）<br><img src="https://s1.ax1x.com/2020/05/31/t3CKat.png" alt="t3CKat.png"><br><a href="http://www.rfceditor.org/RFCoverview.html" target="_blank" rel="noopener">详细介绍</a></li>
</ol>
</li>
</ul>
<p><strong>协议的基本要素：语法、语义和同步</strong></p>
<h1 id="网络边缘部分"><a href="#网络边缘部分" class="headerlink" title="网络边缘部分"></a>网络边缘部分</h1><h1 id="网络核心部分"><a href="#网络核心部分" class="headerlink" title="网络核心部分"></a>网络核心部分</h1><h1 id="Internet主干-ISPs的结构组成"><a href="#Internet主干-ISPs的结构组成" class="headerlink" title="Internet主干/ISPs的结构组成"></a>Internet主干/ISPs的结构组成</h1><h1 id="分组交换网络中延迟和丢失"><a href="#分组交换网络中延迟和丢失" class="headerlink" title="分组交换网络中延迟和丢失"></a>分组交换网络中延迟和丢失</h1><h1 id="协议层及其服务模型"><a href="#协议层及其服务模型" class="headerlink" title="协议层及其服务模型"></a>协议层及其服务模型</h1><h1 id="攻击威胁下的网络"><a href="#攻击威胁下的网络" class="headerlink" title="攻击威胁下的网络"></a>攻击威胁下的网络</h1>]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（三）-- 垃圾收集基础(GC)</title>
    <url>/Garbage-Collection/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p><strong>误解:</strong> 垃圾收集(Garbage Collection,简称GC)是Java语言的伴生产物。<br>事实上，垃圾收集的历史远远比Java久远，在1960年诞生于麻省理工学院的Lisp是第一门开始使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，其作者John McCarthy就思考过垃圾收集需要完成的三件事情：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？<a id="more"></a>

</li>
</ul>
<h2 id="Why-need-it？"><a href="#Why-need-it？" class="headerlink" title="Why need it？"></a>Why need it？</h2><p>经过半个世纪的发展，今天的内存动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解垃圾收集和内存分配？</p>
<p><strong>答案很简单：</strong>当需要排查<strong>各种内存溢出、内存泄漏问题</strong>时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术实施必要的监控和调节。</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>我们在系列2中学习了Java内存运行各个区域，分别为<strong>程序计数器、虚拟机栈、本地方法栈、Java堆、方法区</strong>。(<em>如果忘记了，快回头复习</em>)</p>
<p>其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</p>
<p>而<strong>Java堆和方法区</strong>有很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这个不分内存的分配和回收是动态的。<strong>这也就是GC所关注的对象！</strong><br>这里我们就回答了之前提出的第一个问题 – 哪些内存需要回收。</p>
<h1 id="判断对象生死"><a href="#判断对象生死" class="headerlink" title="判断对象生死"></a>判断对象生死</h1><p>在垃圾收集器对内存进行回收时，第一步就是要判断对象的状态。</p>
<h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p><strong>引用计数算法：</strong><br>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；<br>当引用失效时，计数器值就减一；<br>任何时刻计算器为零的对象就是不可能再被使用的。</p>
<p><em>这种方法是我编程中最常用的了，这里被狠狠地打脸了。</em><br>这个算法面临的问题：<strong>无法解决对象之间相互循环引用的问题。</strong></p>
<blockquote>
<p>即 <code>objA.instance = objB; objB.instance = objA;</code>objA 和 objB 都不会再被访问后，它们仍然相互引用着对方，所以它们的引用计数器不为 0，将永远不能被判为不可用。<br>(可以好好思考一下)</p>
</blockquote>
<h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p><strong>基本思路：</strong> 当前对象到根对象(GC Roots)是否是可达的 <em>(图论知识)</em></p>
<ul>
<li>从 “GC Roots” 对象作为起点开始向下搜索，走过的路径称为引用链（Reference Chain）；</li>
<li>从 “GC Roots” 开始，不可达的对象被判为不可用。</li>
</ul>
<blockquote>
<p>如下图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，因此它们将会被判定为可回收的对象。</p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/31/tl4Qv4.png" alt="tl4Qv4.png"></p>
<h3 id="Java中可作为GC-Roots的对象"><a href="#Java中可作为GC-Roots的对象" class="headerlink" title="Java中可作为GC Roots的对象"></a>Java中可作为GC Roots的对象</h3><ol>
<li>栈中(本地变量表中的Reference)<ul>
<li>虚拟机栈中，栈帧中的本地变量表所引用的对象；</li>
<li>本地方法栈中，JNI引用的对象(native方法)</li>
</ul>
</li>
<li>方法区中<ul>
<li>类的静态属性引用的对象；</li>
<li>常量引用的对象；<blockquote>
<p>这上面的对象没搞懂</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p>即便如此，一个对象也不是一旦被判为不可达，就立即死去的，宣告一个的死亡需要经过两次标记过程。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用”离不开关系。</p>
<p>在JDK 1.2版以前，Java里面的引用是很传统的<strong>定义：</strong>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该reference数据是代表某块内存、某个对象的引用。–<em>我自己的以往理解也是这样的</em></p>
<p>在JDK 1.2版之后，Java对引用的概念进行了扩充，将引用分为<strong>强引用（Strongly Re-ference）、软引用（SoftReference）、弱引用（Weak Reference）和虚引用（Phantom Reference）</strong>4种，这4种引用强度依次逐渐减弱。</p>
<h3 id="4种引用"><a href="#4种引用" class="headerlink" title="4种引用"></a>4种引用</h3><ol>
<li><strong>强引用：</strong> 像<code>Object obj = new Object()</code>这种，只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用：</strong> 用来描述还有用但非必须的对象。对于软引用对象，在OOM（OutOfMemory)前，虚拟机会把这些对象列入回收范围中进行第二次回收，如果这次回收后，内存还是不够用，就OOM。实现类：<code>SoftReference</code>。</li>
<li><strong>弱引用：</strong> 跟软引用类似，比它更弱一点。被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。实现类：<code>WeakReference</code>。</li>
<li><strong>虚引用：</strong> 也称为“幽灵引用”或者“幻影引用”，它是最弱的一种引用关系。唯一作用就是为了能在这个对象被收集器回收时收到一个系统通知。实现类：<code>PhantomReference</code>。</li>
</ol>
<h2 id="To-be-or-not-to-be"><a href="#To-be-or-not-to-be" class="headerlink" title="To be or not to be?"></a>To be or not to be?</h2><p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li><strong>第一次标记：</strong> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；</li>
<li><strong>第二次标记：</strong> 筛选此对象是否有必要执行<code>finalize()</code>方法。假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li>
</ol>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。</p>
<blockquote>
<p>这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。<br>这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。</p>
</blockquote>
<p><strong>存活方式：</strong><br>如果对象要在finalize()中成功拯救自己–只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；</p>
<blockquote>
<p>finalize()能做的所有工作，使用try-finally或者其他方式都可以做得更好、更及时，所以笔者建议大家完全可以忘掉Java语言里面的这个方法。</p>
</blockquote>
<h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><blockquote>
<p>方法区垃圾收集的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
</blockquote>
<p>回收的内容：<strong>废弃的常量和不再使用的类型</strong></p>
<ul>
<li><strong>废弃常量：</strong> 例如一个字符串”abc”，当没有任何引用指向”abc”时，它就是废弃常量了。</li>
<li><strong>无用的类：</strong> 同时满足一下3个条件的类。<ol>
<li>该类的所有实例已被回收，Java堆中不存在该类的任何实例；</li>
<li>加载该类的Classloader已被回收；</li>
<li>该类的Class对象没有被任何地方引用，即无法在任何地方通过反射访问该类的方法。</li>
</ol>
</li>
</ul>
<h1 id="Free-Talk"><a href="#Free-Talk" class="headerlink" title="Free Talk"></a>Free Talk</h1><p>今天的垃圾收集基础部分算是写完，本来打算把算法部分也讲了，但是发现算法部分另起一篇的效果更好一点，同时打算补一篇Java基础，发现自己上学期学的Java遗忘的比较厉害了，而且上学期学的时候也没有学全，再拿来复习学习一下比较好。然后我发现自己对内存管理里面的数据区域了解的太少了，遇到了总是弄不清楚。  </p>
<p><strong>热爱未知，比如宇宙和清晨</strong><br><img src="https://s1.ax1x.com/2020/05/31/t1Spex.png" alt="image"></p>
<p>参考资料：<br><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/02-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86(GC).md" target="_blank" rel="noopener">Github</a><br>《深入理解java虚拟机》</p>
]]></content>
      <categories>
        <category>java后端开发</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法篇(一) -- 红黑树</title>
    <url>/Data-Structure-and-Algorithms-1/</url>
    <content><![CDATA[<h1 id="红黑树原理"><a href="#红黑树原理" class="headerlink" title="红黑树原理"></a>红黑树原理</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树具有以下的特性：</p>
<ol>
<li>某节点的左子树节点值仅包含小于该节点值</li>
<li>某节点的右子树节点值仅包含大于该节点值</li>
<li>左右子树每个也必须是二叉查找树</li>
</ol>
<p>简单的讲：<em>越小的放在越左边</em>。</p>
<a id="more"></a>
<p><strong>你以为的二叉查找树</strong><br><img src="https://s1.ax1x.com/2020/05/30/tQrsc6.png" alt="image"><br><strong>变态的二叉查找树</strong><br><img src="https://s1.ax1x.com/2020/05/30/tQrfNd.png" alt="image"><br>这种畸形的二叉查找树就会退化成<strong>链表</strong>，查找节点的时间复杂度就会从<strong>O($ log_2^n $)退化成O(n)</strong>。而根据我们在小学二年级就学过的[去除顶端优势]，我们引入了红黑树，达到树的平衡。</p>
<h2 id="红黑树简介"><a href="#红黑树简介" class="headerlink" title="红黑树简介"></a>红黑树简介</h2><p><strong>R-B Tree</strong>，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的<strong>二叉查找树</strong>。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。</p>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol>
<li>每个节点或者是黑色，或者是红色。(<em>没啥用</em>)</li>
<li>根节点是<strong>黑色</strong>。</li>
<li><em>每个叶子节点是黑色的</em>。</li>
<li><strong>如果一个节点是红色的，则它的子节点必须是黑色的。</strong></li>
<li><strong>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</strong><blockquote>
<p>第5点确保没有一条路径会比其他路径长出两倍。</p>
</blockquote>
</li>
</ol>
<p>示意图如下：<br><img src="https://s1.ax1x.com/2020/05/30/tQs3UH.png" alt="image"></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>主要是用来储存有序的数据，时间复杂度为O($log_2^n$)，效率非常高。<br>例如：Java集合中的<strong>TreeSet、TreeMap</strong>，C++ STL中的<strong>set、map</strong>，以及Linux中<strong>虚拟内存</strong>的管理等。</p>
<h1 id="Recolor-and-Rotation"><a href="#Recolor-and-Rotation" class="headerlink" title="Recolor and Rotation"></a>Recolor and Rotation</h1><p><strong>Recolor:</strong> 重新标记节点为黑色或红色<br><strong>Rotation:</strong> 旋转，达到树的平衡</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>当我们插入一个新的节点X时，要遵循如下公式：</p>
<ol>
<li>将新插入的节点标记为红色</li>
<li>如果X是根节点，则标记为黑色</li>
<li>如果X的parent不是黑色，同时X也不是root:<ul>
<li>如果X的uncle是红色<ol>
<li>将parent和uncle标记为黑色</li>
<li>将grand parent 标记为红色</li>
<li>让X的颜色和grand parent的颜色相同，重复2.3步骤</li>
</ol>
</li>
<li>如果X的uncle是黑色<ol>
<li>左左</li>
<li>左右</li>
<li>右右</li>
<li>右左</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>第一个左指的是parent节点是在grand parent的左边还是右边<br>第二个左指的是此节点X是在parent的左边还是右边        </p>
</blockquote>
<p><img src="https://s1.ax1x.com/2020/05/30/tQsY8I.png" alt="image"></p>
<p>跟着上面的公式走:</p>
<ol>
<li>将新插入的 X 节点标记为红色</li>
<li>发现 X 的 parent (P) 同样为红色，这违反了红黑树的第三条规则「不能有两个连续相邻的红色节点」</li>
<li>发现 X 的 uncle (U) 同样为红色</li>
<li>将 P 和 U 标记为黑色</li>
<li>将 X 和 X 的 grand parent (G) 标记为相同的颜色，即红色，继续重复公式 2、3</li>
<li>发现 G 是根结点，标记为黑色</li>
<li>结束</li>
</ol>
<h3 id="左左"><a href="#左左" class="headerlink" title="左左"></a>左左</h3><p><strong>p在g的左边，x在p的左边</strong></p>
<ol>
<li>右旋g</li>
<li>交换g和p的颜色<br><img src="https://s1.ax1x.com/2020/05/30/tQsdr8.png" alt="image"></li>
</ol>
<h3 id="左右"><a href="#左右" class="headerlink" title="左右"></a>左右</h3><ol>
<li>左旋p</li>
<li>变成左左了<br><img src="https://s1.ax1x.com/2020/05/30/tQsDaQ.png" alt="image"></li>
</ol>
<h3 id="右右"><a href="#右右" class="headerlink" title="右右"></a>右右</h3><ol>
<li>左旋g</li>
<li>交换g和p的颜色<br><img src="https://s1.ax1x.com/2020/05/30/tQsc2q.png" alt="image"></li>
</ol>
<h3 id="右左"><a href="#右左" class="headerlink" title="右左"></a>右左</h3><ol>
<li>右旋p</li>
<li>变成右右了<br><img src="https://s1.ax1x.com/2020/05/30/tQsWrT.png" alt="image"></li>
</ol>
<h2 id="案例演示"><a href="#案例演示" class="headerlink" title="案例演示"></a>案例演示</h2><p>插入 10，20，30，15 到一个空树中</p>
<ol>
<li>向空树中第一次插入数字 10，肯定是 root 节点</li>
<li>root 节点标记成黑色<br><img src="https://image-static.segmentfault.com/313/178/313178228-5d37b7346452f_articlex" alt="image"></li>
<li>向树中插入新节点 20，标记为红色</li>
<li>20 &gt; 10，并发现 10 没有叶子节点，将新节点 20 作为 10 的右孩子<br><img src="https://image-static.segmentfault.com/310/491/310491414-5d37b7319f447_articlex" alt="image"></li>
<li>向树中插入新节点 30，标记为红色</li>
<li>30 &gt; 10，查找 10 的右子树，找到 20</li>
<li>30 &gt; 20，继续查找 20 的右子树，发现 20 没有叶子节点，将值插在此处</li>
<li>30 和 20 节点都为红色，30 为右孩子，20 也为右孩子，触发了<strong>右右情况</strong></li>
<li>通过一次旋转，提起 20 节点</li>
<li>20 节点是根结点，标记为黑色<br><img src="https://image-static.segmentfault.com/386/112/3861123538-5d37b733ce90e_articlex" alt="image"></li>
<li>向树中插入新节点 15，标记为红色</li>
<li>通过比对大小和判断是否有叶子节点，最终插值为 10 节点的右孩子</li>
<li>15 和 10 节点都为红色，15 的 uncle 节点 30 也为红色</li>
<li>按照公式，将 15 的 parent 10 和 uncle 30 更改为黑色</li>
<li>让 15 节点 grand parent 20 的颜色与 15 节点的颜色一样，变为红色</li>
<li>20 为根结点，将其改为黑色<br><img src="https://image-static.segmentfault.com/842/419/842419664-5d37b734b8439_articlex" alt="image"></li>
</ol>
<h1 id="C语言实现"><a href="#C语言实现" class="headerlink" title="C语言实现"></a>C语言实现</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED        0    <span class="comment">// 红色节点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK    1    <span class="comment">// 黑色节点</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> color;        <span class="comment">// 颜色(RED 或 BLACK)</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父结点</span></span><br><span class="line">&#125;Node, *RBTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>&#123;</span></span><br><span class="line">    Node *node;</span><br><span class="line">&#125;RBRoot;</span><br></pre></td></tr></table></figure>
<h2 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h2><p><img src="https://s1.ax1x.com/2020/05/30/tQWj1J.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RED        0    <span class="comment">// 红色节点</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLACK    1    <span class="comment">// 黑色节点</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> color;        <span class="comment">// 颜色(RED 或 BLACK)</span></span><br><span class="line">    Type   key;                    <span class="comment">// 关键字(键值)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">left</span>;</span>    <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">right</span>;</span>    <span class="comment">// 右孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">RBTreeNode</span> *<span class="title">parent</span>;</span>    <span class="comment">// 父结点</span></span><br><span class="line">&#125;Node, *RBTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树的根</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span>&#123;</span></span><br><span class="line">    Node *node;</span><br><span class="line">&#125;RBRoot;</span><br></pre></td></tr></table></figure>

<h2 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h2><p><img src="https://s1.ax1x.com/2020/05/30/tQWvc9.png" alt="image"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 对红黑树的节点(y)进行右旋转</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 右旋示意图(对节点y进行左旋)：</span></span><br><span class="line"><span class="comment"> *            py                               py</span></span><br><span class="line"><span class="comment"> *           /                                /</span></span><br><span class="line"><span class="comment"> *          y                                x                  </span></span><br><span class="line"><span class="comment"> *         /  \      --(右旋)--&gt;            /  \                     #</span></span><br><span class="line"><span class="comment"> *        x   ry                           lx   y  </span></span><br><span class="line"><span class="comment"> *       / \                                   / \                   #</span></span><br><span class="line"><span class="comment"> *      lx  rx                                rx  ry</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_right_rotate</span><span class="params">(RBRoot *root, Node *y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置x是当前节点的左孩子。</span></span><br><span class="line">    Node *x = y-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “x的右孩子” 设为 “y的左孩子”；</span></span><br><span class="line">    <span class="comment">// 如果"x的右孩子"不为空的话，将 “y” 设为 “x的右孩子的父亲”</span></span><br><span class="line">    y-&gt;left = x-&gt;right;</span><br><span class="line">    <span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">        x-&gt;right-&gt;parent = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y的父亲” 设为 “x的父亲”</span></span><br><span class="line">    x-&gt;parent = y-&gt;parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y-&gt;parent == <span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//tree = x;            // 如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line">        root-&gt;node = x;            <span class="comment">// 如果 “y的父亲” 是空节点，则将x设为根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (y == y-&gt;parent-&gt;right)</span><br><span class="line">            y-&gt;parent-&gt;right = x;    <span class="comment">// 如果 y是它父节点的右孩子，则将x设为“y的父节点的右孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;parent-&gt;left = x;    <span class="comment">// (y是它父节点的左孩子) 将x设为“x的父节点的左孩子”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y” 设为 “x的右孩子”</span></span><br><span class="line">    x-&gt;right = y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 “y的父节点” 设为 “x”</span></span><br><span class="line">    y-&gt;parent = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><h3 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修正"><a href="#修正" class="headerlink" title="修正"></a>修正</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="直接删除"><a href="#直接删除" class="headerlink" title="直接删除"></a>直接删除</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修正-1"><a href="#修正-1" class="headerlink" title="修正"></a>修正</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 添加节点：将节点(node)插入到红黑树中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 参数说明：</span></span><br><span class="line"><span class="comment"> *     root 红黑树的根</span></span><br><span class="line"><span class="comment"> *     node 插入的结点        // 对应《算法导论》中的z</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rbtree_insert</span><span class="params">(RBRoot *root, Node *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *y = <span class="literal">NULL</span>;</span><br><span class="line">    Node *x = root-&gt;node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 将红黑树当作一颗二叉查找树，将节点添加到二叉查找树中。</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; x-&gt;key)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    rb_parent(node) = y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (y != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;key &lt; y-&gt;key)</span><br><span class="line">            y-&gt;left = node;                <span class="comment">// 情况2：若“node所包含的值” &lt; “y所包含的值”，则将node设为“y的左孩子”</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            y-&gt;right = node;            <span class="comment">// 情况3：(“node所包含的值” &gt;= “y所包含的值”)将node设为“y的右孩子” </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;node = node;                <span class="comment">// 情况1：若y是空节点，则将node设为根</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 设置节点的颜色为红色</span></span><br><span class="line">    node-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将它重新修正为一颗二叉查找树</span></span><br><span class="line">    rbtree_insert_fixup(root, node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Free-Talk"><a href="#Free-Talk" class="headerlink" title="Free Talk"></a>Free Talk</h1><p>我打算在今后的板块中都增加一个Free Talk的环节，讲讲自己的感受。<br>其实之前一直有听说过红黑树的名字，就是没有深入了解，正好在家待着没事干，就打算写一个数据结构与算法的系列，就当做是复习和进一步学习吧。<br>这次的博客主要是参考了两篇文章，一篇是比较详细的讲解算法实现和原理，一篇特点是动图易懂。自己写完了这篇博客也只能算是懂了第二篇，算法的后半部分确实没啃动。感觉一开始就将红黑树有些硬核，面试应该不可能有手写代码吧。<br>接下打算就是把JVM的系列和数据结构与算法的系列穿插着写，然后算法的系列会加入LeetCode模块，JVM的系列还没有考虑好要怎么用代码实现学习。<br><strong>To be a better man!</strong></p>
<p>参考链接：<br><a href="https://www.cnblogs.com/skywang12345/p/3245399.html" target="_blank" rel="noopener">博客园</a><br><a href="https://segmentfault.com/a/1190000020118044" target="_blank" rel="noopener">segment</a></p>
]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（二）-- Java内存管理</title>
    <url>/JVM%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p><a href="https://imgchr.com/i/tmAiTO" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/28/tmAiTO.md.png" alt="tmAiTO.md.png"></a></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器就是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，和计组中学到的大致一样。</p>
<a id="more"></a>
<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理执行时间的方式来实现的，也就是操作系统中学到的并发性–两个或多个事件在<em>同一时间间隔</em>内发生，在任何时刻仅会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“<strong>线程私有</strong>”的内存。</p>
<p>如果线程正在执行的是一个Java方法，这个计算器记录的是正在执行的虚拟机字节码指令的地址；<br>如果正在执行的是本地(Native)方法，这个计数器值则应为空(Undefined)。<br>此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
<!--more-->
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stack)也是<em>线程私有</em>的，它的生命周期与线程相同。虚拟机站描述的是<strong>Java方法执行的线程内存模型</strong>：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame:是方法运行期很重要的基础数据结构，后面会补充)用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表存放了编译期可知的各种Java虚拟机<strong>基本数据类型</strong>(boolean、byte、char、short、int、float、long、double)、<strong>对象引用</strong>(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和<code>returnAddress</code>类型(指向了一条字节码指令的地址)。</p>
<blockquote>
<p>这些数据类型在局部变量表中的存储空间以<strong>局部变量槽(Slot)</strong> 来表示，其中64位长度的long和double类型的数据会占用<em>两个变量槽</em>，其余的数据类型只占用一个。局部变量表所需的内存空间在<strong>编译期间完成分配</strong>，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是<em>完全确定的</em>，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>
</blockquote>
<blockquote>
<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出<code>StackOverflowerError</code>异常;</li>
<li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出<code>OutOfMemoryError</code>异常。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>动态扩展：</strong>HotSpot虚拟机的栈容量是不可以动态扩展的，以前的Classic虚拟机倒是可以。所以在Hotspot虚拟机上是不会由于虚拟机栈无法扩展而导致<code>OutOfMemoryError</code>异常–只要线程申请栈空间成功了就不会有OOM，但是如果申请时失败，仍然是会出现OOM异常的。</p>
</blockquote>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为<em>虚拟机执行Java方法(也就是字节码)服务</em>，而本地方法栈则是<strong>为虚拟机使用到的本地(Native)方法服务</strong>。</p>
<p>《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>
<h3 id="Native-Method"><a href="#Native-Method" class="headerlink" title="Native Method"></a>Native Method</h3><p>Native Method就是一个java调用非java代码的接口。一个Native Method是这样一个java的方法：该方法的实现由非java语言实现，比如C。这个特征并非java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern “C”告知C++编译器去调用一个C的函数。</p>
<p><a href="https://blog.csdn.net/wike163/article/details/6635321" target="_blank" rel="noopener">详细介绍</a></p>
<h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><p>对于Java应用程序来说，<strong>Java堆(Java Heap)</strong>是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是<strong>存放对象实例</strong>，Java世界里“几乎”所有对象实例都在这里分配内存。</p>
<blockquote>
<p>在《Java虚拟机规范》中对Java堆的描述是：“所有的对象实例以及数组都应当在堆上分配”，而这里笔者写的“几乎”是指从实现角度来看，随着Java语言的发展，现在已经能看到些许迹象表明日后可能出现值类型的支持，即使只考虑现在，由于即时编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说Java对象实例都分配在堆上也渐渐变得不是那么绝对了。</p>
</blockquote>
<p>Java堆是垃圾收集管理器管理的内存区域，因此一些资料中它也被称为“<strong>GC堆</strong>”(Garbage Collected Heap)。从回收内存的角度看，由于现代垃圾收集器大部分都是基于<strong>分代收集理论</strong>设计的，所以Java堆中经常会出现 <strong>“新生代”、“老年代”、“永久代”</strong>等名字；再细致一点的有<strong>Eden空间、From Survivor空间、To Survivor空间</strong>等(面试常问)</p>
<p><img src="http://ifeve.com/wp-content/uploads/2015/05/JUtH_20121024_RuntimeDataAreas_2_MemoryModel-1.png" alt="image"><br>所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）。</p>
<p>根据Java虚拟机规范的规定，Java堆可以处于<strong>物理上不连续的内存空间中，只要逻辑上是连续的即可</strong>，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。</p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出<code>OutOfMemoryError</code>异常。</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于<strong>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存</strong>等数据。</p>
<p>方法的执行都是伴随着线程的。<strong>原始类型的本地变量以及引用</strong>都存放在<strong>线程栈</strong>中。而<strong>引用关联的对象</strong>比如String，都存在在<strong>堆中</strong>。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>运行时常量池（Runtime Constant Pool）</strong>是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表（Constant PoolTable），用于存放<strong>编译期生成的各种字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><p>HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程。</p>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>遇到一条new指令时的创建过程：</p>
<ol>
<li>检查这个指令的参数能否在常量池中定位到一个<strong>类的符号引用</strong>，并检查这个符号引用代表的类是否已被<em>加载、解析和初始化过</em>；</li>
<li>类加载检查通过后，虚拟机将为新对象<strong>分配内存</strong>，此时可以确定存储这个对象所需的<em>内存大小</em>；</li>
<li>在堆中为新对象分配可用内存；</li>
<li>将分配到的内存初始化；</li>
<li>设置对象头中的数据；</li>
<li>此时，从虚拟机的角度看，对象已经创建好了，但从Java程序的角度看，对象创建才刚刚开始，构造函数还没有执行。</li>
</ol>
<h3 id="如何在堆中为新对象划分可用的内存？"><a href="#如何在堆中为新对象划分可用的内存？" class="headerlink" title="如何在堆中为新对象划分可用的内存？"></a>如何在堆中为新对象划分可用的内存？</h3><p><strong>指针碰撞(内存分配规整)</strong></p>
<ul>
<li>用过的内存放一边，没用过的内存放一边，中间用一个指针分割；</li>
<li>分配内存的过程就是将指针向没有用过的内存那边移动所需的长度。</li>
</ul>
<p><strong>空闲列表(内存分配不规整)</strong></p>
<ul>
<li>维护一个列表，记录哪些内存块是可用的；</li>
<li>分配内存时，从列表上选取一块足够大的空间分配给对象，并更新列表上的记录。</li>
</ul>
<h3 id="如何处理多线程创建对象时，划分内存的指针的同步问题？"><a href="#如何处理多线程创建对象时，划分内存的指针的同步问题？" class="headerlink" title="如何处理多线程创建对象时，划分内存的指针的同步问题？"></a>如何处理多线程创建对象时，划分内存的指针的同步问题？</h3><ul>
<li>对分配内存空间的动作进行<strong>同步处理(CAS)</strong>;</li>
<li>把内存分配动作按照线程划分在<strong>不同的空间</strong>之中进行；<ol>
<li>每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>(Thread Local Allocation Buffer,TLAB);</li>
<li>哪个线程要分配内存就在哪个线程的TLAB上分配，TLAB用完需要分配新的TLAB时，才需要同步锁定；</li>
<li>通过 <code>-XX:+/-UseTLAB</code>参数设定是否使用 TLAB。</li>
</ol>
</li>
</ul>
<h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在Hotspot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)</strong>。</p>
<h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p><strong>对象头部分</strong>包括两类信息：</p>
<ol>
<li><strong>运行数据：</strong>用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志等。(见官方 Mark Word)<br><img src="https://s1.ax1x.com/2020/05/28/te5Rcq.png" alt="te5Rcq.png"></li>
<li><strong>类型指针：</strong>即对象指向它的类型元数据的指针，Java虚拟机通过这个指针确定该对象是哪个类的实例。</li>
</ol>
<h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的<strong>各种类型的字段内容</strong>，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>
<ul>
<li><strong>默认分配顺序：</strong>longs/doubles、ints、shorts/chars、bytes/booleans、oops (Ordinary Object Pointers)，相同宽度的字段会被分配在一起，除了 oops，其他的长度由长到短；</li>
<li>默认分配顺序下，父类字段会被分配在子类字段前面。</li>
</ul>
<h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对象的第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着<strong>占位符</strong>的作用。<br>HotSpot VM要求对象的起始地址必须是<strong>8字节的整数倍</strong>，所以不够要补齐。</p>
<h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>Java 程序需要通过虚拟机栈上的 <strong>reference 数据</strong>来操作堆上的具体对象，reference 数据是一个指向对象的引用，不过如何通过这个引用定位到具体的对象，目前主要有以下两种访问方式：<strong>句柄访问和直接指针访问</strong>。</p>
<h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>句柄访问会在Java堆中划分一块内存作为句柄池，每一个句柄存放着对象类型数据的指针。</p>
<p><strong>优势：</strong>对象移动的时候(这在垃圾回收时十分常见)只需改变句柄池中<strong>对象实例数据的指针</strong>，不需要修改Reference本身。<br><img src="https://s1.ax1x.com/2020/05/28/te7VDx.png" alt="te7VDx.png"></p>
<h3 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h3><p>直接指针访问方式在Java堆对象的实例数据中存放了一个指向对象实例数据和对象类型数据的指针，在HotSpot中，这个指针会被存放在对象头中。</p>
<p><strong>优势：</strong>减少了一次指针定位对象实例数据的开销，速度更快。<br><img src="https://s1.ax1x.com/2020/05/28/teHwTK.png" alt="teHwTK.png"></p>
<p>参考目录：<br><a href="http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html" target="_blank" rel="noopener">纯洁的微笑</a><br><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch1-Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/00-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AF%A6%E8%A7%A3.md" target="_blank" rel="noopener">Github笔记总结</a><br>《深入理解java虚拟机》</p>
]]></content>
      <categories>
        <category>java后端开发</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM系列（一）--Java类的加载机制</title>
    <url>/JVM-1/</url>
    <content><![CDATA[<h1 id="类的加载定义"><a href="#类的加载定义" class="headerlink" title="类的加载定义"></a>类的加载定义</h1><p>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。</p>
<p><img src="http://favorites.ren/assets/images/2017/jvm/jvm-1.png" alt="image"></p>
<p>类的最终加载产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并向Java程序提供访问接口。</p>
<p>与C语言的类比：C语言 –&gt; 二进制文件 –&gt; 计算机硬件；Java –&gt; 字节码文件 –&gt; JVM</p>
<blockquote>
<p><strong>注意事项：</strong>类加载器并不需要等到某个类被“首次主动使用”时再加载，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，但是如果这个类在加载中遇到错误，只有在主动使用此类时才会报错(LinkageError)。</p>
</blockquote>
<a id="more"></a>

<h1 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h1><p>加载(Loading) –&gt;  <strong>验证(Verification) –&gt; 准备(Preparation) –&gt; 解析(Resolution)</strong> –&gt; 初始化(Intialization) –&gt; 使用(Using) –&gt; 卸载(Unloading) 共七个阶段；其中验证、准备和解析又统称为<strong>连接(Linking)阶段</strong>。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy80QUc2dGljNjhBR2JSNnc4bWQ5cW1vcmdldjV5cHN0aWF3ekRKNk5kNmFONUZJRzVzaWFyYmlhTUFSSmljeFQ0UmR2ZzZtaDRhUWdnSVlmQ0xZNTAwMHVIRGliUS82NDA_d3hfZm10PXBuZw?x-oss-process=image/format,png" alt="image"></p>
<blockquote>
<p>在前五个阶段中，加载、验证、准备、初始化的顺序是确定的，但是解析阶段不一定，它在某些情况下可以在初始化阶段之前开始，这是为了支持Java的动态绑定。</p>
</blockquote>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p><strong>三个任务：</strong></p>
<blockquote>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流</li>
<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的运行时<strong>数据结构</strong></li>
<li>在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中数据的访问入口</li>
</ul>
</blockquote>
<h2 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h2><p><strong>四个阶段：</strong></p>
<blockquote>
<ul>
<li><strong>文件格式验证</strong>：验证字节流是否符合Class文件格式规范；</li>
<li><strong>云数据验证</strong>：对字节码描述的信息进行语义分析，以保证满足java语言的规范</li>
<li><strong>字节码验证</strong>：通过数据流和控制流，确保程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能够正确执行</li>
</ul>
</blockquote>
<blockquote>
<p>ps: 验证阶段非常重要，但是不是必须的，如果引用的类已经经过反复验证了，就可以使用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
</blockquote>
<h2 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h2><ol>
<li>这时候进行内存分配的仅包括类变量(static)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在java堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值(如0，null,false),而不是被在java代码中显示赋予的值。</li>
<li>如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</li>
</ol>
<p><strong>示例：</strong></p>
<blockquote>
<p>假设一个类变量的定义为：<code>public static int value = 3;</code><br>那么变量value在准备阶段过后的初始值为0，而不是3。因为此时尚未执行任何java方法，而赋值为3是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法中的，在初始化阶段执行。</p>
</blockquote>
<p> 这里还需要注意如下几点：</p>
<blockquote>
<ul>
<li>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。<ul>
<li>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将<strong>常量池内的符号引用替换为直接引用</strong>的过程。<br>符号引用就是一组符号来描述目标，可以是任何字面量。<br>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在java中对类变量进行初始值设定有两种方式：</p>
<blockquote>
<ol>
<li>声明类变量是指定初始值</li>
<li>使用静态代码块为类变量指定初始值</li>
</ol>
</blockquote>
<p><strong>JVM初始化步骤</strong></p>
<blockquote>
<ol>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句</li>
</ol>
</blockquote>
<p>类初始化时机：只有当对类的主动引用的时候才会导致类的初始化。<br><strong>类的主动引用</strong>包括以下六种：</p>
<blockquote>
<ol>
<li>创建类的实例，也就是new的方式</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（如 Class.forName(“com.shengsiyuan.Test”)）</li>
<li>初始化某个类的子类，则其父类也会被初始化</li>
<li>Java虚拟机启动时被标明为启动类的类（ JavaTest），直接使用 java.exe命令来运行某个主类</li>
</ol>
</blockquote>
<p>被动引用：</p>
<blockquote>
<ol>
<li>通过子类引用父类静态字段，不会导致子类初始化；</li>
<li>Array[] arr = new Array[10]; 不会触发 Array 类初始化；</li>
<li>static final VAR 在编译阶段会存入调用类的常量池，通过 ClassName.VAR 引用不会触发 ClassName 初始化。</li>
</ol>
</blockquote>
<h2 id="介绍生命周期"><a href="#介绍生命周期" class="headerlink" title="介绍生命周期"></a>介绍生命周期</h2><p>以下四种情况：</p>
<blockquote>
<ul>
<li>执行了 System.exit()方法</li>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统出现错误而导致Java虚拟机进程终止</li>
</ul>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p><img src="http://favorites.ren/assets/images/2017/jvm/calssloader.png" alt="image"></p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：<br><strong>启动类加载器：</strong><br>它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；<br><strong>所有其它的类加载器：</strong><br>这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类 <code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p><strong>启动类加载器：</strong><code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。<br><strong>扩展类加载器：</strong><code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。<br><strong>应用程序类加载器：</strong><code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><ul>
<li><strong>全盘负责：</strong>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入；</li>
<li><strong>父类委托：</strong>先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类；</li>
<li><strong>缓存机制：</strong>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓冲区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。*这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</li>
</ul>
<h1 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h1><h2 id="显式加载"><a href="#显式加载" class="headerlink" title="显式加载"></a>显式加载</h2><p>调用<code>ClassLoader#loadClass(className)</code>或<code>Class.forName(className)</code>。<br>区别：</p>
<blockquote>
<ol>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
<li>Class.forName(name,initialize,loader)带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象 。</li>
</ol>
</blockquote>
<h2 id="隐式加载"><a href="#隐式加载" class="headerlink" title="隐式加载"></a>隐式加载</h2><ol>
<li>new类对象；</li>
<li>使用类的静态域；</li>
<li>创建子类对象；</li>
<li>使用子类的静态域；</li>
<li>其他的隐式加载，在JVM启动时：<blockquote>
<ul>
<li>BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；</li>
<li>ExtClassLoader 会加载指定目录下一些特殊的 Class；</li>
<li>AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。</li>
</ul>
</blockquote>
</li>
</ol>
<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p><strong>工作流程：</strong>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p><strong>双亲委派机制：</strong></p>
<ol>
<li><p>当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</p>
</li>
<li><p>当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给<code>BootStrapClassLoader</code>去完成。</p>
</li>
<li><p>如果 <code>BootStrapClassLoader</code>加载失败（例如在 $JAVA_HOME/jre/lib里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</p>
</li>
<li><p>若<code>ExtClassLoader</code>也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code>。</p>
</li>
</ol>
<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><ol>
<li><p>简单讲下JVM中的类加载过程</p>
</li>
<li><p>JVM中的类加载和卸载的时机？</p>
</li>
<li><p>如何理解JVM中不同类加载器的概念和作用？</p>
</li>
<li><p>简单讲下JVM中的双亲委派模型？</p>
</li>
<li><p>什么情况下会破坏双亲委派模型？为什么？可否举个例子？</p>
</li>
<li><p>Tomcat中的类加载机制有了解吗？为什么这么设计？</p>
</li>
<li><p>实际开发中有遇到哪些类加载器相关的问题？你又是如何解决的？</p>
</li>
<li><p>JVM之上的弱类型语言例如Groovy是如何实现？简单讲下动态类加载机制？<br>参考资料：<br><a href="https://mp.weixin.qq.com/s?__biz=MzI4NDY5Mjc1Mg==&mid=2247483934&idx=1&sn=41c46eceb2add54b7cde9eeb01412a90&chksm=ebf6da61dc81537721d36aadb5d20613b0449762842f9128753e716ce5fefe2b659d8654c4e8&scene=21#wechat_redirect" target="_blank" rel="noopener">微信公众号</a><br><a href="https://github.com/TangBean/understanding-the-jvm/blob/master/Ch2-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C/01-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noopener">Github博主</a><br><a href="https://blog.csdn.net/duqi_2009/article/details/101877579" target="_blank" rel="noopener">Blog</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>java后端开发</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>java类</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言学习总结</title>
    <url>/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h1><h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p><strong>ret 指令</strong>用栈中的数据，<strong>修改IP的内容</strong>，从而实现近转移；<br><strong>retf 指令</strong>用栈中的数据，<strong>修改CS和IP的内容</strong>，从而实现远转移。</p>
<p>ret 指令相当于</p>
<blockquote>
<p>pop IP</p>
</blockquote>
<p>retf 指令相当于</p>
<blockquote>
<p>pop IP<br>  pop CS</p>
</blockquote>
<a id="more"></a>
<p>检测点10.1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs: code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 16 dup(0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:  mov ax, stack</span><br><span class="line">        mov ss, ax</span><br><span class="line">        mov sp, 16</span><br><span class="line">        mov ax, 1000h;cs地址</span><br><span class="line">        push ax</span><br><span class="line">        mov ax, 0 ;ip地址</span><br><span class="line">        push ax</span><br><span class="line">        retf</span><br><span class="line">        ;retf指令相当于是pop ip,pop cs</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h2><ol>
<li>call 标号<blockquote>
<p>push IP<br>jmp near ptr 标号</p>
</blockquote>
</li>
<li>call far ptr 标号<blockquote>
<p>push CS<br>push IP<br>jmp near ptr 标号</p>
</blockquote>
</li>
<li>call 16位 reg<blockquote>
<p>push IP<br>jmp 16位 reg</p>
</blockquote>
</li>
<li>call word ptr 内存单元地址<blockquote>
<p>push IP<br>jmp word ptr 内存单元地址</p>
</blockquote>
</li>
<li>call dword ptr 内存单元地址<blockquote>
<p>push CS<br>push IP<br>jmp dword ptr 内存单元地址</p>
</blockquote>
</li>
</ol>
<h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><blockquote>
<p>call 标号<br>标号：<br>    指令<br>    ret</p>
</blockquote>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><ol>
<li><strong>两个相乘的数：</strong><br>两个相乘的数，要么都是8位，要么都是16位。<br>如果是8位，一个默认放在AL中，另一个放在8位reg或内存字节单元中；<br>如果是16位，一个默认在AX中，另一个放在16位reg或内存字单元中。</li>
<li><strong>结果：</strong><br>如果是8位乘法，结果默认放在AX中；<br>如果是16位乘法，结果高位默认在DX中存放，低位在AX中放。</li>
</ol>
<blockquote>
<p> mul reg<br>mul 内存单元<br> mul byte ptr ds:[0]</p>
</blockquote>
<h2 id="实验十："><a href="#实验十：" class="headerlink" title="实验十："></a>实验十：</h2><figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">    <span class="built_in">db</span> <span class="number">10</span> dup(<span class="number">0</span>)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">12345</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">bx</span>, data</span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ds</span>, <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">call</span> dtoc</span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="number">dh</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">dl</span>, <span class="number">3</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="number">2</span></span><br><span class="line">        <span class="keyword">call</span> show_str <span class="comment">;IP入栈</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">4c00h</span></span><br><span class="line">        <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">show_str:</span></span><br><span class="line">    <span class="comment">;把需要用到的寄存器入栈保护</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">es</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">;计算起始偏移地址</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">160</span> <span class="comment">;行地址</span></span><br><span class="line">    <span class="keyword">dec</span> <span class="number">dh</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="number">dh</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="number">2</span>  <span class="comment">;列地址</span></span><br><span class="line">    <span class="keyword">dec</span> <span class="built_in">dl</span></span><br><span class="line">    <span class="keyword">mul</span> <span class="built_in">dl</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">bx</span>, <span class="built_in">ax</span> <span class="comment">;偏移地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0b800h</span><span class="comment">;</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>, <span class="built_in">ax</span> <span class="comment">;基址地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">al</span>, <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">;循环执行mov指令</span></span><br><span class="line"><span class="symbol">s:</span>  <span class="keyword">mov</span> <span class="built_in">cl</span>, <span class="built_in">ds</span>:[<span class="built_in">si</span>] <span class="comment">;判断是否结束循环</span></span><br><span class="line">    <span class="keyword">jcxz</span> ok</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>], <span class="built_in">cl</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">bx</span>+<span class="number">1</span>], <span class="built_in">al</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">bx</span>, <span class="number">2</span></span><br><span class="line">    <span class="keyword">jmp</span> short s</span><br><span class="line"></span><br><span class="line"><span class="symbol">ok:</span> </span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">es</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">ret</span> <span class="comment">;IP出栈</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">dtoc:</span> </span><br><span class="line">    <span class="comment">; 寄存器入栈保护</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">cx</span></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="comment">; 计算十进制数字每位的值</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">10d</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="symbol">s1:</span> <span class="keyword">mov</span> <span class="built_in">dx</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">div</span> <span class="built_in">bx</span></span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">ax</span></span><br><span class="line">    <span class="keyword">add</span> <span class="built_in">dx</span>, <span class="number">30H</span> <span class="comment">; 转换ASCII码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">push</span> <span class="built_in">dx</span></span><br><span class="line">    <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">    <span class="keyword">jcxz</span> over</span><br><span class="line">    <span class="keyword">jmp</span> short s1</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="symbol">over:</span>   <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">si</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">s2:</span>     <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">        <span class="keyword">mov</span> <span class="built_in">ds</span>:[<span class="built_in">si</span>], <span class="built_in">dx</span> <span class="comment">; 修改到data字段</span></span><br><span class="line">        <span class="keyword">inc</span> <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">loop</span> s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">dx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">cx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">bx</span></span><br><span class="line">        <span class="keyword">pop</span> <span class="built_in">si</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><p><img src="https://s1.ax1x.com/2020/06/01/t837KH.png" alt="t837KH.png"><br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义；<br>而flag寄存器是按位起作用的，也就是说，它的每一位都有专门的含义，记录特定的信息。</p>
<h2 id="ZF标志-第6位-–零标志位"><a href="#ZF标志-第6位-–零标志位" class="headerlink" title="ZF标志(第6位)–零标志位"></a>ZF标志(第6位)–零标志位</h2><p>记录相关指令执行后，其结果是否为0.</p>
<ol>
<li>结果为0：zf=1；</li>
<li>结果不为0：zf=0。<blockquote>
<p>注意是与结果相反的</p>
</blockquote>
</li>
</ol>
<h2 id="PF标志-第2位-–奇偶标志位"><a href="#PF标志-第2位-–奇偶标志位" class="headerlink" title="PF标志(第2位)–奇偶标志位"></a>PF标志(第2位)–奇偶标志位</h2><p>它记录相关指令执行后，其结果的所有bit位中1的个数是否为偶数。</p>
<ol>
<li>1的个数为偶数：pf=1，</li>
<li>奇数：pf=0。</li>
</ol>
<h2 id="SF标志-第7位-–符号标志位"><a href="#SF标志-第7位-–符号标志位" class="headerlink" title="SF标志(第7位)–符号标志位"></a>SF标志(第7位)–符号标志位</h2><ol>
<li>结果为负，SF=1；</li>
<li>结果为正，SF=0。</li>
</ol>
<p>通常用补码来表示有符号数据。<br>因此，对于一个二进制数据，计算机在既把它当做有符号数运算也进行无符号数运算，同时提供两种结果给程序选择。</p>
<h2 id="CF标志-第0位-–进位-借位标志位"><a href="#CF标志-第0位-–进位-借位标志位" class="headerlink" title="CF标志(第0位)–进位/借位标志位"></a>CF标志(第0位)–进位/借位标志位</h2><p>记录最高有效位向更高有效位的进位/借位<br><img src="https://s1.ax1x.com/2020/06/01/t8Nvin.png" alt="t8Nvin.png"></p>
<ol>
<li>有进位/借位：CF=1，</li>
<li>无进位/借位：CF=0。</li>
</ol>
<h2 id="OF标志-第11位-–溢出标志位"><a href="#OF标志-第11位-–溢出标志位" class="headerlink" title="OF标志(第11位)–溢出标志位"></a>OF标志(第11位)–溢出标志位</h2><ol>
<li>有溢出：OF=1，</li>
<li>无溢出：OF=0。</li>
</ol>
<p><strong>CF和OF的区别：</strong><br>CF是对无符号数运算有意义的标志位；<br>OF是对有符号数运算有意义的标志位。</p>
<h2 id="adc指令"><a href="#adc指令" class="headerlink" title="adc指令"></a>adc指令</h2><p>adc是带进位加法指令，它利用了CF位上记录的进位值。</p>
<blockquote>
<p>adc obj1,obj2<br>obj1 = obj1+obj2+CF</p>
</blockquote>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><h1 id="寄存器-内存访问"><a href="#寄存器-内存访问" class="headerlink" title="寄存器(内存访问)"></a>寄存器(内存访问)</h1><h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><h1 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h1><h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><h1 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h1>]]></content>
      <categories>
        <category>课程总结</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA后端开发学习路线</title>
    <url>/java%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<h1 id="JAVA学习路线"><a href="#JAVA学习路线" class="headerlink" title="JAVA学习路线"></a>JAVA学习路线</h1><p><img src="http://assets.processon.com/chart_image/5ec28f620791290fe06e73f8.png" alt="思维导图"></p>
<a id="more"></a>
<p><a href="https://www.processon.com/embed/5ec28f620791290fe06e73f5" target="_blank" rel="noopener">思维导图在线链接</a><br>感谢来自CodeSheep大神的总结，<a href="https://www.bilibili.com/video/BV1GQ4y1N7HD" target="_blank" rel="noopener">视频链接</a></p>
<h1 id="学习资料总结"><a href="#学习资料总结" class="headerlink" title="学习资料总结"></a>学习资料总结</h1><ol>
<li>Java 基础，那必须 <a href="https://www.bilibili.com/video/BV1GZ4y1s7MG" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GZ4y1s7MG</a></li>
<li>虚拟机，毋庸置疑，肯定是胡志明老师的《深入理解 Java 虚拟机》，累计销售 30W 本，你说中国才有多少 Java 开发呢？</li>
<li>多线程，我是一点点点看阿里P7清英的书学会的，看了三篇，还是非常经典《Java并发编程的艺术》</li>
<li>数据结构和算法， LeetCode 官方国内唯一合作课程，专注于面试场景，全程动态动画教学。我也是一边看这个视频一边刷 LeetCode的，只想说刷完 LeetCode 你会发现，面试的算法全是原题。【付费资料，非喜勿入】<a href="https://t.lagou.com/pR69ReRlRg43F" target="_blank" rel="noopener">https://t.lagou.com/pR69ReRlRg43F</a></li>
<li>计算机网络：《图解HTTP》非常经典，自行购买</li>
<li>SQL/数据库，阿里P9梳理的知识点，看了三遍，每次都是看完都能吊打面试官【付费资料，非喜勿入】<a href="https://urlify.cn/myAZfe" target="_blank" rel="noopener">https://urlify.cn/myAZfe</a></li>
<li>操作系统，那肯定是那本经典神书了《操作系统》，好不好豆瓣脑补。<a href="https://book.douban.com/subject/5064311/" target="_blank" rel="noopener">https://book.douban.com/subject/5064311/</a></li>
<li>设计模式，设计模式看了N多内容包括书籍，但是还是强烈推荐 Google 王峥教程，我也是第一次才知道，学设计模式要和框架和 JDK 本身使用的设计模式结合起来看，<a href="https://urlify.cn/JBZvqy" target="_blank" rel="noopener">https://urlify.cn/JBZvqy</a></li>
<li>IDEA，只能说牛逼，不过太贵了，分享一个免费可用的注册码<a href="https://juejin.im/post/5eb69a23e51d454db678bdd3" target="_blank" rel="noopener">https://juejin.im/post/5eb69a23e51d454db678bdd3</a></li>
<li>Linux，《鸟哥的Linux 私房菜》据说这本书是所有人入门的必看书籍</li>
<li>Maven 是每个前端开发必须的，是时候搞起来了，不过这种工具可以直接上手不用资料</li>
<li>Git，SVN已经废弃了，其实 Git 基本不用看视频，对着文档搞搞搞，30分钟就拿下了 <a href="https://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/git/git-tutorial.html</a></li>
<li>Spring Boot，我必须第一个推荐微笑哥的博客，国内最早做 Spring Boot 教程的人，你看了就知道有多全 <a href="https://www.cnblogs.com/ityouknow/p/5662753.html" target="_blank" rel="noopener">https://www.cnblogs.com/ityouknow/p/5662753.html</a> 对的还有一个非常不错的面试 Spring Boot 实战视频，算是 B站的第一原创 Spring Boot 视频吧 看得起劲 BV1Zb41137X2</li>
<li>Spring Cloud 那必须推荐方志朋老师的专栏，算是全网阅读最高，目前1000W阅读，你觉得阅读都是刷的吗？好不好自己去瞅瞅 <a href="https://blog.csdn.net/forezp/column/info/15197" target="_blank" rel="noopener">https://blog.csdn.net/forezp/column/info/15197</a></li>
<li>RabbitMQ，Kafka 算是面试必考了，我果断买了厮大两本书《RabbitMQ实战指南》《深入理解Kafka》</li>
<li>Dubbo 的其实更推荐直接看 Spring Cloud，为啥子呢？Spring Cloud 相当于开发商精装交付的房子，Dubbo 相当于毛坯房，为了省心还是推荐直接看 Spring Cloud</li>
<li>数据库连接池无论什么方便 HikariCP 都能玩爆其他</li>
<li>微服务太大了，服务发现，网关，调用，熔断和降级，配置中心，分布式事务，任务调度，这里真心难通过视频看懂，所以如果你现在接触不到，建议你自己搞一个项目或者换个工作吧，如果你没有真正的用起来准备也没用，因为你也回答不出来精髓。</li>
<li>容器技术，那肯定是 docker，我是看阮一峰老师的博客入门的，30 分钟稳稳的入门，你信么<a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a></li>
</ol>
<p>目前上述学习总结转载自<a href="https://www.devcuss.com/a/708977837062750208" target="_blank" rel="noopener">https://www.devcuss.com/a/708977837062750208</a> ，之后会在学习中不断地更新上述学习资料。</p>
<p>给自己定一个小目标，半年来学会思维导图里的100%的编程基础和研发工具，以及了解50%的应用框架，熟练使用10%的应用框架。</p>
]]></content>
      <categories>
        <category>java后端开发</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Github入门教学</title>
    <url>/Github%E5%85%A5%E9%97%A8%E6%95%99%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="GitHub入门教学（Git，界面介绍，搜索）"><a href="#GitHub入门教学（Git，界面介绍，搜索）" class="headerlink" title="GitHub入门教学（Git，界面介绍，搜索）"></a>GitHub入门教学（Git，界面介绍，搜索）</h1><h2 id="前提：Git使用"><a href="#前提：Git使用" class="headerlink" title="前提：Git使用"></a>前提：Git使用</h2><p>GitHub是基于Git开发得到，学习Git是了解GitHub的前提，在这里我推荐一个特别喜欢的学习教程。</p>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰Git教学</a></p>
<p>简单示例</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">mkdir learngit <span class="meta">#创建一个空白目录</span></span><br><span class="line">cd learngit </span><br><span class="line"></span><br><span class="line">git init <span class="meta">#把这个目录变成Git可以管理的仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">add</span> readme.txt <span class="meta">#把文件添加到仓库</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"wrote a readme file"</span> <span class="meta">#把文件提交给仓库</span></span><br><span class="line"></span><br><span class="line">git <span class="keyword">push</span> -u origin master <span class="meta">#把本地仓库中的所有内容上传到远程库</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2020/06/01/t8gefS.png" alt="t8gefS.png"></p>
<a id="more"></a>
<h2 id="GitHub介绍-敲黑板"><a href="#GitHub介绍-敲黑板" class="headerlink" title="GitHub介绍(敲黑板)"></a>GitHub介绍(敲黑板)</h2><p>Keywords：</p>
<p>版本分支介绍，版本分支比较，Issue，Pull Request，Projects，Wiki，Github Pages</p>
<h2 id="GitHub搜索开源项目"><a href="#GitHub搜索开源项目" class="headerlink" title="GitHub搜索开源项目"></a>GitHub搜索开源项目</h2><p>开源项目的搜索方法</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">pushed:</span>&gt;<span class="number">2020</span><span class="number">-05</span><span class="number">-15</span>   <span class="meta"># 在最近这一天修改过</span></span><br><span class="line"><span class="symbol">in:</span>name [关键字]  <span class="meta"># 名字里面包含关键字</span></span><br><span class="line"><span class="symbol">in:</span>readme [关键字] <span class="meta"># readme里面包含关键字</span></span><br><span class="line"><span class="symbol">in:</span>description 【关键字】<span class="meta"># 描述里面包含关键字</span></span><br><span class="line"><span class="symbol">forks:</span>&gt;<span class="number">4</span> <span class="meta"># stars数量大于4的项目</span></span><br><span class="line"><span class="symbol">stars:</span>&gt;<span class="number">1000</span>  <span class="meta"># stars数量大于1000的项目</span></span><br><span class="line"><span class="symbol">langusge:</span>java  <span class="meta"># 使用java作为开发语言</span></span><br></pre></td></tr></table></figure>

<p>简单示例</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">in:description 爬虫 <span class="keyword">star</span><span class="variable">s:</span>&gt;<span class="number">100</span>  <span class="keyword">language</span>:<span class="keyword">python</span></span><br></pre></td></tr></table></figure>

<h2 id="B站视频链接"><a href="#B站视频链接" class="headerlink" title="B站视频链接"></a><a href="https://www.bilibili.com/video/BV1ea4y1i7NN/" target="_blank" rel="noopener">B站视频链接</a></h2>]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>数学建模算法汇总</title>
    <url>/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/03/AiDVdhUEBgYKtQz.png" alt="image.png"></p>
<h1 id="优化模型"><a href="#优化模型" class="headerlink" title="优化模型"></a>优化模型</h1><a id="more"></a>
<h2 id="优化模型-1"><a href="#优化模型-1" class="headerlink" title="优化模型(1)"></a>优化模型(1)</h2><p><em>三要素:</em> <strong>决策变量、目标函数、约束</strong><br><strong><a href="https://blog.csdn.net/luolang_103/article/details/80567443" target="_blank" rel="noopener">https://blog.csdn.net/luolang_103/article/details/80567443</a></strong><br><img src="https://i.loli.net/2020/02/03/zVPmxnUyRLS1Q57.png" alt="image.png"></p>
<h3 id="单目标（Single-Objective-Optimization-Problem）"><a href="#单目标（Single-Objective-Optimization-Problem）" class="headerlink" title="单目标（Single-Objective Optimization Problem）"></a>单目标（Single-Objective Optimization Problem）</h3><blockquote>
<p>所评测目标只有一个，只需要根据具体的满足函数条件，求得最值</p>
</blockquote>
<h3 id="多目标（Multi-objective-Optimization-Problem）"><a href="#多目标（Multi-objective-Optimization-Problem）" class="headerlink" title="多目标（Multi-objective Optimization Problem）"></a>多目标（Multi-objective Optimization Problem）</h3><blockquote>
<p>多目标优化问题中，同时存在多个最大化或是最小化的目标函数，并且，这些目标函数并不是相互独立的，也不是相互和谐融洽的，他们之间会存在或多或少的冲突，使得不能同时满足所有的目标函数。</p>
</blockquote>
<h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><blockquote>
<p>线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数<br><strong><a href="https://blog.csdn.net/fjssharpsword/article/details/53195556" target="_blank" rel="noopener">https://blog.csdn.net/fjssharpsword/article/details/53195556</a></strong></p>
</blockquote>
<h3 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h3><blockquote>
<p>如果目标函数或者约束条件中至少有一个是非线性函数时，最优化问题叫做非线性规划问题<br><strong><a href="https://blog.csdn.net/qjzcy/article/details/51727741" target="_blank" rel="noopener">https://blog.csdn.net/qjzcy/article/details/51727741</a></strong></p>
</blockquote>
<h3 id="整数规划优化"><a href="#整数规划优化" class="headerlink" title="整数规划优化"></a>整数规划优化</h3><blockquote>
<p>全部变量限制为整数的规划问题，称为纯整数规划；部分变量限制为整数的规划问题，称为混合整数规划；变量只取0或1的规划问题，称为0-1整数规划。<br>整数规划问题，建议使用Lingo软件求解。常用的整数规划问题解法有：<br>（1）分枝定界法：可求纯或混合整数线性规划。<br>（2）割平面法：可求纯或混合整数线性规划。<br>（3）隐枚举法：用于求解0-1整数规划，有过滤法和分枝法。<br>（4）匈牙利法：解决指派问题（0-1规划特殊情形）。<br>（5）蒙特卡罗法：求解各种类型规划。<br><strong><a href="https://zhuanlan.zhihu.com/p/27976866" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27976866</a></strong></p>
</blockquote>
<h3 id="单目标化"><a href="#单目标化" class="headerlink" title="单目标化"></a>单目标化</h3><p><img src="https://i.loli.net/2020/02/03/fwNLboBKaz4qVDI.png" alt="image.png"></p>
<blockquote>
<p>一般采用两个目标函数加权相加的形式。加权可以解决两个目标函数量纲不一致，或者变化剧烈程度不一致的问题，不过权重本身需要人为选取。<br>一般不使用乘法来组合目标函数，因为这样会使得导数的形式变得复杂。<br><strong><a href="https://zhuanlan.zhihu.com/p/30383993" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/30383993</a></strong></p>
</blockquote>
<h2 id="优化模型-2"><a href="#优化模型-2" class="headerlink" title="优化模型(2)"></a>优化模型(2)</h2><h3 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划 Dynamic Programming"></a>动态规划 Dynamic Programming</h3><p><img src="https://i.loli.net/2020/02/03/T9FYRqJgzxSw4am.png" alt="image.png"></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">A * <span class="string">"1+1+1+1+1+1+1+1 =？"</span> *</span><br><span class="line"></span><br><span class="line"><span class="string">A :</span> <span class="string">"上面等式的值是多少"</span></span><br><span class="line"><span class="string">B :</span> *计算* <span class="string">"8!"</span></span><br><span class="line"></span><br><span class="line">A *在上面等式的左边写上 <span class="string">"1+"</span> *</span><br><span class="line"><span class="string">A :</span> <span class="string">"此时等式的值为多少"</span></span><br><span class="line"><span class="string">B :</span> *quickly* <span class="string">"9!"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"你怎么这么快就知道答案了"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"只要在8的基础上加1就行了"</span></span><br><span class="line"><span class="string">A :</span> <span class="string">"所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 '记住求过的解来节省时间'"</span></span><br></pre></td></tr></table></figure>
<p><strong><a href="https://blog.csdn.net/u013309870/article/details/75193592" target="_blank" rel="noopener">https://blog.csdn.net/u013309870/article/details/75193592</a></strong></p>
<blockquote>
<p><strong>1. 将原问题分解为子问题</strong><br>    把原问题分解为若干个子问题，子问题和原问题形式相同或类似，只不过规模变小了。子问题都解决，原问题即解决(数字三角形例）。<br>    子问题的解一旦求出就会被保存，所以每个子问题只需求 解一次。<br> <strong>2. 确定状态</strong><br>    在用动态规划解题时，我们往往将和子问题相关的各个变量的一组取值，称之为一个“状 态”。一个“状态”对应于一个或多个子问题， 所谓某个“状态”下的“值”，就是这个“状 态”所对应的子问题的解。<br>    所有“状态”的集合，构成问题的“状态空间”。“状态空间”的大小，与用动态规划解决问题的时间复杂度直接相关。 在数字三角形的例子里，一共有N×(N+1)/2个数字，所以这个问题的状态空间里一共就有N×(N+1)/2个状态。<br>    整个问题的时间复杂度是状态数目乘以计算每个状态所需时间。在数字三角形里每个“状态”只需要经过一次，且在每个状态上作计算所花的时间都是和N无关的常数。<br>   <strong>3.确定一些初始状态（边界状态）的值</strong><br>    以“数字三角形”为例，初始状态就是底边数字，值就是底边数字值。<br>    <strong>4. 确定状态转移方程</strong><br>     定义出什么是“状态”，以及在该“状态”下的“值”后，就要找出不同的状态之间如何迁移――即如何从一个或多个“值”已知的 “状态”，求出另一个“状态”的“值”(递推型)。状态的迁移可以用递推公式表示，此递推公式也可被称作“状态转移方程”。<br>    数字三角形的状态转移方程:<br><img src="https://i.loli.net/2020/02/03/peAd9XNOTvlDib6.png" alt="image.png"><br><strong><a href="https://blog.csdn.net/baidu_28312631/article/details/47418773" target="_blank" rel="noopener">https://blog.csdn.net/baidu_28312631/article/details/47418773</a></strong></p>
</blockquote>
<h3 id="目标规划"><a href="#目标规划" class="headerlink" title="目标规划"></a>目标规划</h3><blockquote>
<p><strong>1、加权系数法</strong><br>       为每一个目标加一个权系数，把多目标模型转化成单一目标模型。但是困难时确定合理的权系数，以反映不同目标之间的重要程度。<br><strong>2、优先等级法</strong><br>       将各目标按其重要程度分为不同的优先等级，转化为单目标模型。<br><strong>3、有效解法</strong><br>       寻求能够照顾到各个目标，并使决策者感到满意的解。由决策者来确定选取哪一个解，即得到满意的解。但是有效解太多，无法挑选<br><strong><a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4273802.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4273802.html</a></strong></p>
</blockquote>
<h3 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h3><h3 id="网络流模型"><a href="#网络流模型" class="headerlink" title="网络流模型"></a>网络流模型</h3><blockquote>
<p>对于一个网络流我们可以用一个有向图G = （V，E，C）表示；V表示顶点的集合，E表示有向边的集合，C表示有向边的最大流量。对于每一个网络，有一个源输入点，称之为source，一个输出点，称之为sink。在不是出发点source也不是输出点sink的其他点，流量不能超过有向边的最大流量，这是一个约束条件。<br>下图就是一个简单的网络流模型：<br><img src="https://i.loli.net/2020/02/03/SHIw21EnNCq4mZO.png" alt="image.png"><br><strong><a href="https://blog.csdn.net/changyuanchn/article/details/17097807" target="_blank" rel="noopener">https://blog.csdn.net/changyuanchn/article/details/17097807</a></strong></p>
</blockquote>
<h3 id="最短路"><a href="#最短路" class="headerlink" title="最短路"></a>最短路</h3><blockquote>
<p><strong>最短路径问题</strong><br>画图在线平台：<br><strong><a href="https://csacademy.com/app/graph_editor/" target="_blank" rel="noopener">https://csacademy.com/app/graph_editor/</a></strong><br>注意邻接矩阵和关联矩阵的概念！<br><img src="https://i.loli.net/2020/02/03/RvLaVzcdrN3umXO.png" alt="9_GJHOYM9__MAR_K0_F6CNT.png"><br>邻接矩阵：元素为权值，不连接时为无穷(无权时为0/1表示是否相连)<br><img src="https://i.loli.net/2020/02/03/PJ9D8QyEMj1sFml.png" alt="84"><br>解决方法：Dijkstra算法 Floyd算法<br><strong><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html" target="_blank" rel="noopener">https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2615833.html</a></strong><br><strong><a href="https://blog.csdn.net/weixin_43791406/article/details/89314614" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43791406/article/details/89314614</a></strong></p>
</blockquote>
<h3 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h3><blockquote>
<p>网络流图是一张只有一个源点和汇点的有向图，而最大流就是求源点到汇点间的最大水流量，下图的问题就是一个最基本，经典的最大流问题<br><img src="https://i.loli.net/2020/02/03/gJQO9F2SepzR6xy.png" alt="image.png"><br><strong>流量,容量,可行流,增广路</strong><br><strong><a href="https://blog.csdn.net/stevensonson/article/details/79177530" target="_blank" rel="noopener">https://blog.csdn.net/stevensonson/article/details/79177530</a></strong></p>
</blockquote>
<blockquote>
<p>图就是一种管道，管道有最大通过流量的限制，图中边的权值就是所谓的“容量”。同时，注意有唯一的源点和汇点。<br>算法的关键在于<br><strong>1）何为增广路径，如何找出增广路径。</strong><br><strong>2）如何更新流量</strong><br>所谓增广路径，就是找到这样一条路径，其流量不满，未达到容量上限。<br>所有的可能的增广路径在一起便构成了残留网络<br>第一步，计算可增加流量<br>设某一增广路径上的节点为（a1,a2,a3,a4,….,an）<br>如果（u,v）是正向边，则增加流量d = min{ c(ai,aj) - f(ai,aj) | j = i +1, i =1,2,3…,n-1}<br>如果是逆向边，则增加流量d = min{ f(ai, aj) | j = i +1, i =1,2,3…,n-1}<br>第二步，更新流量<br>如果（u,v）是正向边，则 f(u,v) = f(u,v) + d<br>是逆向边，则f(u,v) = f(u,v) - d<br>注意，如果是逆向边，就是减法，当前管道从中减去部分流量，而且，伴随着这部分减去的流量，必有另一部分管道的流量会增加。。而且，最后的总流量增加了d<br><strong>来自 <a href="https://www.cnblogs.com/ShaneZhang/p/3755479.html" target="_blank" rel="noopener">https://www.cnblogs.com/ShaneZhang/p/3755479.html</a></strong></p>
</blockquote>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><blockquote>
<p>图G=（V(G),E(G)）树T=（V(T),E’(T)）<br>在一个连通无向图G=(V, E)中，对于其中的每条边(u,v)∈E，赋予其权重w(u, v)，则最小生成树问题就是要在G中找到一个连通图G中所有顶点的无环子集T⊆E，使得这个子集中所有边的权重之和最小。<br>即生成树为一条连接所有点的路径，最小生成树为权重和最小那个生成树（非环）<br>解决最小生成树问题有两个算法：Prim算法和Kruskal算法<br><strong>Prim算法</strong>基本思想是从选点开始，再选择和不连通点之间的边，进而循环，每一次循环中，一个关键在于判断点之间是否不连通（对连通点集团进行编号，即只需判断集团编号是否相等即可），另一个在于选择最小的边。<br><strong>Kruskal算法</strong>基本思想是从选最小边开始，连通成一个集团，进行编号，再选择不连通的集团的最小赋权边进行连接，依次循环。<br><img src="https://i.loli.net/2020/02/03/ZGHkLWOPjENM6Vg.png" alt="3"><br><strong><a href="https://blog.csdn.net/luoshixian099/article/details/51908175" target="_blank" rel="noopener">https://blog.csdn.net/luoshixian099/article/details/51908175</a></strong></p>
</blockquote>
<h2 id="优化模型-3"><a href="#优化模型-3" class="headerlink" title="优化模型(3)"></a>优化模型(3)</h2><h3 id="背包"><a href="#背包" class="headerlink" title="背包"></a>背包</h3><blockquote>
<p><strong><em>《背包问题九讲》</em></strong><br>背包问题不单单是一个简单的算法问题，它本质上代表了一大类问题，这类问题实际上是01线性规划问题，其约束条件和目标函数如下：<img src="https://i.loli.net/2020/02/03/3iC2xhWNXGuq8v6.png" alt="image.png"><br><strong>eg:01背包问题，完全背包问题，多重背包问题，二维费用背包问题</strong><br><strong><a href="http://dongxicheng.org/structure/knapsack-problems/" target="_blank" rel="noopener">http://dongxicheng.org/structure/knapsack-problems/</a></strong></p>
</blockquote>
<h3 id="指派-分配问题"><a href="#指派-分配问题" class="headerlink" title="指派(分配问题)"></a>指派(分配问题)</h3><blockquote>
<p>实际中，会遇到这样的问题，有n项不同的任务，需要n个人分别完成其中的1项，每个人完成任务的时间不一样。于是就有一个问题，如何分配任务使得花费时间最少。<br>通俗来讲，就是n*n矩阵中，选取n个元素，每行每列各有1个元素，使得和最小。<br>如下图：<br><img src="https://i.loli.net/2020/02/03/d58hrDcQ14k7JwV.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p><strong>指派问题的最优解有这样一个性质，若从矩阵的一行(列)各元素中分别减去该行(列)的最小元素，得到归约矩阵，其最优解和原矩阵的最优解相同</strong></p>
</blockquote>
<blockquote>
<p><strong>匈牙利法：</strong><br><img src="https://i.loli.net/2020/02/03/hWeQFEwxgnAORzX.png" alt="image.png"></p>
</blockquote>
<h3 id="抽屉"><a href="#抽屉" class="headerlink" title="抽屉"></a>抽屉</h3><h3 id="旅行社TSP"><a href="#旅行社TSP" class="headerlink" title="旅行社TSP"></a>旅行社TSP</h3><blockquote>
<p>Travelling Salesman Problem (TSP) 是最基本的路线问题。它寻求的是旅行者由起点出发，通过所有给定的需求点后，再次返回起点所花费的最小路径成本<br>整理模拟退火算法的程序！<br><strong><a href="http://blog.csdn.net/zhangzhengyi03539/article/details/46673545" target="_blank" rel="noopener">http://blog.csdn.net/zhangzhengyi03539/article/details/46673545</a><br><a href="https://www.cnblogs.com/ranjiewen/p/6815333.html" target="_blank" rel="noopener">https://www.cnblogs.com/ranjiewen/p/6815333.html</a></strong></p>
</blockquote>
<h3 id="CPP"><a href="#CPP" class="headerlink" title="CPP"></a>CPP</h3><blockquote>
<p>中国邮路问题，就是派邮递员送信，最后返回邮局，要求必须经过负责投递的街道至少一次，并且途径距离最短，属于图论里的euler回路<br><strong>介绍：<a href="https://blog.csdn.net/gxuan/article/details/7869119" target="_blank" rel="noopener">https://blog.csdn.net/gxuan/article/details/7869119</a><br>编程实现：<a href="https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html" target="_blank" rel="noopener">https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html</a></strong></p>
</blockquote>
<h3 id="产销"><a href="#产销" class="headerlink" title="产销"></a>产销</h3><blockquote>
<p>解决如何实现成本最小，利润最大的问题，问题的核心为如何求成本函数最小值的问题。<br><strong><a href="https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html" target="_blank" rel="noopener">https://www.cnblogs.com/guocai/archive/2012/07/08/2581979.html</a></strong></p>
</blockquote>
<h3 id="运输"><a href="#运输" class="headerlink" title="运输"></a>运输</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/MlcEqYBx6ny3kUK.png" alt="image.png"><br><em>四要素：</em> <strong>生产地，销售地，运输物资，运输价格</strong><br><strong><a href="https://zhuanlan.zhihu.com/p/33299659" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33299659</a></strong></p>
</blockquote>
<h3 id="排队论"><a href="#排队论" class="headerlink" title="排队论"></a>排队论</h3><blockquote>
<p>排队系统由三部分组成：<br><strong>(1)顾客输入过程</strong><br><strong>(2)排队结构与排队规则</strong><br><strong>(3)服务机构与服务规则</strong><br><img src="https://i.loli.net/2020/02/03/r6WleBKoTV4cSta.png" alt="7"><br>一般研究的问题为总体为无限的，到达方式逐个，到达间隔随机，顾客之间相互独立，输入过程平稳。<br><img src="https://i.loli.net/2020/02/03/4zCUAPQHEgwFdaV.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/UF7ujBXEA4ZR9yH.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2020/02/03/K2E7bxswA8mhCDc.png" alt="image.png"><br><strong><a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270875.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270875.html</a></strong></p>
</blockquote>
<h1 id="预测模型"><a href="#预测模型" class="headerlink" title="预测模型"></a>预测模型</h1><h2 id="预测模型-1-微分方程预测"><a href="#预测模型-1-微分方程预测" class="headerlink" title="预测模型(1)微分方程预测"></a>预测模型(1)微分方程预测</h2><blockquote>
<p><a href="https://wenku.baidu.com/view/2e0a184a16fc700abb68fc7c.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/2e0a184a16fc700abb68fc7c.html</a></p>
</blockquote>
<h3 id="单种群"><a href="#单种群" class="headerlink" title="单种群"></a>单种群</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/KAxoXkQFC6sv7g5.png" alt="image.png"></p>
</blockquote>
<h3 id="多种群增长"><a href="#多种群增长" class="headerlink" title="多种群增长"></a>多种群增长</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/VzoeUjYAB5s6G41.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/4XY9DRtmj3Blgre.png" alt="image.png"></p>
</blockquote>
<h3 id="Logistic阻滞增长"><a href="#Logistic阻滞增长" class="headerlink" title="Logistic阻滞增长"></a>Logistic阻滞增长</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/GWXCzd8Ue9nKurm.png" alt="image.png"><br><strong><a href="https://blog.csdn.net/mrguanlingyu/article/details/7976607" target="_blank" rel="noopener">https://blog.csdn.net/mrguanlingyu/article/details/7976607</a></strong></p>
</blockquote>
<blockquote>
<p><img src="https://i.loli.net/2020/02/03/fqDx69TcVwPe35U.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/B1OwxPuFb7HNYXc.png" alt="image.png"><br>指数模型人口预测程序：<br><img src="https://i.loli.net/2020/02/03/WzCBA6ThL7qoPMX.png" alt="image.png"><br>logistic阻滞型人口模型代码：<br><img src="https://i.loli.net/2020/02/03/EuC8jnDwX24JrPp.png" alt="image.png"><br><strong>主要为nlinfit函数的使用</strong></p>
</blockquote>
<h3 id="时滞模型"><a href="#时滞模型" class="headerlink" title="时滞模型"></a>时滞模型</h3><blockquote>
<p>考虑到种群密度对种群增长的时滞作用而改进的一个种群连续增长模型。</p>
</blockquote>
<h2 id="预测模型-2-微分方程预测"><a href="#预测模型-2-微分方程预测" class="headerlink" title="预测模型(2)微分方程预测"></a>预测模型(2)微分方程预测</h2><h3 id="房室模型"><a href="#房室模型" class="headerlink" title="房室模型"></a>房室模型</h3><blockquote>
<p><a href="https://wenku.baidu.com/view/231eab44b307e87101f69645.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/231eab44b307e87101f69645.html</a></p>
</blockquote>
<h3 id="差分方差模型"><a href="#差分方差模型" class="headerlink" title="差分方差模型"></a>差分方差模型</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/tb9lHuMQKn7xAhy.png" alt="image.png"><br><strong><a href="https://www.cnblogs.com/TaigaCon/p/6878674.html" target="_blank" rel="noopener">https://www.cnblogs.com/TaigaCon/p/6878674.html</a></strong></p>
</blockquote>
<h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><blockquote>
<p>解析解(analytical solution)就是一些严格的公式,给出任意的自变量就可以求出其因变量,也就是问题的解, 他人可以利用这些公式计算各自的问题.  </p>
</blockquote>
<h3 id="数值解"><a href="#数值解" class="headerlink" title="数值解"></a>数值解</h3><blockquote>
<p>解析解(analytical solution)就是一些严格的公式,给出任意的自变量就可以求出其因变量,也就是问题的解, 他人可以利用这些公式计算各自的问题.  </p>
</blockquote>
<h3 id="参数确定"><a href="#参数确定" class="headerlink" title="参数确定"></a>参数确定</h3><h2 id="预测模型-3"><a href="#预测模型-3" class="headerlink" title="预测模型(3)"></a>预测模型(3)</h2><h3 id="线性-1"><a href="#线性-1" class="headerlink" title="线性"></a>线性</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/BtPiv147VgqfpZK.png" alt="image.png"><br><strong><a href="https://otexts.com/fppcn/regression-intro.html" target="_blank" rel="noopener">https://otexts.com/fppcn/regression-intro.html</a></strong></p>
</blockquote>
<h3 id="非线性回归与拟合"><a href="#非线性回归与拟合" class="headerlink" title="非线性回归与拟合"></a>非线性回归与拟合</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/5sDUoVdkzvMcNnw.png" alt="image.png"><br><strong><a href="https://zhuanlan.zhihu.com/p/32325298" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32325298</a></strong></p>
</blockquote>
<p><strong>逻辑回归</strong><br><img src="https://i.loli.net/2020/02/03/94McTKJ7N5gDpaF.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/kKFmwp79qXNgCtW.png" alt="image.png"></p>
<h3 id="统计回归预测"><a href="#统计回归预测" class="headerlink" title="统计回归预测"></a>统计回归预测</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/QHGD2U6Wpjtb5mI.png" alt="image.png"><br><strong><a href="https://otexts.com/fppcn/forecasting-regression.html" target="_blank" rel="noopener">https://otexts.com/fppcn/forecasting-regression.html</a><br><a href="https://blog.csdn.net/Android_xue/article/details/97614045" target="_blank" rel="noopener">https://blog.csdn.net/Android_xue/article/details/97614045</a></strong></p>
</blockquote>
<h3 id="参数确定-1"><a href="#参数确定-1" class="headerlink" title="参数确定"></a>参数确定</h3><h2 id="预测模型-4"><a href="#预测模型-4" class="headerlink" title="预测模型(4)"></a>预测模型(4)</h2><h3 id="Markov链预测"><a href="#Markov链预测" class="headerlink" title="Markov链预测"></a>Markov链预测</h3><blockquote>
<p><strong>1.状态</strong>  在马尔可夫预测中，“状态”是一个重要的术语。所谓状态，就是指某一事件在某个时刻（或时期)出现的某种结果。一般而言，随着所研究的事件及其预测的目标不同，状态可以有不同的划分方式。譬如，在商品销售预测中，有“畅销”、“一般”、“滞销”等状态；在农业收成预测中，有“丰收”、“平收”、“欠收”等状态；在人口构成预测中，有“婴儿”、“儿童”、“少年”、“青年”、“中年”、“老年”等状态；等等。<br><strong>2.状态转移过程</strong>  在事件的发展过程中，从一种状态转变为另一种状态，就称为状态转移。事件的发展，随着时间的变化而变化所作的状态转移，或者说状态转移与时间的关系，就称为状态转移过程，简称过程。<br><img src="https://i.loli.net/2020/02/03/cpMKNXrnLdsvh1I.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/p6rTQwKsfRkEPtO.png" alt="image.png"><br><strong><a href="https://blog.csdn.net/qq_41686130/article/details/81906527" target="_blank" rel="noopener">https://blog.csdn.net/qq_41686130/article/details/81906527</a><br><a href="https://blog.csdn.net/bitcarmanlee/article/details/82819860" target="_blank" rel="noopener">https://blog.csdn.net/bitcarmanlee/article/details/82819860</a></strong></p>
</blockquote>
<h3 id="神经网络预测"><a href="#神经网络预测" class="headerlink" title="神经网络预测"></a>神经网络预测</h3><blockquote>
<p><img src="https://i.loli.net/2020/02/03/HzjDa4dU3FyQESt.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/O5hTurW7HfLawyz.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/HnYr2uSxUCVblRN.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/jug7q39TyOEl5Uv.png" alt="image.png"><br><strong><a href="https://otexts.com/fppcn/nnetar.html" target="_blank" rel="noopener">https://otexts.com/fppcn/nnetar.html</a><br><a href="https://blog.csdn.net/asd20172016/article/details/81454009" target="_blank" rel="noopener">https://blog.csdn.net/asd20172016/article/details/81454009</a><br><a href="https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270391.html" target="_blank" rel="noopener">https://www.cnblogs.com/BlueMountain-HaggenDazs/p/4270391.html</a></strong></p>
</blockquote>
<h2 id="预测模型-5"><a href="#预测模型-5" class="headerlink" title="预测模型(5)"></a>预测模型(5)</h2><h3 id="模糊预测"><a href="#模糊预测" class="headerlink" title="模糊预测"></a>模糊预测</h3><h3 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h3><blockquote>
<p>灰色系统介于白色和黑色之间，灰色系统内的一部分信息是已知的，另一部分信息是未知的，系统内各因素间有不确定的关系。<br>灰色预测通过鉴别系统因素之间发展趋势的相异程度，即进行关联分析，并对原始数据进行生成处理来寻找系统变动的规律，生成有较强规律性的数据序列，然后建立相应的微分方程模型，从而预测事物未来发展趋势的状况。<br><strong>数据生成：累加生成、累减生成、加权累加生成<br>灰色模型GM(1,1)</strong><br><strong><a href="https://blog.csdn.net/qq547276542/article/details/77865341" target="_blank" rel="noopener">https://blog.csdn.net/qq547276542/article/details/77865341</a></strong></p>
</blockquote>
<h3 id="参数确定-2"><a href="#参数确定-2" class="headerlink" title="参数确定"></a>参数确定</h3><h1 id="分类模型"><a href="#分类模型" class="headerlink" title="分类模型"></a>分类模型</h1><h2 id="分类模型-1"><a href="#分类模型-1" class="headerlink" title="分类模型(1)"></a>分类模型(1)</h2><p><strong><a href="https://blog.csdn.net/sinat_26917383/article/details/51611519" target="_blank" rel="noopener">https://blog.csdn.net/sinat_26917383/article/details/51611519</a></strong></p>
<h3 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h3><blockquote>
<p><strong>三类比较常见的聚类模型，K-mean聚类、层次（系统）聚类、最大期望EM算法</strong><br><em>聚类分析的目的就是让类群内观测的距离最近，同时不同群体之间的距离最大。</em></p>
</blockquote>
<p><strong>K-mean聚类</strong></p>
<blockquote>
<p><img src="https://i.loli.net/2020/02/03/KYwmGE1IiACNlty.png" alt="image.png"></p>
</blockquote>
<p><strong>层次（系统）聚类</strong></p>
<blockquote>
<p>层次聚类也称系统聚类法，是根据个体间距离将个体向上两两聚合，再将聚合的小群体两两聚合一直到聚为一个整体。计算所有个体之间的距离，最相近距离的个体合体，不断合体。<br><img src="https://i.loli.net/2020/02/03/V9K8yAF5ovqpfYu.png" alt="image.png"></p>
</blockquote>
<p><strong>最大期望EM算法</strong></p>
<blockquote>
<p>最大期望（EM）算法是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐藏变量（Latent Variable）。</p>
</blockquote>
<p><img src="https://i.loli.net/2020/02/03/NSJts5pRYHabmuI.png" alt="image.png"></p>
<h3 id="模糊聚类-FCM"><a href="#模糊聚类-FCM" class="headerlink" title="模糊聚类(FCM)"></a>模糊聚类(FCM)</h3><p><strong><a href="https://blog.csdn.net/WWWQ2386466490/article/details/80349239" target="_blank" rel="noopener">https://blog.csdn.net/WWWQ2386466490/article/details/80349239</a></strong><br><strong>隶属度</strong></p>
<blockquote>
<p>隶属度函数是表示一个对象x 隶属于集合A 的程度的函数，通常记做μA(x)，其自变量范围是所有可能属于集合A 的对象（即集合A 所在空间中的所有点），取值范围是[0,1]，即0&lt;=μA(x)，μA(x)&lt;=1。μA(x)=1 表示x 完全隶属于集合A，相当于传统集合概念上的x∈A。</p>
</blockquote>
<p><strong>模糊集合</strong></p>
<blockquote>
<p>个定义在空间X={x}上的隶属度函数就定义了一个模糊集合A，或者叫定义在论域X={x}上的模糊子集A’。对于有限个对象x1，x2，……，xn 模糊集合A’可以表示为：<br><img src="https://i.loli.net/2020/02/03/FIMcE7QACyBJi8V.png" alt="image.png"></p>
</blockquote>
<p><strong>FCM聚类算法</strong></p>
<blockquote>
<p><img src="https://i.loli.net/2020/02/03/ULvH9CngXNY2SfQ.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/r2xmuBJeasM6NVH.png" alt="image.png"></p>
</blockquote>
<h3 id="距离函数选取"><a href="#距离函数选取" class="headerlink" title="距离函数选取"></a>距离函数选取</h3><p><img src="https://i.loli.net/2020/02/03/t5v4yEAY6UeLSPj.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/h4aLlNPW1IiD6nT.png" alt="image.png"></p>
<h3 id="线性非线性分类器选取"><a href="#线性非线性分类器选取" class="headerlink" title="线性非线性分类器选取"></a>线性非线性分类器选取</h3><p><img src="https://i.loli.net/2020/02/03/94XMJRnPa8bYE3e.png" alt="image.png"><br>左边：非线性分类器<br>右边：线性分类器（又名：一刀切）<br><strong>分类器</strong><br>可以把输入数据分类的“东西”<br><strong><a href="https://www.zhihu.com/question/30633734/answer/463900106" target="_blank" rel="noopener">https://www.zhihu.com/question/30633734/answer/463900106</a></strong></p>
<h2 id="分类模型-2"><a href="#分类模型-2" class="headerlink" title="分类模型(2)"></a>分类模型(2)</h2><h3 id="神经网络分类"><a href="#神经网络分类" class="headerlink" title="神经网络分类"></a>神经网络分类</h3><p><img src="https://i.loli.net/2020/02/03/i9XoDwdpzhObqcH.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/03/xiKTcGe6zON7d8L.png" alt="image.png"><br><strong><a href="https://blog.csdn.net/HerosOfEarth/article/details/52165133" target="_blank" rel="noopener">https://blog.csdn.net/HerosOfEarth/article/details/52165133</a></strong></p>
<h3 id="网络构造"><a href="#网络构造" class="headerlink" title="网络构造"></a>网络构造</h3><blockquote>
<p>A、输入量的选择：<br>a、输入量必须选择那些对输出影响大且能够检测或提取的变量；<br>b、各输入量之间互不相关或相关性很小。从输入、输出量性质分类来看，可以分为两类：数值变量和语言变量。数值变量又分为连续变量或离散变量。如常见的温度，压力，电压，电流等就是连续变量；语言变量是用自然语言表示的概念。如红，绿，蓝；男，女；大，中，小，开，关，亮，暗等。一般来说，语言变量在网络处理时，需要转化为离散变量。<br>c、输入量的表示与提取：多数情况下，直接送给神经网络的输入量无法直接得到，常常需要用信号处理与特征提取技术从原始数据中提取能反映其特征的若干参数作为网络输入。<br>B、输出量选择与表示：<br>a、输出量一般代表系统要实现的功能目标，如分类问题的类别归属等；<br>b、输出量表示可以是数值也可是语言变量；<br><strong><a href="https://blog.csdn.net/m0_37102093/article/details/78030711" target="_blank" rel="noopener">https://blog.csdn.net/m0_37102093/article/details/78030711</a></strong></p>
</blockquote>
<h3 id="初始权值选取"><a href="#初始权值选取" class="headerlink" title="初始权值选取"></a>初始权值选取</h3><blockquote>
<p>网络权值的初始化决定了网络的训练从误差曲面的哪一点开始，因此初始化方法对缩短网络的训练时间至关重要。<br>神经元的作用函数是关于坐标点对称的，若每个节点的净输入均在零点附近，则输出均出在作用函数的中点，这个位置不仅远离作用函数的饱和区，而且是其变化最灵敏的区域，必使网络学习加快。从神经网络净输入表达式来看，为了使各节点的初始净输入在零点附近，如下两种方法被常常使用：<br>A、取足够小的初始权值；<br>B、使初始值为+1和-1的权值数相等。</p>
</blockquote>
<h1 id="评价模型"><a href="#评价模型" class="headerlink" title="评价模型"></a>评价模型</h1><h2 id="评价模型-1"><a href="#评价模型-1" class="headerlink" title="评价模型(1)"></a>评价模型(1)</h2><h3 id="模糊分析"><a href="#模糊分析" class="headerlink" title="模糊分析"></a>模糊分析</h3><blockquote>
<p><strong>1.建立综合评价的因素集</strong><br><img src="https://i.loli.net/2020/02/04/iWFAPeQa3kc96Kt.png" alt="image.png"><br><strong>2.建立综合评价的评价集</strong><br><img src="https://i.loli.net/2020/02/04/Ar3expYbJXVCj7L.png" alt="image.png"><br><strong>3.进行单元素模糊评价，获得评价矩阵</strong><br><img src="https://i.loli.net/2020/02/04/pH26unJlESLYKZ9.png" alt="image.png"><br><strong>4.确定因素权向量</strong><br><img src="https://i.loli.net/2020/02/04/WN4a9Knukd5oh1H.png" alt="image.png"><br><strong>5.建立综合评价模型</strong><br><img src="https://i.loli.net/2020/02/04/OIoYlxQjsV1greF.png" alt="image.png"><br><img src="https://i.loli.net/2020/02/04/njQg5yq93vuCXYN.png" alt="image.png"><br><strong>6.确定系统总得分</strong><br><img src="https://i.loli.net/2020/02/04/dLfOj9tx2JHqBP5.png" alt="image.png"><br><strong><a href="https://zhuanlan.zhihu.com/p/32666445" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32666445</a></strong></p>
</blockquote>
<h3 id="隶属度函数选取与构造"><a href="#隶属度函数选取与构造" class="headerlink" title="隶属度函数选取与构造"></a>隶属度函数选取与构造</h3><blockquote>
<p>常用的方法：<strong>直觉方法，二元对比排序法，模糊统计试验法，最小模糊度法</strong>（根据先验知识和采集的数据，确定出描述模糊概念的候选隶属函数，利用最小化模糊度的原则计算相关的参数，进而获得合适的隶属函数）。<br>下面介绍三种最常用的隶属度函数：<strong>三角形隶属度函数、梯形隶属度函数、高斯型隶属度函数：</strong><br><strong>三角形隶属度函数</strong><br><img src="https://i.loli.net/2020/02/04/GUTEVZDzRcYHXv3.png" alt="image.png"><br><strong>梯形隶属度函数</strong><br><img src="https://i.loli.net/2020/02/04/TmEJY6WvuNxO23t.png" alt="image.png"><br><strong>高斯型隶属度函数</strong><br><img src="https://i.loli.net/2020/02/04/uqkzCd7jrvbMpmw.png" alt="image.png"><br><strong><a href="https://zhuanlan.zhihu.com/p/37616833" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/37616833</a></strong></p>
</blockquote>
<h2 id="评价模型-2"><a href="#评价模型-2" class="headerlink" title="评价模型(2)"></a>评价模型(2)</h2><h3 id="层次分析法评价-AHP"><a href="#层次分析法评价-AHP" class="headerlink" title="层次分析法评价(AHP)"></a>层次分析法评价(AHP)</h3><blockquote>
<p><strong>对难以完全定量得复杂系统做出决策，主要用来求权重</strong><br><img src="https://i.loli.net/2020/02/04/wJ1NAbS9aigzop8.png" alt="image.png"><br><strong>第一步，建立从目标层到准则层(指标层)再到决策层(方案层)</strong><br>1）最高层（目标层）——只有一个元素：决策目标；<br>2）中间层（准则层）——考虑的因素，决策的准则、子准则；<br>3）最底层（方案层）——决策时的备选方案、措施。<br><img src="https://i.loli.net/2020/02/04/pJHBimPk5DGd1rF.png" alt="image.png"><br><strong>第二步，(最重要的一步)构造成对比较矩阵</strong><br><img src="https://i.loli.net/2020/02/04/syupZ7jMd6L2e91.png" alt="image.png"><br>A矩阵代表准则层各个指标之间的相互关系，B矩阵代表各个待选方案分别在5个指标中的相互比较关系。<br>(即若n个指标，m个决策方案，则B为(n,n)矩阵，有m个)<br><strong><a href="https://zhuanlan.zhihu.com/p/35051786" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/35051786</a></strong></p>
</blockquote>
<h3 id="打分与权重确定"><a href="#打分与权重确定" class="headerlink" title="打分与权重确定"></a>打分与权重确定</h3><h2 id="评价模型-3"><a href="#评价模型-3" class="headerlink" title="评价模型(3)"></a>评价模型(3)</h2><h3 id="主成分分析-Principal-components-analysis-PCA"><a href="#主成分分析-Principal-components-analysis-PCA" class="headerlink" title="主成分分析(Principal components analysis,PCA)"></a>主成分分析(Principal components analysis,PCA)</h3><p>找出数据里最主要的方面，用数据里最主要的方面来代替原始数据。</p>
<ol>
<li>最近重构性：样本点到这个超平面的距离足够近</li>
<li>最大可分性：样本点在这个超平面上的投影能尽可能的分开<br><img src="https://i.loli.net/2020/02/04/tR4zIEkOQeBnDKC.png" alt="image.png"><br>PCA算法的主要优点有：<br>仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　<br>各主成分之间正交，可消除原始数据成分间的相互影响的因素。<br>计算方法简单，主要运算是特征值分解，易于实现。<br>PCA算法的主要缺点有：<br>主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。<br>方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</li>
</ol>
<p><strong><a href="https://zhuanlan.zhihu.com/p/32412043" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/32412043</a></strong></p>
<h3 id="主成分回归评价-principle-component-regression；PCR"><a href="#主成分回归评价-principle-component-regression；PCR" class="headerlink" title="主成分回归评价(principle component regression；PCR)"></a>主成分回归评价(principle component regression；PCR)</h3><blockquote>
<p>主成份回归可以解决变量间共线性的问题。它使用从数据抽提出的主成份进行回归，一般来说是选择前面的几个主成份。下面给出一个例子，训练集中的自变量数据X和因变量y，以及测试集中的数据Xnew和因变量Ynew，结果给出训练集中的回归模型得到的预测值和实际值的相关系数，以及测试集中相应的相关系数。<br><strong><a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=54276&amp;do=blog&amp;id=375339" target="_blank" rel="noopener">http://blog.sciencenet.cn/home.php?mod=space&amp;uid=54276&amp;do=blog&amp;id=375339</a></strong></p>
</blockquote>
<h3 id="主成分解释"><a href="#主成分解释" class="headerlink" title="主成分解释"></a>主成分解释</h3><blockquote>
<p>主成分分析（PCA）是一种降维方法，通常用于通过将数量很多的变量转换为仍包含集合中大部分信息的较少变量来降低数据集的维数。<br>减少数据集的变量数量自然是以牺牲精度为代价的，但降维是为了简单而略微准确。因为较小的数据集更易于探索和可视化，并且使机器学习算法更容易和更快地分析数据，而无需处理无关的变量。<br>总而言之，PCA的概念很简单：减少数据集的维数，同时保留尽可能多的信息。<br><strong><a href="https://zhuanlan.zhihu.com/p/58663947" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58663947</a></strong></p>
</blockquote>
<h3 id="数据包络分析-Data-Envelopment-Analysis-DEA"><a href="#数据包络分析-Data-Envelopment-Analysis-DEA" class="headerlink" title="数据包络分析(Data Envelopment Analysis,DEA)"></a>数据包络分析(Data Envelopment Analysis,DEA)</h3><blockquote>
<p>它是根据多项投入指标和多项产出指标，利用线性规划的方法，对具有可比性的同类型单位进行相对有效性评价的一种数量分析方法。</p>
</blockquote>
<p>1) 定义变量<br>设Ek（k=1，2，……， K）为第k个单位的效率比率，这里K代表评估单位的总数。<br>设uj（j=1，2，……， M）为第j种产出的系数，这里M代表所考虑的产出种类的总数。变量uj用来衡量产出价值降低一个单位所带来的相对的效率下降。<br>设vI（I=1，2，……，N）为第I种投入的系数，这里N代表所考虑的投入种类的综合素。变量vI用来衡量投入价值降低一个单位带来的相对的效率下降。<br>设Ojk为一定时期内由第k个服务单位所创造的第j种产出的观察到的单位的数量。<br>设Iik为一定时期内由第k个服务单位所使用的第i种投入的实际的单位的数量。<br>2) 目标函数<br>　　目标是找出一组伴随每种产出的系数u和一组伴随每种投入的系数ν，从而给被评估的服务单位最高的可能效率。<br><img src="https://i.loli.net/2020/02/04/tlK5C3Sfb1BPpHF.png" alt="image.png"><br>式中，e是被评估单位的代码。 这个函数满足这样一个约束条件，当同一组投入和产出的系数（uj和vi）用于所有其他对比服务单位时，没有一个服务单位将超过100%的效率或超过1.0的比率。<br>3) 约束条件<br><img src="https://i.loli.net/2020/02/04/GncTOyBzp1a9IXS.png" alt="image.png"><br>k=1,2,……,K<br>式中所有系数值都是正的且非零。<br>为了用标准线性规划软件求解这个有分数的线性规划，需要进行变形。要注意，目标函数和所有约束条件都是比率而不是线性函数。通过把所评估单位的投入人为地调整为总和1.0，这样等式的目标函数可以重新表述为：<br><img src="https://i.loli.net/2020/02/04/Qu71vcEz8mYPlgB.png" alt="image.png"><br>　　满足以下约束条件：<br><img src="https://i.loli.net/2020/02/04/28EWzgrPiL7TuIj.png" alt="image.png"><br>　　对于个服务单位，等式（**）的约束条件可类似转化为：<br><img src="https://i.loli.net/2020/02/04/JVjoiPvfyt5XaO3.png" alt="image.png"><br>　　k=1,2,…,K<br>　　式中 uj≥0 j=1，2，…，M vi≥0 i=1，2，…，N<br>　　关于服务单位的样本数量问题是由在分析种比较所挑选的投入和产出变量的数量所决定的。下列关系式把分析中所使用的服务单位数量K和所考虑的投入种类数N与产出种类数M联系出来，它是基于实证发现和DEA实践的经验：<br><img src="https://i.loli.net/2020/02/04/87J914AgkoSaNQT.png" alt="image.png"><br><a href="https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90" target="_blank" rel="noopener">https://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%BB%9C%E5%88%86%E6%9E%90</a></p>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>建模算法</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛写作套路</title>
    <url>/%E7%BE%8E%E8%B5%9B%E5%86%99%E4%BD%9C%E5%A5%97%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="美赛写作套路"><a href="#美赛写作套路" class="headerlink" title="美赛写作套路"></a>美赛写作套路</h1><h2 id="Word还是LaTex"><a href="#Word还是LaTex" class="headerlink" title="Word还是LaTex"></a>Word还是LaTex</h2><blockquote>
<p>倾向于使用Word进行写作，有利于论文的最后的协同合作<br>LaTex最新模板地址:<a href="https://github.com/latexstudio-org/mcmthesis/releases/tag/6.3" target="_blank" rel="noopener">https://github.com/latexstudio-org/mcmthesis/releases/tag/6.3</a></p>
</blockquote>
<h2 id="美赛论文怎么翻译"><a href="#美赛论文怎么翻译" class="headerlink" title="美赛论文怎么翻译"></a>美赛论文怎么翻译</h2><blockquote>
<p>谷歌翻译:<a href="https://translate.google.cn/" target="_blank" rel="noopener">https://translate.google.cn/</a><br><strong>有以下几点要注意：</strong><br>（1） 翻译完成后再排版，记住，排版永远放在最后一步；<br>（2）第一次翻译完成后一定要再次核对语法、通顺程度、专有名词等，初次翻译出来的结果是不能看的，后面我再教给大家怎么修改；<br>（3）中文版用word写，后续翻译完成并修改后再用latex模板套用，因为latex导出来的就直接是pdf版本了，谷歌翻译对word的识别要远好于pdf。</p>
</blockquote>
<a id="more"></a>
<h2 id="语法和拼写错误检测"><a href="#语法和拼写错误检测" class="headerlink" title="语法和拼写错误检测"></a>语法和拼写错误检测</h2><h2 id="专有名词翻译"><a href="#专有名词翻译" class="headerlink" title="专有名词翻译"></a>专有名词翻译</h2><blockquote>
<p><strong>CNKI翻译助手：</strong><a href="http://dict.cnki.net/" target="_blank" rel="noopener">http://dict.cnki.net/</a></p>
</blockquote>
<h2 id="模型介绍的翻译"><a href="#模型介绍的翻译" class="headerlink" title="模型介绍的翻译"></a>模型介绍的翻译</h2><h3 id="20个常用模型的美赛论文解读"><a href="#20个常用模型的美赛论文解读" class="headerlink" title="20个常用模型的美赛论文解读"></a>20个常用模型的美赛论文解读</h3><h3 id="应对查重的小技巧"><a href="#应对查重的小技巧" class="headerlink" title="应对查重的小技巧"></a>应对查重的小技巧</h3><h4 id="代码查重问题"><a href="#代码查重问题" class="headerlink" title="代码查重问题"></a>代码查重问题</h4><p>1.添加注释<br>2.改变变量名</p>
<h4 id="文章查重问题"><a href="#文章查重问题" class="headerlink" title="文章查重问题"></a>文章查重问题</h4><p>1.模型介绍、优缺点等尽量自己写<br>2.可以使用流程图来介绍算法</p>
<h2 id="Word公式编辑和LaTeX公式语法"><a href="#Word公式编辑和LaTeX公式语法" class="headerlink" title="Word公式编辑和LaTeX公式语法"></a>Word公式编辑和LaTeX公式语法</h2><blockquote>
<p><strong>Axmath</strong>进行公式排版，同时也支持转换为LaTeX代码</p>
</blockquote>
<h2 id="美赛数据下载网站"><a href="#美赛数据下载网站" class="headerlink" title="美赛数据下载网站"></a>美赛数据下载网站</h2><p>1.data.gov( <a href="https://www.data.gov/" target="_blank" rel="noopener">https://www.data.gov/</a> )<br>2.Googledatasets<br>( <a href="https://cloud.google.com/bigquery/public‐data/" target="_blank" rel="noopener">https://cloud.google.com/bigquery/public‐data/</a> )<br>3.WorldBank( <a href="http://data.worldbank.org/" target="_blank" rel="noopener">http://data.worldbank.org/</a> ) </p>
<h2 id="统计图表的绘制"><a href="#统计图表的绘制" class="headerlink" title="统计图表的绘制"></a>统计图表的绘制</h2><h3 id="使用Excel绘制统计图的视频"><a href="#使用Excel绘制统计图的视频" class="headerlink" title="使用Excel绘制统计图的视频"></a>使用Excel绘制统计图的视频</h3><blockquote>
<p>数学建模：用EXCEL绘制统计图第1部分——饼图  <a href="https://www.bilibili.com/video/av78475931" target="_blank" rel="noopener">https://www.bilibili.com/video/av78475931</a><br>数学建模：用EXCEL绘制统计图第2部分——柱状图和条形图  <a href="https://www.bilibili.com/video/av78476106" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476106</a><br>数学建模：用EXCEL绘制统计图第3部分——直方图  <a href="https://www.bilibili.com/video/av78476359" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476359</a><br>数学建模：用EXCEL绘制统计图第4部分——折线图  <a href="https://www.bilibili.com/video/av78476554" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476554</a><br>数学建模：用EXCEL绘制统计图第5部分——散点图  <a href="https://www.bilibili.com/video/av78442212" target="_blank" rel="noopener">https://www.bilibili.com/video/av78442212</a><br>数学建模：用EXCEL绘制统计图第6部分——箱线图 <a href="https://www.bilibili.com/video/av78476715" target="_blank" rel="noopener">https://www.bilibili.com/video/av78476715</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>美赛论文句式</title>
    <url>/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E5%8F%A5%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="开头句型写法"><a href="#开头句型写法" class="headerlink" title="开头句型写法"></a>开头句型写法</h2><blockquote>
<p>Mention polygamy in Canada and waht might come to mind is Bountiful ,a suitably named town in British Columbia .</p>
</blockquote>
<p><strong>Mention…and what comes to mind is …</strong><br>提及……时我们第一个想到的是……<br>当我们要介绍某个地方、人物或者作品时，就可以用上该句型<br>Mention A and what comes to mind is B<br>A 一般是与事物有关的品质或者特点 B是事物本身<br>eg:<br>Mention  innovative thinking and what comes to mind is Steve Jobs ,a man who was ahead of his time and who reshaped the IT industry .</p>
<a id="more"></a>
<h2 id="积累转折句型"><a href="#积累转折句型" class="headerlink" title="积累转折句型"></a>积累转折句型</h2><blockquote>
<p>For all the talk of a global market for talent ,chief executives in Britain still earn considerably less than their counterparts in the United States .</p>
</blockquote>
<p><strong>For all the talk of … still …</strong><br>尽管关于……有很多的讨论，……仍然……<br>eg:<br>For all the talk of equal rights For women ,gender discrimination is still rife in the workplace .</p>
<h2 id="表达背道而驰"><a href="#表达背道而驰" class="headerlink" title="表达背道而驰"></a>表达背道而驰</h2><blockquote>
<p>Mr Trump certainly has the poewr to wreak trade havoc .A big blanket tariff would slice through supply chains ,hurt American consumers and fly in the face of the global system of trade rules overseen by the World Trade Organization (WTO).</p>
</blockquote>
<p><strong>fly in the face of something</strong><br>与(人们认为合理或正常的事情)背道而驰，这种事情可以指法律法规，也可以指传统、常识、逻辑等。<br>eg:<br>Staying up late flies in the face of healthy living .</p>
<h2 id="表达带来严重后果"><a href="#表达带来严重后果" class="headerlink" title="表达带来严重后果"></a>表达带来严重后果</h2><blockquote>
<p>Commentators recently said that Clean Reader,the app that bowdlerises ebooks ,puts us on a slippery slope towards total literary censorship .</p>
</blockquote>
<p><strong>a slippery slope</strong><br>(过程或者习惯等)带来严重后果，使人走向极坏的境地<br>eg:<br>Once he had tried that first cigarette ,he was on the slippery slope to being a smoker .</p>
<h2 id="写对比句"><a href="#写对比句" class="headerlink" title="写对比句"></a>写对比句</h2><blockquote>
<p>Despite the mystery, Dr Charcot’s colleagues never thought to question the scientific value of the experiment. The same cannot be said of Mario Beauregard, a brain-imager from the University of Montreal, who has also experimented with mescaline.</p>
</blockquote>
<p><strong>the same cannot be said of…</strong><br>同样的说法/情况并不能用在……身上<br>eg:<br>In big cities it is always easy to find a movie theater, karaoke hall or fitness studio. However, the same cannot be said of remote villages.</p>
]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>英文写作句型</tag>
      </tags>
  </entry>
  <entry>
    <title>日语学习常用句式（一）</title>
    <url>/%E6%97%A5%E8%AF%AD%E5%AD%A6%E4%B9%A0%E5%B8%B8%E7%94%A8%E5%8F%A5%E5%BC%8F%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="常用句式"><a href="#常用句式" class="headerlink" title="常用句式"></a>常用句式</h2><p>Su go ku o I si i<br>すごく　おいしい　<br>超级好吃</p>
<p>Su go ku ta no si i<br>すごく　たのしい<br>超级开心</p>
<p>I ta da ki ma su<br>いただきます<br>我要开动啦</p>
<a id="more"></a>
<p>O I si i<br>おいしい<br>好吃（女生）</p>
<p>U ma i　<br>うまい<br>好吃（男生）</p>
<p>I ma do ko<br>いま、どこ？<br>你现在在哪儿？</p>
<p>E ki da<br>えきだ<br>在车站呢</p>
<p>Ge nn ki<br>げんき<br>元気<br>ん拨音<br>身体健康</p>
<p>O ge nn ki de su ka<br>おげんきですか<br>你的身体还健康吗？<br>お：尊敬语<br>A na ka do<br>あなかど<br>你的<br>です：是<br>か：吗</p>
<p>Se nn se i<br>せんせい<br>先生</p>
<p>Yo ro shi ku<br>よろしく<br>请多关照</p>
<p>Sa yo na ra<br>さよなら<br>再见</p>
<h2 id="五十音"><a href="#五十音" class="headerlink" title="五十音"></a>五十音</h2><p>A I u e o<br>あえうえお</p>
<p>Ka ki ku ke ko<br>かきくけこ</p>
<p>Sa shi su se so<br>さしすせそ</p>
<p>Ta chi tsu te to<br>たちつてと</p>
<p>Na ni nu ne no<br>なにぬねの</p>
<p>Ha hi fu he ho<br>はひふへほ</p>
<p>Ma mi mu me mo<br>まみむめも</p>
<p>Ya yu yo<br>やゆよ</p>
<p>Ra ri ru re ro<br>らりるれろ</p>
]]></content>
      <categories>
        <category>日语学习</category>
      </categories>
      <tags>
        <tag>日语常用句式</tag>
        <tag>五十音</tag>
      </tags>
  </entry>
  <entry>
    <title>LaTeX基本操作</title>
    <url>/LaTeX%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="1-LaTeX环境的安装与配置"><a href="#1-LaTeX环境的安装与配置" class="headerlink" title="1.LaTeX环境的安装与配置"></a>1.LaTeX环境的安装与配置</h2><blockquote>
<p>官网自行安装下载</p>
</blockquote>
<h2 id="2-LaTeX源文件的基本结构"><a href="#2-LaTeX源文件的基本结构" class="headerlink" title="2.LaTeX源文件的基本结构"></a>2.LaTeX源文件的基本结构</h2> <figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">%导言区 注释</span><br><span class="line">\documentclass&#123;article&#125;%book, report, letter </span><br><span class="line">\title&#123;My First Document&#125;</span><br><span class="line">\author&#123;Lin Jun&#125;	</span><br><span class="line">\<span class="keyword">date</span>&#123;\today&#125;</span><br><span class="line">%正文区（文稿区）</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle </span><br><span class="line"></span><br><span class="line">Hello World!</span><br><span class="line"></span><br><span class="line">%在源文件增加空行实现分行</span><br><span class="line">Let $f(x)$ be defined by the formula</span><br><span class="line">$f(x)=<span class="number">3</span>x^<span class="number">2</span>+x<span class="number">-1</span>$.</span><br><span class="line">%使用$符号编辑行内数学公式</span><br><span class="line">$$f(x)=<span class="number">3</span>x^<span class="number">2</span>+x<span class="number">-1</span>$$ which is a polynomial of degree <span class="number">2.</span></span><br><span class="line">%使用$$符号编辑行间数学公式</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="3-LaTeX中的中文处理方法"><a href="#3-LaTeX中的中文处理方法" class="headerlink" title="3.LaTeX中的中文处理方法"></a>3.LaTeX中的中文处理方法</h2><h3 id="1-设置构建的默认编译器为XeLaTeX"><a href="#1-设置构建的默认编译器为XeLaTeX" class="headerlink" title="1.设置构建的默认编译器为XeLaTeX"></a>1.设置构建的默认编译器为XeLaTeX</h3><h3 id="2-设置编辑器的编码格式为UTF-8"><a href="#2-设置编辑器的编码格式为UTF-8" class="headerlink" title="2.设置编辑器的编码格式为UTF-8"></a>2.设置编辑器的编码格式为UTF-8</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">%导言区 注释</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span><span class="comment">%book, report, letter </span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span> <span class="comment">%引入中文宏包</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">newcommand</span></span><span class="tag">\<span class="name">degree</span><span class="string">&#123;^\circ&#125;</span></span> <span class="comment">%在导言区进行命令的定义</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">title</span><span class="string">&#123;\heiti 杂谈勾股定理&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">author</span><span class="string">&#123;\kaisu 不二&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">date</span><span class="string">&#123;\today&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">%正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">   <span class="tag">\<span class="name">maketitle</span></span> </span><br><span class="line"></span><br><span class="line">	勾股定理可以用现代语言表述如下:</span><br><span class="line"></span><br><span class="line">	直角三角形斜边的平方等于两腰的平方和。</span><br><span class="line"></span><br><span class="line">	可以用符号语言表述为: 设直角三角形 <span class="formula">$ABC$</span>, 其中 <span class="formula">$<span class="tag">\<span class="name">angle</span></span> C=90<span class="tag">\<span class="name">degree</span></span>$</span>, 则有:</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">	AB^2 = BC^2 + AC^2.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">	<span class="comment">%引入equation环境 相当于$$符号</span></span><br><span class="line">	<span class="comment">%注意angle C 之间需要有空格</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="4-LaTeX的字体设置"><a href="#4-LaTeX的字体设置" class="headerlink" title="4.LaTeX的字体设置"></a>4.LaTeX的字体设置</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">在LaTeX中，一个字体有5中属性:</span><br><span class="line"> 1.字体编码</span><br><span class="line">   正文字体编码: OT1、T1、EU1等</span><br><span class="line">   数字字体编码: OML、OMS、OMX等</span><br><span class="line"> 2.字体族</span><br><span class="line">   罗马字体: 笔画起始处有装饰</span><br><span class="line">   <span class="tag">\<span class="name">textrm</span><span class="string">&#123;Roman Family&#125;</span></span></span><br><span class="line">   <span class="tag">\<span class="name">rmfamily</span></span> Roman Family </span><br><span class="line">   无衬线字体: 笔画起始处无装饰</span><br><span class="line">   <span class="tag">\<span class="name">textsf</span><span class="string">&#123;Sans Serif Family&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">sffamily</span></span> Sans Serif Family&#125;</span><br><span class="line">   打字机字体: 每个字符宽度 </span><br><span class="line">   <span class="tag">\<span class="name">texttt</span><span class="string">&#123;Typewriter Family&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">ttfamily</span></span> Typewriter Family&#125;</span><br><span class="line"> 3.字体系列</span><br><span class="line"> 	粗细</span><br><span class="line"> 	<span class="tag">\<span class="name">textmd</span><span class="string">&#123;Medium Series&#125;</span></span></span><br><span class="line"> 	&#123;<span class="tag">\<span class="name">mdseries</span></span> Medium Series&#125;</span><br><span class="line"> 	宽度</span><br><span class="line"> 	<span class="tag">\<span class="name">textbf</span><span class="string">&#123;Boldface Series&#125;</span></span></span><br><span class="line"> 	&#123;<span class="tag">\<span class="name">bfseries</span></span> Boldface Series&#125;</span><br><span class="line"> 4.字体形状</span><br><span class="line">   直立</span><br><span class="line">   <span class="tag">\<span class="name">textup</span><span class="string">&#123;Upright Shape&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">upshape</span></span> Upright Shape&#125;</span><br><span class="line">   斜体</span><br><span class="line">   <span class="tag">\<span class="name">textit</span><span class="string">&#123;Italic Shape&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">itshape</span></span> Italic Shape&#125;</span><br><span class="line">   伪斜体</span><br><span class="line">   <span class="tag">\<span class="name">textsl</span><span class="string">&#123;Slanted Shape&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">slshape</span></span> Slanted Shape&#125;</span><br><span class="line">   小型大写</span><br><span class="line">   <span class="tag">\<span class="name">textsc</span><span class="string">&#123;Small Caps Shape&#125;</span></span></span><br><span class="line">   &#123;<span class="tag">\<span class="name">scshape</span></span> Small Caps Shape&#125;</span><br><span class="line"> 5.字体大小</span><br><span class="line"> 参看文档</span><br><span class="line"> 6.中文字体</span><br><span class="line"> <span class="comment">%需要使用ctex宏包</span></span><br><span class="line"> &#123;<span class="tag">\<span class="name">songti</span></span> 宋体&#125;</span><br><span class="line"> &#123;<span class="tag">\<span class="name">heiti</span></span> 黑体&#125;</span><br><span class="line"> &#123;<span class="tag">\<span class="name">fangsong</span></span> 仿宋&#125; </span><br><span class="line"> &#123;<span class="tag">\<span class="name">kaisu</span></span> 楷书&#125; 	</span><br><span class="line"> <span class="comment">%\quad表示空格</span></span><br><span class="line"> <span class="comment">%\\表示换行</span></span><br><span class="line"> <span class="comment">%通常定义命令来实现字体操作</span></span><br><span class="line"> <span class="tag">\<span class="name">newcommand</span><span class="string">&#123;\myfont&#125;</span><span class="string">&#123;\textit&#123;\textbf&#123;\textsf&#123;Fancy Text&#125;</span></span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-LaTeX的篇章结构"><a href="#5-LaTeX的篇章结构" class="headerlink" title="5.LaTeX的篇章结构"></a>5.LaTeX的篇章结构</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">   <span class="comment">%导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexbook&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%\usepackage&#123;ctex&#125; </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%在导言区可以使用ctexset进行格式设置</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">%正文区</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">tableofcontents</span></span></span><br><span class="line">  	</span><br><span class="line">  	<span class="tag">\<span class="name">chapter</span><span class="string">&#123;实验与结果分析&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">&#123;引言&#125;</span></span> <span class="comment">%小结 </span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">&#123;实验方法&#125;</span></span>  </span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">&#123;实验结果&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;数据&#125;</span></span> <span class="comment">%子小结</span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;图表&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;实验条件&#125;</span></span> <span class="comment">%子子小结</span></span><br><span class="line">  	<span class="tag">\<span class="name">subsubsection</span><span class="string">&#123;实验过程&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;结果分析&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">&#123;结论&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">section</span><span class="string">&#123;致谢&#125;</span></span></span><br><span class="line">  	</span><br><span class="line">  	<span class="comment">%题干构建 </span></span><br><span class="line">  	<span class="comment">%\par 实现另起段落</span></span><br><span class="line">  </span><br><span class="line">  	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="6-LaTeX中的特殊字符"><a href="#6-LaTeX中的特殊字符" class="headerlink" title="6.LaTeX中的特殊字符"></a>6.LaTeX中的特殊字符</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">  <span class="comment">%导言区</span></span><br><span class="line"> <span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span></span><br><span class="line"> <span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span> <span class="comment">% 中文处理宏包</span></span><br><span class="line"> <span class="tag">\<span class="name">usepackage</span><span class="string">&#123;xltxtra&#125;</span></span> <span class="comment">%提供了针对XeTeX的改进并且加入XeTeX的LOGO</span></span><br><span class="line"> <span class="comment">% 正文区（文稿区）</span></span><br><span class="line"> <span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;空白符号&#125;</span></span></span><br><span class="line"> 	<span class="comment">% 空行分段，多个空行等同1个</span></span><br><span class="line"> 	<span class="comment">% 自动缩进，绝对不能使用空格代替</span></span><br><span class="line"> 	<span class="comment">% 英文中多个空格处理为1个空格，中文中空格将被忽略</span></span><br><span class="line"><span class="comment">% 汉字与其它字符的间距会自动由XeLaTeX处理</span></span><br><span class="line"><span class="comment">% 禁止使用中文全角空格</span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;\LaTeX 控制符&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">#</span></span> <span class="tag">\<span class="name">$</span></span> <span class="tag">\<span class="name">%</span></span> <span class="tag">\<span class="name">&#123;</span></span> <span class="tag">\<span class="name">&#125;</span></span> <span class="tag">\<span class="name">~</span><span class="string">&#123;&#125;</span></span> <span class="tag">\<span class="name">_</span><span class="string">&#123;&#125;</span></span> <span class="tag">\<span class="name">^</span><span class="string">&#123;&#125;</span></span> <span class="tag">\<span class="name">textbackslash</span></span> <span class="tag">\<span class="name">&amp;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;排版符号&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">S</span></span> <span class="tag">\<span class="name">P</span></span> <span class="tag">\<span class="name">dag</span></span> <span class="tag">\<span class="name">ddag</span></span> <span class="tag">\<span class="name">copyright</span></span> <span class="tag">\<span class="name">pounds</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;\TeX 标志符号&#125;</span></span></span><br><span class="line"> 	<span class="comment">%基本符号</span></span><br><span class="line"> 	<span class="tag">\<span class="name">TeX</span><span class="string">&#123;&#125;</span></span> <span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span> <span class="tag">\<span class="name">LaTeXe</span><span class="string">&#123;&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">XeLaTeX</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;引号&#125;</span></span></span><br><span class="line"> 	‘ ’ “ ”</span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;连字符&#125;</span></span></span><br><span class="line"> 	- -- ---</span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;非英文字符&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">oe</span></span> <span class="tag">\<span class="name">OE</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">section</span><span class="string">&#123;重音符号(以o为例)&#125;</span></span></span><br><span class="line"> 	<span class="tag">\<span class="name">`</span></span>o</span><br><span class="line"> <span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="7-LaTeX中的插图"><a href="#7-LaTeX中的插图" class="headerlink" title="7.LaTeX中的插图"></a>7.LaTeX中的插图</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"><span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="comment">% 导言区: \usepackage&#123;graphicx&#125;</span></span><br><span class="line"><span class="comment">% 语  法: \includegraphics[&lt;选项&gt;]&#123;&lt;文件名&gt;&#125;</span></span><br><span class="line"><span class="comment">% 格  式: EPS,PDF,PNG,JPEG,BMP</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span>	</span><br><span class="line"><span class="tag">\<span class="name">graphicspath</span><span class="string">&#123;&#123;figures/&#125;</span></span>&#125;<span class="comment">% 此处需要双括号</span></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>中的插图:</span><br><span class="line"><span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=0.25]</span><span class="string">&#123;wallpaper&#125;</span></span><span class="comment">% 输入图片名,指定缩放因子</span></span><br><span class="line"><span class="comment">%\includegraphics[height=5cm]&#123;wallpaper&#125;</span></span><br><span class="line"><span class="comment">%\includegraphics[width=10cm]&#123;wallpaper&#125;</span></span><br><span class="line"><span class="comment">%使用texdoc graphicx 查看文档</span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="8-LaTeX中的表格"><a href="#8-LaTeX中的表格" class="headerlink" title="8.LaTeX中的表格"></a>8.LaTeX中的表格</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">	  <span class="comment">% 导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  <span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line">  <span class="comment">% 正文区（文稿区）</span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|l|c|c|c|p&#123;1.5cm&#125;</span></span>|&#125;</span><br><span class="line">  		<span class="comment">% l 左对齐 c 居中对齐 r 右对齐 | 产生表格竖线 </span></span><br><span class="line">  		<span class="comment">%空格不起作用 p&#123;&lt;宽&gt;&#125;指定宽度 </span></span><br><span class="line">  		<span class="comment">%当内容超出时自动换行 &amp; 表示不同列</span></span><br><span class="line">  		<span class="comment">%texdoc booktab</span></span><br><span class="line">  		<span class="comment">%texdoc longtab</span></span><br><span class="line">  		<span class="comment">%texdoc tabu</span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		王二 &amp; 80 &amp; 82 &amp; 78 &amp; <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">  		<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  		  	</span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="9-LaTeX中的浮动体"><a href="#9-LaTeX中的浮动体" class="headerlink" title="9.LaTeX中的浮动体"></a>9.LaTeX中的浮动体</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">	<span class="comment">% 导言区</span></span><br><span class="line">  <span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line">  <span class="tag">\<span class="name">usepackage</span><span class="string">&#123;graphicx&#125;</span></span>	</span><br><span class="line">  <span class="tag">\<span class="name">graphicspath</span><span class="string">&#123;figures/&#125;</span></span></span><br><span class="line">  <span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line">  <span class="comment">% 正文区（文稿区）</span></span><br><span class="line">  <span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">  	电脑壁纸见图<span class="tag">\<span class="name">ref</span><span class="string">&#123;fig-wallpaper&#125;</span></span><span class="comment">% 实现交叉引用</span></span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">&#123;figure&#125;</span><span class="string">[htbp]</span></span><span class="comment">%图形位置 h 当前位置 t 顶部 b 底部 p 浮动页</span></span><br><span class="line">  		<span class="tag">\<span class="name">centering</span></span> <span class="comment">% 居中排列</span></span><br><span class="line">  		<span class="tag">\<span class="name">includegraphics</span><span class="string">[scale=0.25]</span><span class="string">&#123;wallpaper&#125;</span></span><span class="comment">% 输入图片名,指定缩放因子</span></span><br><span class="line">  		<span class="tag">\<span class="name">caption</span><span class="string">&#123;WallPaper&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;fig-wallpaper&#125;</span></span> <span class="comment">%设置图片名字 设置浮动体标签</span></span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">&#123;figure&#125;</span></span></span><br><span class="line">  	</span><br><span class="line">  	当然，在<span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>中也如以下使用表<span class="tag">\<span class="name">ref</span><span class="string">&#123;tab-score&#125;</span></span>所示的表格</span><br><span class="line">  	<span class="tag">\<span class="name">begin</span><span class="string">&#123;table&#125;</span><span class="string">[h]</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">centering</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">caption</span><span class="string">&#123;考试成绩单&#125;</span></span><span class="tag">\<span class="name">label</span><span class="string">&#123;tab-score&#125;</span></span></span><br><span class="line">  		<span class="tag">\<span class="name">begin</span><span class="string">&#123;tabular&#125;</span><span class="string">&#123;|l|c|c|c|r|&#125;</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			姓名 &amp; 语文 &amp; 数学 &amp; 外语 &amp; 备注 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			张三 &amp; 87 &amp; 100 &amp; 93 &amp; 优秀 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			李四 &amp; 75 &amp; 64 &amp; 52 &amp; 补考另行通知 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线</span></span><br><span class="line">  			王二 &amp; 80 &amp; 82 &amp; 78 &amp; <span class="tag">\<span class="name">\</span></span> </span><br><span class="line">  			<span class="tag">\<span class="name">hline</span></span> <span class="comment">%产生横线	</span></span><br><span class="line">  		<span class="tag">\<span class="name">end</span><span class="string">&#123;tabular&#125;</span></span></span><br><span class="line">  	<span class="tag">\<span class="name">end</span><span class="string">&#123;table&#125;</span></span></span><br><span class="line">  	</span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="10-LaTeX数学公式初步"><a href="#10-LaTeX数学公式初步" class="headerlink" title="10.LaTeX数学公式初步"></a>10.LaTeX数学公式初步</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">	<span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;article&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;ctex&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;简介&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">LaTeX</span><span class="string">&#123;&#125;</span></span>将排版内容分为文本模式和数学模式。文本模式用于普通文本排版，数学模式用于数学公式排版。</span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;行内公式&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;美元符号&#125;</span></span></span><br><span class="line">	交换律是 <span class="formula">$a+b=b+a$</span>,如 <span class="formula">$1+2=2+1=3$</span>。</span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;小括号&#125;</span></span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">(</span></span>a+b=b+a<span class="tag">\<span class="name">)</span></span>,如 <span class="tag">\<span class="name">(</span></span>1+2=2+1=3<span class="tag">\<span class="name">)</span></span>。</span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;math环境&#125;</span></span></span><br><span class="line">	交换律是 <span class="tag">\<span class="name">begin</span><span class="string">&#123;math&#125;</span></span>a+b=b+a<span class="tag">\<span class="name">end</span><span class="string">&#123;math&#125;</span></span>,如<span class="tag">\<span class="name">begin</span><span class="string">&#123;math&#125;</span></span></span><br><span class="line">	1+2=2+1=3<span class="tag">\<span class="name">end</span><span class="string">&#123;math&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;上下标&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;上标&#125;</span></span></span><br><span class="line">	<span class="formula">$3x^&#123;20&#125; - x + 2 = 0$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$3x^&#123;3x^&#123;20&#125; - x + 2&#125; - x + 2 = 0$</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;下标&#125;</span></span></span><br><span class="line">	<span class="formula">$a_0,a_1,a_2$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$a_0,a_1,a_2,...,a_&#123;3x^&#123;20&#125; - x + 2&#125;$</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;希腊字母&#125;</span></span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">alpha</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">beta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">gamma</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">epsilon</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">pi</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">omega</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Gamma</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Delta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Theta</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Pi</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">Omega</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">alpha</span></span>^3 + <span class="tag">\<span class="name">beta</span></span>^2 + <span class="tag">\<span class="name">gamma</span> = <span class="number">0</span></span>$</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;数字函数&#125;</span></span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">log</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sin</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">cos</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">arcsin</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">arccos</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">ln</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sin</span></span>^2 x + <span class="tag">\<span class="name">cos</span></span>^2 x = 1$</span></span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">arcsin</span></span> x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">sin</span></span>^&#123;-1&#125; x$</span> </span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">log</span></span>_2 x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$y = <span class="tag">\<span class="name">ln</span></span> x$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;2&#125;</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;x^2 + y^2&#125;</span></span>$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;2 + \sqrt&#123;2&#125;</span></span>&#125;$</span></span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">[4]</span><span class="string">&#123;x&#125;</span></span>$</span> <span class="comment">%通过[]指定开方的次数</span></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;分式&#125;</span></span></span><br><span class="line">	大约是原体积的<span class="formula">$3/4$</span>。</span><br><span class="line">	大约是原体积的<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;3&#125;</span><span class="string">&#123;4&#125;</span></span>$</span>。</span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;x&#125;</span><span class="string">&#123;x^2 + x +1&#125;</span></span>$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;\sqrt&#123;x-1&#125;</span></span>&#125;&#123;<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;x+1&#125;</span></span>&#125;$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">frac</span><span class="string">&#123;1&#125;</span><span class="string">&#123;1+ \frac&#123;1&#125;</span><span class="string">&#123;x&#125;</span></span>&#125;$</span></span><br><span class="line">	</span><br><span class="line">	<span class="formula">$<span class="tag">\<span class="name">sqrt</span><span class="string">&#123;\frac&#123;x&#125;</span><span class="string">&#123;x^2 + x + 1&#125;</span></span>&#125;$</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">\<span class="name">section</span><span class="string">&#123;行间公式&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;美元符号&#125;</span></span></span><br><span class="line">	交换律是 <span class="formula">$$a+b=b+a$$</span></span><br><span class="line">	如 <span class="formula">$$1+2=2+1=3$$</span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;中括号&#125;</span></span></span><br><span class="line">	 <span class="tag">\<span class="name">[</span></span>a+b=b+a<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	 如</span><br><span class="line">	 <span class="tag">\<span class="name">[</span></span>1+2=2+1=3<span class="tag">\<span class="name">]</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;displaymath环境&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">		a+b=b+a,</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span>,</span><br><span class="line">	如</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">		1+2=2+1=3.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;displaymath&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;自动编号公式equation环境&#125;</span></span></span><br><span class="line">	交换律见式<span class="tag">\<span class="name">ref</span><span class="string">&#123;eq:commutative&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">		a+b=b+a <span class="tag">\<span class="name">label</span><span class="string">&#123;eq:commutative&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">subsection</span><span class="string">&#123;不编号公式equation*环境&#125;</span></span></span><br><span class="line">	交换律见式<span class="tag">\<span class="name">ref</span><span class="string">&#123;eq:commutative2&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation*&#125;</span></span></span><br><span class="line">	a+b=b+a <span class="tag">\<span class="name">label</span><span class="string">&#123;eq:commutative2&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation*&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="11-LaTeX数学公式的矩阵"><a href="#11-LaTeX数学公式的矩阵" class="headerlink" title="11.LaTeX数学公式的矩阵"></a>11.LaTeX数学公式的矩阵</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"><span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%矩阵环境，用&amp;分隔列，用\\分隔行</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;matrix&#125;</span></span></span><br><span class="line">	0 &amp; 1<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	1 &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;matrix&#125;</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% pmatrix环境 加小括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% bmatrix环境 加中括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;bmatrix&#125;</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;bmatrix&#125;</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% Bmatrix环境 加大括号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;Bmatrix&#125;</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;Bmatrix&#125;</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% vmatrix环境 加单竖线</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;vmatrix&#125;</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;vmatrix&#125;</span></span> <span class="tag">\<span class="name">qquad</span></span></span><br><span class="line">	<span class="comment">% Vmatrix环境 加双竖线</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;Vmatrix&#125;</span></span></span><br><span class="line">	0 &amp; -i<span class="tag">\<span class="name">\</span></span></span><br><span class="line">	i &amp; 0</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;Vmatrix&#125;</span></span> </span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">% 可以使用上下标</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	A = <span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line">	a_&#123;11&#125;^2 &amp; a_&#123;12&#125;^2 &amp; a_&#123;13&#125;^2 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; a_&#123;22&#125; &amp; a_&#123;23&#125; <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; 0 &amp; a_&#123;33&#125;</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">%常用省略号：\dots,\vdots,\ddots</span></span><br><span class="line">	<span class="tag">\<span class="name">[</span></span></span><br><span class="line">	A = <span class="tag">\<span class="name">begin</span><span class="string">&#123;pmatrix&#125;</span></span></span><br><span class="line">	a_&#123;11&#125; &amp; <span class="tag">\<span class="name">dots</span></span> &amp; a_&#123;1n&#125; <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&amp; <span class="tag">\<span class="name">ddots</span></span> &amp; <span class="tag">\<span class="name">vdots</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	0 &amp; &amp; a_&#123;mn&#125;</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;pmatrix&#125;</span></span>_&#123;n <span class="tag">\<span class="name">times</span></span> n&#125;<span class="comment">% times命令排版乘号</span></span><br><span class="line">	<span class="tag">\<span class="name">]</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="12-LaTeX中的多行数学公式"><a href="#12-LaTeX中的多行数学公式" class="headerlink" title="12.LaTeX中的多行数学公式"></a>12.LaTeX中的多行数学公式</h2><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amsmath&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;amssymb&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">% gather 和 gather* 环境 (可以使用\\换行)</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">		a + b = b + a <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		ab ba</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 不带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;gather*&#125;</span></span></span><br><span class="line">	3+5 = 5+3 = 8 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	3 <span class="tag">\<span class="name">times</span></span> 5 = 5 <span class="tag">\<span class="name">times</span></span> 3</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;gather*&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% 在\\前使用\notag 阻止编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">		3^2 + 4^2 = 5^2 <span class="tag">\<span class="name">notag</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		5^2 + 12^2 = 13^2 <span class="tag">\<span class="name">notag</span></span> <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		a^2 + b^2 = c^2 </span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;gather&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% align 和 align* 环境 (用 &amp; 进行对齐)</span></span><br><span class="line">	<span class="comment">% 带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line">	x &amp;= t + <span class="tag">\<span class="name">cos</span></span> t + 1 <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	y &amp;= 2<span class="tag">\<span class="name">sin</span></span> t</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;align&#125;</span></span></span><br><span class="line">	<span class="comment">% 不带编号</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;align*&#125;</span></span></span><br><span class="line">		x &amp;= t &amp; x &amp;= <span class="tag">\<span class="name">cos</span></span> t &amp; x &amp;= t <span class="tag">\<span class="name">\</span></span></span><br><span class="line">		y &amp;= 2t &amp; y &amp;= <span class="tag">\<span class="name">sin</span></span>(t+1) &amp; y &amp;= <span class="tag">\<span class="name">sin</span></span> t </span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;align*&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% split 环境(对齐采用 align 环境的方式，编号在中间)</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;split&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">cos</span></span> 2x &amp;= <span class="tag">\<span class="name">cos</span></span>^2 x - <span class="tag">\<span class="name">sin</span></span>^2 x <span class="tag">\<span class="name">\</span></span></span><br><span class="line">	&amp;= 2<span class="tag">\<span class="name">cos</span></span>^2 x - 1</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;split&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">% cases 环境</span></span><br><span class="line">	<span class="comment">% 每行公式中使用 &amp;　分隔为两部分，</span></span><br><span class="line">	<span class="comment">%　通常表示值和后面的条件</span></span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;equation&#125;</span></span></span><br><span class="line">		D(x) = <span class="tag">\<span class="name">begin</span><span class="string">&#123;cases&#125;</span></span></span><br><span class="line">		1, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;如果 &#125;</span></span> x <span class="tag">\<span class="name">in</span></span> <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Q&#125;</span></span>; <span class="tag">\<span class="name">\</span></span> <span class="comment">%\in 用于输出属于符号 mathbb用于输出花体字符 \text&#123;&#125; 用于在数学模式中输入中文</span></span><br><span class="line">		0, &amp; <span class="tag">\<span class="name">text</span><span class="string">&#123;如果 &#125;</span></span> x <span class="tag">\<span class="name">in</span></span> <span class="tag">\<span class="name">mathbb</span><span class="string">&#123;R&#125;</span></span><span class="tag">\<span class="name">setminus</span></span><span class="tag">\<span class="name">mathbb</span><span class="string">&#123;Q&#125;</span></span>.</span><br><span class="line">		<span class="tag">\<span class="name">end</span><span class="string">&#123;cases&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;equation&#125;</span></span> </span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="13-LaTeX中的参考文献——BibTex"><a href="#13-LaTeX中的参考文献——BibTex" class="headerlink" title="13.LaTeX中的参考文献——BibTex"></a>13.LaTeX中的参考文献——BibTex</h2><ol>
<li>在构件中设置默认文献工具为BibTex</li>
<li>在谷歌学术中点击引用链接获取BibTex格式的数据</li>
<li>新建.bib后缀的文件，复制获取参考文献数据</li>
</ol>
<h3 id="tex文件如下"><a href="#tex文件如下" class="headerlink" title=".tex文件如下"></a>.tex文件如下</h3><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 导言区</span></span><br><span class="line"><span class="tag">\<span class="name">documentclass</span><span class="string">&#123;ctexart&#125;</span></span><span class="comment">%ctexbook, ctexrep</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%\usepackage&#123;ctex&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">\<span class="name">bibliographystyle</span><span class="string">&#123;plain&#125;</span></span><span class="comment">%指定排版样式 如plain unsrt alpha abbrv</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 正文区（文稿区）</span></span><br><span class="line"><span class="tag">\<span class="name">begin</span><span class="string">&#123;document&#125;</span></span></span><br><span class="line">	<span class="comment">%一次管理，一次使用</span></span><br><span class="line">	<span class="comment">%参考文献格式：</span></span><br><span class="line">	<span class="comment">%\begin&#123;thebibliography&#125;&#123;编号样本&#125;</span></span><br><span class="line">	<span class="comment">%	\bibitem[label]&#123;citekey&#125;文献条目1</span></span><br><span class="line">	<span class="comment">%   \bibitem[label]&#123;citekey&#125;文献条目2</span></span><br><span class="line">	<span class="comment">%	……</span></span><br><span class="line">	<span class="comment">%\end&#123;thebibliography&#125;</span></span><br><span class="line">	<span class="comment">%其中文献条目包括：作者，题目，出版社，年代，版本，页码等。</span></span><br><span class="line">	<span class="comment">%引用时候要可以采用：\cite&#123;引用标志1，引用标志2，……&#125;</span></span><br><span class="line">	引用一本Guide<span class="tag">\<span class="name">cite</span><span class="string">&#123;latexGuide&#125;</span></span>等等</span><br><span class="line">	<span class="tag">\<span class="name">begin</span><span class="string">&#123;thebibliography&#125;</span><span class="string">&#123;99&#125;</span></span></span><br><span class="line">		<span class="tag">\<span class="name">bibitem</span><span class="string">&#123;latexGuide&#125;</span></span> Kopka Helmut, W. Daly Patrick,</span><br><span class="line">		<span class="tag">\<span class="name">emph</span><span class="string">&#123;Guide to \LaTeX&#125;</span></span>, <span class="formula">$4^&#123;th&#125;$</span> Edition.</span><br><span class="line">		Available at <span class="tag">\<span class="name">texttt</span><span class="string">&#123;http://www.amazon.com&#125;</span></span>.</span><br><span class="line">	<span class="tag">\<span class="name">end</span><span class="string">&#123;thebibliography&#125;</span></span></span><br><span class="line">	这是一个参考文献的引用：<span class="tag">\<span class="name">cite</span><span class="string">&#123;scott1988social&#125;</span></span></span><br><span class="line">	<span class="tag">\<span class="name">bibliography</span><span class="string">&#123;test&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">end</span><span class="string">&#123;document&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="bib文件如下"><a href="#bib文件如下" class="headerlink" title=".bib文件如下"></a>.bib文件如下</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">  @article&#123;scott1988social,</span><br><span class="line">  title=&#123;Social<span class="built_in"> network </span>analysis&#125;,</span><br><span class="line">  author=&#123;Scott, John&#125;,</span><br><span class="line">  journal=&#123;Sociology&#125;,</span><br><span class="line">  volume=&#123;22&#125;,</span><br><span class="line">  number=&#123;1&#125;,</span><br><span class="line">  pages=&#123;109--127&#125;,</span><br><span class="line">  year=&#123;1988&#125;,</span><br><span class="line">  publisher=&#123;British Sociological Association Publications Limited&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-LaTeX中定义新命令和环境"><a href="#15-LaTeX中定义新命令和环境" class="headerlink" title="15.LaTeX中定义新命令和环境"></a>15.LaTeX中定义新命令和环境</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="code">	% 导言区</span></span><br><span class="line">\documentclass&#123;ctexart&#125;%ctexbook, ctexrep</span><br><span class="line"></span><br><span class="line">% \newcommand&#123;cmd&#125;&#123;def&#125;定义命令</span><br><span class="line">% 命令只能由字母组成，不能以\end 开头</span><br><span class="line">% \newcommand&#123;命令&#125;[<span class="string">参数个数</span>][<span class="symbol">首字母默认值</span>]&#123;具体定义&#125;</span><br><span class="line"></span><br><span class="line">% \newcommand可以是简单字符串替代，例如：</span><br><span class="line">% 使用\PRC 相当于 People's Republic of \emph&#123;China&#125; 这一串内容</span><br><span class="line">\newcommand\PRC&#123;People's Republic of \emph&#123;China&#125;&#125;%\emph&#123;text&#125;表示强调</span><br><span class="line"></span><br><span class="line">% \newcommand也可以使用参数</span><br><span class="line">% 参数个数可以从1到9，使用时用 #1，#2，……，#9 表示</span><br><span class="line">\newcommand\loves[2]&#123;#1 喜欢 #2&#125;</span><br><span class="line">\newcommand\hatedby[2]&#123;#2 不受 #1 喜欢&#125;</span><br><span class="line"></span><br><span class="line">% \newcommand的参数也可以有默认值</span><br><span class="line">% 指定参数个数的同时指定了首个参数的默认值，那么这个命令的</span><br><span class="line">% 第一个参数就成为可选的参数(要使用中括号指定)</span><br><span class="line">\newcommand\love[<span class="string">3</span>][<span class="symbol">喜欢</span>]&#123;#2#1#3&#125;</span><br><span class="line"></span><br><span class="line">% \renewcommand-重定义命令</span><br><span class="line">% 与\newcommand 命令作用和用法相同，但只能用于已有命令</span><br><span class="line">% \renewcommand&#123;cmd&#125;[<span class="string">args</span>][<span class="symbol">default</span>]&#123;def&#125;</span><br><span class="line">\renewcommand\abstractname&#123;内容简介&#125;</span><br><span class="line"></span><br><span class="line">% 定义和重定义环境</span><br><span class="line">% \newenvironment&#123;name&#125;[<span class="string">args</span>][<span class="symbol">default</span>]&#123;begdef&#125;&#123;enddef&#125;</span><br><span class="line">% \renewenvironment&#123;name&#125;[<span class="string">args</span>][<span class="symbol">default</span>]&#123;begdef&#125;&#123;enddef&#125;</span><br><span class="line"></span><br><span class="line">% 为 book 类中定义摘要(abstract) 环境</span><br><span class="line">\newenvironment&#123;myabstract&#125;[<span class="string">1</span>][<span class="symbol">摘要</span>]%</span><br><span class="line">&#123;\small</span><br><span class="line"><span class="code">	\begin&#123;center&#125;\bfseries #1\end&#123;center&#125;%</span></span><br><span class="line"><span class="code">	\begin&#123;quotation&#125;&#125;%</span></span><br><span class="line">&#123;	</span><br><span class="line"><span class="code">	\end&#123;quotation&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% 正文区（文稿区）</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line"><span class="code">	\PRC</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\loves&#123;猫儿&#125;&#123;鱼&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\hatedby&#123;猫儿&#125;&#123;萝卜&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\love&#123;猫儿&#125;&#123;鱼&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\love[最爱]&#123;猫儿&#125;&#123;鱼&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\begin&#123;abstract&#125;</span></span><br><span class="line"><span class="code">		这是一段摘要...</span></span><br><span class="line"><span class="code">	\end&#123;abstract&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code">	\begin&#123;myabstract&#125;[我的摘要]</span></span><br><span class="line"><span class="code">		这是一段自定义格式的摘要...</span></span><br><span class="line"><span class="code">	\end&#123;myabstract&#125;</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>

<h1 id="完整的演示代码见Github仓库https-github-com-Gemini-Lin-MCM-ICM"><a href="#完整的演示代码见Github仓库https-github-com-Gemini-Lin-MCM-ICM" class="headerlink" title="完整的演示代码见Github仓库https://github.com/Gemini-Lin/MCM-ICM"></a>完整的演示代码见Github仓库<a href="https://github.com/Gemini-Lin/MCM-ICM" target="_blank" rel="noopener">https://github.com/Gemini-Lin/MCM-ICM</a></h1>]]></content>
      <categories>
        <category>数学建模</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title>谷歌访问助手</title>
    <url>/%E8%B0%B7%E6%AD%8C%E6%9C%8D%E5%8A%A1%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p><strong>谷歌访问助手插件安装</strong>  </p>
</blockquote>

<p>1.<a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">点击文字安装谷歌浏览器</a></p>
<p>2.<a href="https://github.com/Gemini-Lin/Tookits" target="_blank" rel="noopener">点击文字下载谷歌访问助手</a></p>
<a id="more"></a>
<p>3.安装谷歌访问助手插件<br> <img src="https://s1.ax1x.com/2020/03/29/GVceEt.png" alt="GVceEt.png"></p>
<blockquote>
<p>Step1: 进入谷歌浏览器的扩展程序</p>
</blockquote>
<blockquote>
<p>Step2: 勾选开发者选项</p>
</blockquote>
<blockquote>
<p>Step3: 点击加载已解压的扩展程序</p>
</blockquote>
<blockquote>
<p>Step4: 选择下载后解压的文件</p>
</blockquote>
<blockquote>
<p>Step5: 安装成功<br><img src="https://s1.ax1x.com/2020/03/29/GVcM8S.png" alt="GVcM8S.png"><br> <img src="https://s1.ax1x.com/2020/03/29/GVcQgg.png" alt="GVcQgg.png"></p>
</blockquote>
<h2 id="VPN推荐"><a href="#VPN推荐" class="headerlink" title="VPN推荐"></a>VPN推荐</h2><p>20元一个月，特别稳定，网速快。</p>
<p><a href="https://efanccyun.net/" target="_blank" rel="noopener">饿饭CC云</a></p>
]]></content>
      <categories>
        <category>工具分享</category>
      </categories>
      <tags>
        <tag>Google</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期支教</title>
    <url>/%E6%94%AF%E6%95%99/</url>
    <content><![CDATA[<p> <strong><em>让我再看看你们</em></strong>  </p>
<blockquote>
<p><strong>“让我再看看你们”</strong>这是我在黑板上留下的最后一句话。<br><img src="https://i.loli.net/2020/03/29/eGFf2H6Y1Lvw5VT.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>这支教半个月来，我们从陌生到相识相知再到现在转身离别。<strong>这既是与学生，亦是与队员</strong>。</p>
</blockquote>
<a id="more"></a>

<blockquote>
<p>我很抱歉，在这半个月里并没有认识班上所有的小孩，有些只局限于名字。<strong>每个人心中都有一团火，路过的人都只看到烟。</strong>这是我给班上的38个孩子写完明信片后的感慨。我若看到他们心中的火，就会说一些出于真心的废话，絮絮叨叨；我若只看到他们心中的烟，便只有一些泛泛而谈的寄语，满腹诗论。<br><img src="https://i.loli.net/2020/03/29/MBjHLwJ7NhioCOy.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>支教的这半个月，自己最大的体会是孩子并不是天使，他们也有着人类阴暗与丑陋的一面。比如班上的一个女孩陈柯欣，她的脑袋有点问题，全班的小朋友都远离她，没人愿意和她一起玩。而我呢？会站在上帝视角上看待这一切，忘记自己小时候也是这副模样，甚至现在也未必改变。</p>
</blockquote>
<blockquote>
<p>对于孩子而言，最可怕的是他们腐朽的思想。尽管我也是生活在农村，但是这里的学习氛围与家里天壤之别。这里还保留着读完初中就外出打工的腐朽思想。父母对于孩子的学习，关注实在太少太少。我意识到自己仅仅给孩子们传授知识是远远不够的，我必须给他们强调学习的重要性。因此在支教的后半段，我每天都给孩子们普及大学的知识。先给他们看看北大的宣传片《星空日记》和《北大体验》，看到《星空日记》时，我也想起我自己高二的时候，看到北大的宣传片满腔热血，奔向未来，现在的我却离梦想渐行渐远了。看到《北大体验》，我的脑海里不停回荡这那句“在北大生活是一种什么样的体验，北大等着你来体验”，在我的内心深处还残存着对北大的愿景。<strong>你自由，而在一片向上生长的林中，你不会歪斜，但我失去了你，只敢在梦里拥抱着你。</strong>然后我给他们看了一下成电的招生宣传片，和一系列成电的照片，用自己在大学生活的感受去感染他们。我希望自己用着些举动，能够在他们的心中种下名为“大学”的种子。<br><img src="https://i.loli.net/2020/04/18/mIkGb1exLlwTyMJ.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p><strong>“即使有一天我失去了所有，但在祖国的大西部，我还有一群可爱的孩子”</strong>写于在教室前目送孩子们离去，我对他们大喊：“今天我就不送你们了，今后的路你们要自己走了。”</p>
</blockquote>
<blockquote>
<p><strong>“支教真的有意义吗？”</strong>这是我在支教路上在知乎关注的一个问题，今天在支教生涯结束时，我要用自己的方式给出回答。<br><img src="https://i.loli.net/2020/03/29/zFaUuGHbLNn7RSe.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>谈支教是否有意义，最为关键的问题是你是如何看待支教的，你到底为支教付出了多少。回顾我们至微这四个月为支教的筹备，一进队最为强调的一点是<strong>“支教对于你的收获是远远大于你给孩子的收获”</strong>，这一路来，我们经历了两周的义捐义卖，两天的高考文具募捐，两周的课程试讲，再到两周的正式支教。再谈我是如何看待支教的，在我的心里这是小时候的愿景，是社会的公益给我的驱使。我想要通过支教让山里的孩子们明白，他们所看到的仅仅是世界的很小一部分，他们应该去更高更远的地方，去好好看看这世界。因此，我可以确切地回答，支教是绝对有意义的。<br><img src="https://s1.ax1x.com/2020/03/29/GV61Tx.png" alt="image.png"></p>
</blockquote>
<blockquote>
<p>其实支教对我影响最大的不是<strong>支教本身，而是我身旁一起陪伴的十五名队员。</strong>当你身处在一个大环境中时，你会自然而然地被环境所影响。先谈谈舒队，作为队长，他需要把握团队的大局走向，最为关键的是控制一个“度”，比如伙食的质量，放松的时间，上课的课程，活动的安排。我印象最深的是，当我在过渡放纵的时候，会有一个改变以往逗比的形象的人，严肃地和你强调支教是为了什么。从支教的过程中，同时也是从队友的身上，发现自己的不足，便是我此行最大的收获。比如对于支教日志的撰写上，有的队友每天坚持记录至少1500字的日志，尽管里面的很多内容是记流水账，但是对于这件事上她是付出了大量的时间，与我每次几百字的支教日志形成了极大的反差。再比如活动组的成员，在每次活动前都会周密的安排，加班到凌晨一两点，相反的是我十一点多就回到了寝室。从他们的身上，我发现了优秀的原因，同时也解决我一直以来的困惑。简而言之，就是对于事情的专注，对于一件事情，做的时候必须竭尽全力、心无旁骛，这样结束时才可以尽情放松。对于学习亦是如此，我总是把学习挂在嘴边，但是每天真正学习的时长却总是很短，看似每天都在学习，其实两天的学习效率抵不过别人的一天，自然放松的时候也不能尽兴。<br><img src="https://s1.ax1x.com/2020/03/29/GV6rAP.jpg" alt="GV6rAP.jpg"></p>
</blockquote>
<blockquote>
<p>最后再回到支教本身来，谈谈这群我可能再也不会相见的38个孩子们。其实离别的时候，没有孩子流泪，我还是比较难过的，即使我确实不希望哭丧着离别，但可能是因为我对班上的孩子们付出还是太少了。作为四年级的班主任，我明显感受到自己与班上孩子的感情与任课老师差别很大的，每天一大半的时间，我都会陪在这群孩子身边。今天的最后一堂课，我和副班主任们，都和孩子们讲了一些煽情的话，关于回顾，关于离别，关于未来。我让孩子们把自己的名字都写在黑板上，让我记住他们，同时我也在黑板上写下<strong>“你这一生，我只送一程；不忍离别，但车已到站”。</strong>借用龙应台的一句话，<strong>我慢慢地、慢慢地了解到，所谓师生一场，只不过意味着，你和他们的缘分就是今生今世目送着他们的背影渐行渐远。你站在小路的这一段，看着他逐渐消失在小路转弯的地方，而且，他们用背影默默告诉你：不必追。</strong><br><img src="https://s1.ax1x.com/2020/03/29/GV6g1g.jpg" alt="GV6g1g.jpg"></p>
</blockquote>
<p><strong>未来</strong></p>
<p><strong>我让你成为你</strong></p>
<p><strong>你梦着我的梦</strong></p>
<p><strong>我写着你的诗</strong></p>
<p><strong>你点亮我的天空</strong></p>
<p><strong>我闪耀你的眼睛</strong></p>
<p><strong>从此，</strong></p>
<p><strong>山谷里多了一片</strong></p>
<p><strong>彩色森林</strong></p>
<blockquote>
<p>（这首诗送给支教的孩子们，亦是支教感悟的终点）<br><a href="https://weibo.com/u/2694121201?is_all=1" target="_blank" rel="noopener">至微公益团队微博</a></p>
</blockquote>
]]></content>
      <categories>
        <category>大学生活</category>
      </categories>
      <tags>
        <tag>体验</tag>
        <tag>支教</tag>
      </tags>
  </entry>
</search>
